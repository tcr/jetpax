------- FILE main.s LEVEL 1 PASS 2
      1  fffe					      processor	6502
      2  10000 ????
      3  10000 ????						; Nibble null methods
      4  10000 ????				       mac	nibble_start_kernel
      5  10000 ????				       seg.U	ignoreme	; comment out rest of code
      6  10000 ????				       endm
      7  10000 ????				       mac	nibble_if
      8  10000 ????				       endm
      9  10000 ????				       mac	nibble_write
     10  10000 ????				       endm
     11  10000 ????				       mac	nibble_write_opcode
     12  10000 ????				       endm
     13  10000 ????				       mac	nibble_else
     14  10000 ????				       endm
     15  10000 ????				       mac	nibble_end_if
     16  10000 ????				       endm
     17  10000 ????				       mac	nibble_end_kernel
     18  10000 ????				       seg	CodeBank3
     19  10000 ????				       endm
     20  10000 ????
     21  10000 ????
     22  10000 ????						; Perform a left rotation on the 32 bit number at
     23  10000 ????						; location VLA and store the result at location
     24  10000 ????						; RES. If VLA and RES are the same then the
     25  10000 ????						; operation is applied directly to the memory,
     26  10000 ????						; otherwise it is done in the accumulator.
     27  10000 ????						;
     28  10000 ????						; On exit: A = ??, X & Y are unchanged.
     29  10000 ????
     30  10000 ????						;http://www.obelisk.me.uk/6502/maclib.inc but reversed
     31  10000 ????				       mac	_ror32
     32  10000 ????			    VLA        EQU	{1}
     33  10000 ????			    RES        EQU	{2}
     34  10000 ????				       IF	VLA != RES
     35  10000 ????				       LDA	VLA+0
     36  10000 ????				       ROR	A
     37  10000 ????				       STA	RES+0
     38  10000 ????				       LDA	VLA+1
     39  10000 ????				       ROR	A
     40  10000 ????				       STA	RES+1
     41  10000 ????				       LDA	VLA+2
     42  10000 ????				       ROR	A
     43  10000 ????				       STA	RES+2
     44  10000 ????				       LDA	VLA+3
     45  10000 ????				       ROR	A
     46  10000 ????				       STA	RES+3
     47  10000 ????				       ELSE
     48  10000 ????				       ROR	VLA+0
     49  10000 ????				       ROR	VLA+1
     50  10000 ????				       ROR	VLA+2
     51  10000 ????				       ROR	VLA+3
     52  10000 ????				       ENDIF
     53  10000 ????				       ENDM
     54  10000 ????
     55  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     56  10000 ????				       mac	assert_runtime
     57  10000 ????			    .COND      SET	{1}
     58  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     59  10000 ????				       endm
     60  10000 ????
     61  10000 ????
     62  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     63  10000 ????				       mac	assert_runtime_kernel
     64  10000 ????			    .KERNEL    SET	{1}
     65  10000 ????			    .COND      SET	{2}
     66  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     67  10000 ????				       endm
     68  10000 ????
     69  10000 ????						; Static assertions for size
     70  10000 ????				       mac	assert_size
     71  10000 ????			    .STARTA    SET	{1}
     72  10000 ????			    .ENDA      SET	{2}
     73  10000 ????			    .LEN       SET	{3}
     74  10000 ????				       if	[[.ENDA - .STARTA] >= .LEN]
     75  10000 ????				       echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
     76  10000 ????				       err
     77  10000 ????				       endif
     78  10000 ????				       endm
     79  10000 ????				       mac	assert_size_exact
     80  10000 ????			    .STARTA    SET	{1}
     81  10000 ????			    .ENDA      SET	{2}
     82  10000 ????			    .LEN       SET	{3}
     83  10000 ????				       if	[[.ENDA - .STARTA] != .LEN]
     84  10000 ????				       echo	""
     85  10000 ????				       echo	"Error: Violated size limit", [.ENDA - .STARTA], "vs", .LEN
     86  10000 ????				       err
     87  10000 ????				       endif
     88  10000 ????				       endm
     89  10000 ????
     90  10000 ????						; Global headers
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE main.s
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????
    163  0000 ????						; EOF
------- FILE main.s
------- FILE xmacro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"xmacro.h"
      1  0000 ????
      2  0000 ????						;-------------------------------------------------------
      3  0000 ????						; Usage: TIMER_SETUP lines
      4  0000 ????						; where lines is the number of scanlines to skip (> 2).
      5  0000 ????						; The timer will be set so that it expires before this number
      6  0000 ????						; of scanlines. A WSYNC will be done first.
      7  0000 ????
      8  0000 ????				      MAC	timer_setup
      9  0000 ????			   .lines     SET	{1}
     10  0000 ????				      lda	#(((.lines)*76-14)/64)
     11  0000 ????				      sta	WSYNC
     12  0000 ????				      sta	TIM64T
     13  0000 ????				      ENDM
     14  0000 ????
     15  0000 ????						;-------------------------------------------------------
     16  0000 ????						; Use with TIMER_SETUP to wait for timer to complete.
     17  0000 ????						; You may want to do a WSYNC afterwards, since the timer
     18  0000 ????						; is not accurate to the beginning/end of a scanline.
     19  0000 ????
     20  0000 ????				      MAC	timer_wait
     21  0000 ????			   .waittimer
     22  0000 ????				      lda	INTIM
     23  0000 ????				      bne	.waittimer
     24  0000 ????				      sta	WSYNC
     25  0000 ????				      ENDM
     26  0000 ????
------- FILE main.s
     94  0000 ????
     95  0000 ????						; RAM and constants
------- FILE game_define.s LEVEL 2 PASS 2
      0  0000 ????				      include	"game_define.s"
      1 U0000 ????				      seg.u	Defines
      2 U0000 ????
      3 U0000 ????	       00 10	   ROW_COUNT  =	16
      4 U0000 ????	       00 02	   SIGNAL_LINE =	$02
      5 U0000 ????	       00 07	   FrameSkip  =	%111	; Tick (every 8 frames)
      6 U0000 ????
      7 U0000 ????						; RAM+ memory map
      8 U0000 ????
      9 U0000 ????	       f0 00	   CBSRAM_KERNEL_WRITE =	$f000
     10 U0000 ????	       f1 00	   CBSRAM_KERNEL_READ =	$f100
     11 U0000 ????	       f1 04	   CBSRAM_KERNEL_ENTRY =	[CBSRAM_KERNEL_READ + 4]
     12 U0000 ????
     13 U0000 ????	       f0 40	   RAMP_STORAGE_W =	$f040	; is this just max(frame_1_end, frame_2_end) ?
     14 U0000 ????	       f1 40	   RAMP_STORAGE_R =	$f140
     15 U0000 ????
     16 U0000 ????
     17 U0000 ????						; NUSIZ values
     18 U0000 ????
     19 U0000 ????	       00 13	   THREE_COPIES =	%00010011
     20 U0000 ????
     21 U0000 ????
     22 U0000 ????						; Colors
     23 U0000 ????
     24 U0000 ????	       00 42	   COL_BG     =	$42
     25 U0000 ????	       00 cc	   COL_EMERALD =	$CC
     26 U0000 ????	       00 cc	   COL_EMERALD_2 =	$CC
     27 U0000 ????
     28 U0000 ????
     29 U0000 ????						; HMOVE values for missiles
     30 U0000 ????
     31 U0000 ????	       00 1c	   KERNEL_A_MISSILE_SLEEP =	28
     32 U0000 ????	       00 00	   KERNEL_A_MISSILE_HMOVE =	$00
     33 U0000 ????
     34 U0000 ????	       00 33	   KERNEL_B_MISSILE_SLEEP =	51
     35 U0000 ????	       00 10	   KERNEL_B_MISSILE_HMOVE =	$10
     36 U0000 ????
     37 U0000 ????						; Missile values when 2A=RST
     38 U0000 ????						; KERNEL_B_MISSILE_SLEEP equ 46
     39 U0000 ????						; KERNEL_B_MISSILE_HMOVE equ $20
     40 U0000 ????
     41 U0000 ????
     42 U0000 ????						; Sprite details
     43 U0000 ????
     44 U0000 ????	       00 07	   EMERALD_SP_COLOR =	COLUP1
     45 U0000 ????	       00 1c	   EMERALD_SP =	GRP1
     46 U0000 ????	       00 1e	   EMERALD_MI_ENABLE =	ENAM1
     47 U0000 ????	       00 11	   EMERALD_SP_RESET =	RESP1
     48 U0000 ????	       00 13	   EMERALD_MI_RESET =	RESM1
     49 U0000 ????	       00 21	   EMERALD_SP_HMOVE =	HMP1
     50 U0000 ????	       00 23	   EMERALD_MI_HMOVE =	HMM1
     51 U0000 ????	       00 05	   EMERALD_COPIES =	NUSIZ1
     52 U0000 ????
     53 U0000 ????	       00 1b	   JET_SP     =	GRP0
     54 U0000 ????	       00 10	   JET_SP_RESET =	RESP0
     55 U0000 ????	       00 20	   JET_SP_HMOVE =	HMP0
     56 U0000 ????	       00 06	   JET_SP_COLOR =	COLUP0
     57 U0000 ????
     58 U0000 ????
     59 U0000 ????						; Game dimensionsn
     60 U0000 ????
     61 U0000 ????						; Spriteend is HEIGHT_OFFSET - YPos
     62 U0000 ????	       00 08	   SPRITE_HEIGHT =	8
     63 U0000 ????	       00 c8	   HEIGHT_OFFSET =	200
     64 U0000 ????
     65 U0000 ????						; Compared with YPos
     66 U0000 ????	       00 48	   FLOOR_OFFSET =	72
     67 U0000 ????	       00 c0	   CEILING_OFFSET =	192
     68 U0000 ????
     69 U0000 ????						; Starting player position
     70 U0000 ????	       00 48	   YPosStart  =	72
     71 U0000 ????	       00 58	   XPosStart  =	88
     72 U0000 ????
     73 U0000 ????						; Top left corner
     74 U0000 ????						; YPosStart equ 190
     75 U0000 ????						; XPosStart equ 28
------- FILE main.s
------- FILE game_vars.s LEVEL 2 PASS 2
      0 U0000 ????				      include	"game_vars.s"
      1 U00be ????				      seg.u	Variables
      2 U00be ????
      3 U0080					      org	$80
      4 U0080
      5 U0080		       00	   DebugKernelID byte.b		; which kernel are we running this frame? (for debugging)
      6 U0081
      7 U0081		       00	   Temp       byte.b
      8 U0082
      9 U0082							; Counters
     10 U0082		       00	   RowCount   byte.b
     11 U0083		       00	   LoopCount  byte.b
     12 U0084		       00	   FrameCount byte.b
     13 U0085
     14 U0085		       00	   YP1	      byte.b
     15 U0086		       00	   SpriteEnd  byte.b
     16 U0087		       00	   XPos       byte.b		; X position of player sprite
     17 U0088
     18 U0088
     19 U0088		       00	   Speed1     byte.b
     20 U0089		       00	   Speed2     byte.b
     21 U008a
     22 U008a		       00	   YPos       byte.b		; Y position of player sprite
     23 U008b		       00	   YPos2      byte.b
     24 U008c
     25 U008c		       00	   GEM_02_TARGET byte.b
     26 U008d
     27 U008d		       00	   JMP_ADDR   byte.b
     28 U008e		       00	   JMP_ADDR_2 byte.b
     29 U008f
     30 U008f		       00	   ROW_DEMO_INDEX byte.b
     31 U0090
     32 U0090		       00	   RamNibbleTemp byte.b
     33 U0091		       00	   RamNibbleVar1 byte.b
     34 U0092		       00	   RamNibbleVar2 byte.b
     35 U0093		       00	   RamZeroByte byte.b
     36 U0094		       00	   RamLowerSixByte byte.b
     37 U0095		       00	   RamFFByte  byte.b
     38 U0096		       00	   RamStackBkp byte.b
     39 U0097
     40 U0097		       00	   RamRowJetpackIndex byte.b		; sprite counter
     41 U0098
     42 U0098							; Kernel support
     43 U0098		       00	   RamPF1Value byte.b
     44 U0099		       00	   RamKernelGRP0 byte.b		; temp
     45 U009a		       00	   RamKernelPhpTarget byte.b
     46 U009b		       00	   RamKernelX byte.b
     47 U009c		       00	   RamKernelY byte.b
     48 U009d		       00	   RamKernelGemini1 byte.b
     49 U009e		       00	   RamKernelGemini1Reg byte.b
     50 U009f		       00	   RamKernelGemini2 byte.b
     51 U00a0		       00	   RamKernelGemini2Reg byte.b
     52 U00a1		       00	   RamKernelGemini3 byte.b
     53 U00a2		       00	   RamKernelGemini3Reg byte.b
     54 U00a3		       00	   RamKernelGemini4 byte.b
     55 U00a4		       00	   RamKernelGemini4Reg byte.b
     56 U00a5		       00	   RamKernelGemini5 byte.b
     57 U00a6
     58 U00a6		       00	   BuildKernelX byte.b
     59 U00a7		       00	   BuildKernelY byte.b
     60 U00a8		       00	   BuildKernelRST byte.b
     61 U00a9		       00	   BuildKernelGrp0 byte.b
     62 U00aa		       00	   BuildKernelVdel1 byte.b
     63 U00ab		       00	   BuildKernelMissile byte.b
     64 U00ac
     65 U00ac		       00	   level_for_game byte.b
     66 U00ad		       00		      byte.b
     67 U00ae		       00		      byte.b
     68 U00af		       00		      byte.b
     69 U00b0
     70 U00b0		       00	   DO_MISS_A  byte.b
     71 U00b1		       00	   DO_MISS_B  byte.b
     72 U00b2		       00	   DO_GEMS_A  byte.b
     73 U00b3		       00		      byte.b
     74 U00b4		       00		      byte.b
     75 U00b5		       00		      byte.b
     76 U00b6		       00		      byte.b
     77 U00b7		       00		      byte.b
     78 U00b8		       00	   DO_GEMS_B  byte.b
     79 U00b9		       00		      byte.b
     80 U00ba		       00		      byte.b
     81 U00bb		       00		      byte.b
     82 U00bc		       00		      byte.b
     83 U00bd		       00		      byte.b
------- FILE main.s
     98 U00be
     99 U00be							; Bank 1
    100  e000 ????				      seg	CodeBank1
    101  d000					      org	$D000
    102  d000					      rorg	$F000
    103  d000		       00	   BANK1      byte.b
    104  d200					      org	$d200
    105  d200					      rorg	$d200
    106  d200				   Bank1Start
    107  d200		       ad fa ff 	      lda	$fffa
    108  d203		       ea		      nop
    109  d204		       ea		      nop
    110  d205		       ea		      nop
    111  d206
    112  dffc					      org	$dffc
    113  dffc					      rorg	$fffc
    114  dffc		       00 d2		      .word.w	Bank1Start
    115  dffe		       00 d2		      .word.w	Bank1Start
    116  e000
    117  e000							; Bank 2
    118  f000 ????				      seg	CodeBank2
    119  e000					      org	$E000
    120  e000					      rorg	$F000
    121  e000		       00	   BANK2      byte.b
    122  e200					      org	$e200
    123  e200					      rorg	$f200
    124  e200				   Bank2Start
    125  e200		       ad fa ff 	      lda	$fffa
    126  e203		       ea		      nop
    127  e204		       ea		      nop
    128  e205		       ea		      nop
    129  e206
    130  effc					      org	$effc
    131  effc					      rorg	$fffc
    132  effc		       00 f2		      .word.w	Bank2Start
    133  effe		       00 f2		      .word.w	Bank2Start
    134  f000
    135  f000							; Bank 3
    136  10000 ????				       seg	CodeBank3
    137  f000					      org	$F000
    138  f000					      rorg	$F000
    139  f000		       00	   BANK3      byte.b
    140  f200					      org	$f200
    141  f200					      rorg	$f200
    142  f200				   Bank3Start
    143  f200		       ad fa ff 	      lda	$fffa
    144  f203		       ea		      nop
    145  f204		       ea		      nop
    146  f205		       ea		      nop
    147  f206		       4c 09 f2 	      jmp	Start
    148  f209
    149  f209							; Bank 3 source code
------- FILE game_init.s LEVEL 2 PASS 2
      0  f209					      include	"game_init.s"
      1  f209							; Game Initialization after power on or reset
      2  f209
      3  f209				   IFTRACKER  SET	1
      4  f209
      5  f209				   IFTRACKER  SET	2
      6  f209
      7  f209				   Start
      0  f209					      CLEAN_START
      1  f209		       78		      sei
      2  f20a		       d8		      cld
      3  f20b
      4  f20b		       a2 00		      ldx	#0
      5  f20d		       8a		      txa
      6  f20e		       a8		      tay
      7  f20f		       ca	   .CLEAR_STACK dex
      8  f210		       9a		      txs
      9  f211		       48		      pha
     10  f212		       d0 fb		      bne	.CLEAR_STACK
     11  f214
      9  f214
     10  f214							; Disable interrupt flag in processor status (it's useless anyway)
     11  f214		       58		      cli
     12  f215
     13  f215				   InitSetup
     14  f215		       a9 00		      lda	#0
     15  f217		       85 84		      sta	FrameCount
     16  f219
     17  f219							; P0 has three copies
     18  f219		       a9 13		      lda	#%00010011
     19  f21b		       85 05		      sta	EMERALD_COPIES
     20  f21d
     21  f21d		       a9 00		      lda	#$00
     22  f21f		       85 09		      sta	COLUBK
     23  f221		       a9 01		      lda	#%00000001
     24  f223		       85 0a		      sta	CTRLPF	; reflect playfield
     25  f225
     26  f225							; Disable VDEL
     27  f225		       a9 00		      lda	#0
     28  f227		       85 25		      sta	VDELP0
     29  f229		       85 26		      sta	VDELP1
     30  f22b
     31  f22b							; Player 0
     32  f22b		       a2 cc		      ldx	#COL_EMERALD
     33  f22d		       86 07		      stx	EMERALD_SP_COLOR
     34  f22f
     35  f22f							; Player 1
     36  f22f		       a9 0f		      lda	#$0f
     37  f231		       85 06		      sta	JET_SP_COLOR
     38  f233		       a9 00		      lda	#$00
     39  f235		       85 1b		      sta	JET_SP
     40  f237
     41  f237							; Positions
     42  f237		       a9 48		      lda	#YPosStart
     43  f239		       85 8a		      sta	YPos
     44  f23b		       a9 58		      lda	#XPosStart
     45  f23d		       85 87		      sta	XPos
     46  f23f		       a9 00		      lda	#0
     47  f241		       85 88		      sta	Speed1
     48  f243		       85 89		      sta	Speed2
     49  f245		       85 8b		      sta	YPos2
     50  f247
     51  f247		       a9 00		      lda	#0
     52  f249		       85 8f		      sta	ROW_DEMO_INDEX
     53  f24b
     54  f24b							; Store 0 into RamZeroByte
     55  f24b		       a9 00		      lda	#0
     56  f24d		       85 93		      sta	RamZeroByte
     57  f24f		       a9 3f		      lda	#%00111111
     58  f251		       85 94		      sta	RamLowerSixByte
     59  f253		       a9 ff		      lda	#$ff
     60  f255		       85 95		      sta	RamFFByte
     61  f257
     62  f257							; Setup level.
     63  f257		       20 d6 fa 	      jsr	game_state_setup
     64  f25a
     65  f25a							; Start with vertical sync (to reset frame)
     66  f25a		       4c 00 f4 	      jmp	VerticalSync
------- FILE main.s
------- FILE kernel_loader.s LEVEL 2 PASS 2
      0  f25d					      include	"kernel_loader.s"
      1  f25d							; Copies the gem kernels to RAM
      2  f25d
      3  f25d							; Copy Kernel A to CBSRAM
      4  f25d				   LoadKernelA subroutine
      5  f25d		       a0 37		      ldy	#(kernel_1_end - kernel_1_start)-1
      6  f25f				   .loop
      7  f25f		       b9 00 fd 	      lda	kernel_1_start,Y
      8  f262		       99 00 10 	      sta	$1000,Y
      9  f265		       88		      dey
     10  f266		       d0 f7		      bne	.loop
     11  f268		       ad 00 fd 	      lda	kernel_1_start
     12  f26b		       8d 00 10 	      sta	$1000
     13  f26e		       60		      rts
     14  f26f
     15  f26f							; Copy Kernel B to CBSRAM
     16  f26f				   LoadKernelB subroutine
     17  f26f		       a0 37		      ldy	#(kernel_2_end - kernel_2_start)-1
     18  f271				   .loop
     19  f271		       b9 38 fd 	      lda	kernel_2_start,Y
     20  f274		       99 00 10 	      sta	$1000,Y
     21  f277		       88		      dey
     22  f278		       d0 f7		      bne	.loop
     23  f27a		       ad 38 fd 	      lda	kernel_2_start
     24  f27d		       8d 00 10 	      sta	$1000
     25  f280		       60		      rts
------- FILE main.s
------- FILE nibble.s LEVEL 2 PASS 2
      0  f281					      include	"nibble.s"
      1  f281
      2  f281					      MAC	nibble_gem_kernel_a_1_build
      3  f281					      lda	#0
      4  f281					      ldx	#SENTINEL
      5  f281					      stx	BuildKernelX
      6  f281					      stx	BuildKernelY
      7  f281					      stx	BuildKernelRST
      8  f281							; Gemini 1A
      9  f281				   .K_1A
     10  f281					      ldy	[DO_GEMS_A + 0]
     11  f281					      jsr	KernelA_GenReset
     12  f281				   .if_1
     13  f281					      bne	.else_1
     14  f281					      sec
     15  f281					      rol
     16  f281							; Special: Encoding RST0
     17  f281							; Rewrite lda RamKernelPF1 to be #immediate
     18  f281					      ldy	#BC_LDA_IMM
     19  f281					      sty	[KernelA_B - $100]
     20  f281					      ldy	#%10100000
     21  f281					      sty	[KernelA_B - $100 + 1]
     22  f281							; Store 1A in GRP0
     23  f281					      ldy	[DO_GEMS_A + 1]
     24  f281					      sty	BuildKernelGrp0
     25  f281							; Gemini 1A is RESPx
     26  f281					      ldy	#EMERALD_SP_RESET
     27  f281					      sty	[KernelA_C - $100 + 1]
     28  f281							; Turn 3-cycle NOP into 4-cycle
     29  f281					      ldy	#$14
     30  f281					      sty	[KernelA_D - $100]
     31  f281					      jmp	.endif_1
     32  f281							; [BIT DEPTH] #1 If-End @ 1
     33  f281					      rol
     34  f281
     35  f281				   .else_1
     36  f281					      clc
     37  f281					      rol
     38  f281							; Store 0A in GRP0
     39  f281					      ldy	[DO_GEMS_A + 0]
     40  f281					      sty	BuildKernelGrp0
     41  f281					      ldy	[DO_GEMS_A + 1]
     42  f281					      jsr	KernelA_GenReset
     43  f281				   .if_2
     44  f281					      bne	.else_2
     45  f281					      sec
     46  f281					      rol
     47  f281							; GEM1ASWITCH
     48  f281					      jmp	.endif_2
     49  f281							; [BIT DEPTH] #2 If-End @ 2
     50  f281
     51  f281				   .else_2
     52  f281					      clc
     53  f281					      rol
     54  f281							; Calculate the 1A value
     55  f281					      ldy	SHARD_LUT_RF1
     56  f281					      cpy	#1
     57  f281					      .byte	$D0, #3
     58  f281					      ldy	#RESP1
     59  f281					      .byte	$2C
     60  f281					      ldy	#GRP1
     61  f281					      sty	RamKernelGemini1Reg
     62  f281							; Set opcode
     63  f281					      ldx	SHARD_LUT_RF1
     64  f281					      cpx	#1
     65  f281					      ldy	#BC_STX
     66  f281					      .byte	$F0, #5
     67  f281					      ldy	[DO_GEMS_A + 1]
     68  f281					      jsr	KernelA_UpdateRegs
     69  f281					      sty	RamKernelGemini1
     70  f281							; [BIT DEPTH] #2 *If-End @ 2
     71  f281							; [BIT DEPTH] #2 Else-End @ 2
     72  f281				   .endif_2
     73  f281							; [BIT DEPTH] #1 *If-End @ 1
     74  f281							; [BIT DEPTH] #1 Else-End @ 2
     75  f281				   .endif_1
     76  f281							; BuildKernelX, BuildKernelY are upgraded if not set
     77  f281							; Gemini 2A
     78  f281				   .K_2A
     79  f281					      ldy	[DO_GEMS_A + 2]
     80  f281					      jsr	KernelA_GenReset
     81  f281				   .if_3
     82  f281					      bne	.else_3
     83  f281					      sec
     84  f281					      rol
     85  f281					      jmp	.endif_3
     86  f281							; [BIT DEPTH] #3 If-End @ 3
     87  f281
     88  f281				   .else_3
     89  f281					      clc
     90  f281					      rol
     91  f281							; Set opcode
     92  f281					      ldy	[DO_GEMS_A + 2]
     93  f281					      jsr	KernelA_UpdateRegs
     94  f281					      sty	RamKernelGemini2
     95  f281							; Set opcode target
     96  f281					      ldy	SHARD_LUT_RF1
     97  f281					      cpy	#2
     98  f281					      .byte	$D0, #3
     99  f281					      ldy	#RESP1
    100  f281					      .byte	$2C
    101  f281					      ldy	#GRP1
    102  f281					      sty	RamKernelGemini2Reg
    103  f281							; [BIT DEPTH] #3 *If-End @ 3
    104  f281							; [BIT DEPTH] #3 Else-End @ 3
    105  f281				   .endif_3
    106  f281							; Gemini 3A
    107  f281				   .K_3A
    108  f281					      ldy	[DO_GEMS_A + 3]
    109  f281					      jsr	KernelA_GenReset
    110  f281				   .if_4
    111  f281					      bne	.else_4
    112  f281					      sec
    113  f281					      rol
    114  f281					      jmp	.endif_4
    115  f281							; [BIT DEPTH] #4 If-End @ 4
    116  f281
    117  f281				   .else_4
    118  f281					      clc
    119  f281					      rol
    120  f281							; Set opcode
    121  f281					      ldy	[DO_GEMS_A + 3]
    122  f281					      jsr	KernelA_UpdateRegs
    123  f281					      sty	RamKernelGemini3
    124  f281							; Set opcode target
    125  f281					      ldy	SHARD_LUT_RF1
    126  f281					      cpy	#3
    127  f281					      .byte	$D0, #3
    128  f281					      ldy	#RESP1
    129  f281					      .byte	$2C
    130  f281					      ldy	#GRP1
    131  f281					      sty	RamKernelGemini3Reg
    132  f281							; [BIT DEPTH] #4 *If-End @ 4
    133  f281							; [BIT DEPTH] #4 Else-End @ 4
    134  f281				   .endif_4
    135  f281							; [BIT DEPTH] Final: 4 (out of 8 bits)
    136  f281					      rol
    137  f281					      rol
    138  f281					      rol
    139  f281					      rol
    140  f281					      ENDM
    141  f281
    142  f281					      MAC	nibble_gem_kernel_a_2_build
    143  f281					      lda	#0
    144  f281							; VD1 default
    145  f281					      ldx	[DO_GEMS_A + 1]
    146  f281					      stx	BuildKernelVdel1
    147  f281							; Gemini 4A
    148  f281					      ldx	SHARD_LUT_VD1
    149  f281					      cpx	#4
    150  f281				   .if_1
    151  f281					      beq	.else_1
    152  f281					      sec
    153  f281					      rol
    154  f281							; Set PHP
    155  f281							; Update VDEL1
    156  f281					      ldx	[DO_GEMS_A + 4]
    157  f281					      stx	BuildKernelVdel1
    158  f281					      jmp	.endif_1
    159  f281							; [BIT DEPTH] #1 If-End @ 1
    160  f281
    161  f281				   .else_1
    162  f281					      clc
    163  f281					      rol
    164  f281					      ldy	[DO_GEMS_A + 4]
    165  f281					      jsr	KernelA_UpdateRegs
    166  f281					      sty	RamKernelGemini4
    167  f281							; Set PHP
    168  f281							; [BIT DEPTH] #1 *If-End @ 1
    169  f281							; [BIT DEPTH] #1 Else-End @ 1
    170  f281				   .endif_1
    171  f281							; Misisle
    172  f281					      ldy	DO_MISS_A
    173  f281				   .if_2
    174  f281					      bne	.else_2
    175  f281					      sec
    176  f281					      rol
    177  f281					      jmp	.endif_2
    178  f281							; [BIT DEPTH] #2 If-End @ 2
    179  f281
    180  f281				   .else_2
    181  f281					      clc
    182  f281					      rol
    183  f281							; [BIT DEPTH] #2 *If-End @ 2
    184  f281							; [BIT DEPTH] #2 Else-End @ 2
    185  f281				   .endif_2
    186  f281							; VD1
    187  f281							; GRP0
    188  f281							; X
    189  f281							; Y
    190  f281							; Gemini 5A
    191  f281							; TODO eventually...?
    192  f281							; [BIT DEPTH] Final: 2 (out of 8 bits)
    193  f281					      rol
    194  f281					      rol
    195  f281					      rol
    196  f281					      rol
    197  f281					      rol
    198  f281					      rol
    199  f281					      ENDM
    200  f281
    201  f281					      MAC	nibble_gem_kernel_b_build
    202  f281					      lda	#0
    203  f281							; Php target default
    204  f281					      ldx	#RESP1
    205  f281					      stx	RamKernelPhpTarget
    206  f281					      ldx	#SENTINEL
    207  f281					      stx	BuildKernelX
    208  f281					      stx	BuildKernelY
    209  f281					      stx	BuildKernelRST
    210  f281							; Gemini 0B
    211  f281					      ldy	[DO_GEMS_B + 0]
    212  f281					      sty	BuildKernelGrp0
    213  f281							; NIBBLE_WRITE KernelB_D_W, RamKernelGemini0
    214  f281							; Gemini 1B
    215  f281					      ldy	[DO_GEMS_B + 1]
    216  f281					      jsr	KernelA_UpdateRegs
    217  f281					      sty	RamKernelGemini1
    218  f281							; Calculate Gemini 2B
    219  f281					      ldy	[DO_GEMS_B + 2]
    220  f281					      jsr	KernelB_UpdateRegs
    221  f281					      sty	RamKernelGemini2
    222  f281							; Calculate Gemini 3B
    223  f281					      ldy	[DO_GEMS_B + 3]
    224  f281					      jsr	KernelB_UpdateRegs
    225  f281					      sty	RamKernelGemini3
    226  f281							; Gemini 2B
    227  f281					      ldy	[DO_GEMS_B + 2]
    228  f281					      jsr	KernelB_GenPhp
    229  f281				   .if_1
    230  f281					      bne	.else_1
    231  f281					      sec
    232  f281					      rol
    233  f281							; Write to PHP in 2B
    234  f281					      cpy	G11
    235  f281				   .if_2
    236  f281					      beq	.else_2
    237  f281					      sec
    238  f281					      rol
    239  f281					      jmp	.endif_2
    240  f281							; [BIT DEPTH] #2 If-End @ 2
    241  f281
    242  f281				   .else_2
    243  f281					      clc
    244  f281					      rol
    245  f281							; [BIT DEPTH] #2 *If-End @ 2
    246  f281							; [BIT DEPTH] #2 Else-End @ 2
    247  f281				   .endif_2
    248  f281					      jmp	.endif_1
    249  f281							; [BIT DEPTH] #1 If-End @ 2
    250  f281
    251  f281				   .else_1
    252  f281					      clc
    253  f281					      rol
    254  f281							; [BIT DEPTH] #1 *If-End @ 2
    255  f281							; [BIT DEPTH] #1 Else-End @ 1
    256  f281					      rol
    257  f281				   .endif_1
    258  f281							; Gemini 3B
    259  f281					      ldy	[DO_GEMS_B + 3]
    260  f281					      jsr	KernelB_GenPhp
    261  f281				   .if_3
    262  f281					      beq	.else_3
    263  f281					      sec
    264  f281					      rol
    265  f281							; Write to PHP in 3B
    266  f281							; TODO compare this in the outside by checking KernelB_GenPhp value
    267  f281					      cpy	G11
    268  f281				   .if_4
    269  f281					      bne	.else_4
    270  f281					      sec
    271  f281					      rol
    272  f281					      jmp	.endif_4
    273  f281							; [BIT DEPTH] #4 If-End @ 4
    274  f281
    275  f281				   .else_4
    276  f281					      clc
    277  f281					      rol
    278  f281							; [BIT DEPTH] #4 *If-End @ 4
    279  f281							; [BIT DEPTH] #4 Else-End @ 4
    280  f281				   .endif_4
    281  f281					      jmp	.endif_3
    282  f281							; [BIT DEPTH] #3 If-End @ 4
    283  f281
    284  f281				   .else_3
    285  f281					      clc
    286  f281					      rol
    287  f281							; [BIT DEPTH] #3 *If-End @ 4
    288  f281							; [BIT DEPTH] #3 Else-End @ 3
    289  f281					      rol
    290  f281				   .endif_3
    291  f281							; Gemini 4B
    292  f281					      ldy	[DO_GEMS_B + 4]
    293  f281					      jsr	KernelA_UpdateRegs
    294  f281					      sty	RamKernelGemini4
    295  f281							; TODO if no PHP, rewrite previous section:
    296  f281							; NIBBLE_IF cs
    297  f281							;
    298  f281							;     NIBBLE_WRITE [KernelB_E_W + 0], #BC_PHP
    299  f281							;     NIBBLE_WRITE [KernelB_F_W + 0], #BC_STY, #EMERALD_SP
    300  f281							;     NIBBLE_WRITE [KernelB_G_W + 0], #BC_STA, #PF1
    301  f281							;     NIBBLE_WRITE [KernelB_H_W + 0], #BC_STY, #EMERALD_SP
    302  f281							; NIBBLE_END_IF
    303  f281							; Make adjustments for sprites.
    304  f281					      ror	BuildKernelGrp0
    305  f281					      ror	BuildKernelX
    306  f281					      ror	BuildKernelY
    307  f281							;
    308  f281							; NIBBLE_WRITE [KernelB_VDEL1 - $100], BuildKernelVdel1
    309  f281							; GRP0
    310  f281							; X
    311  f281							; Y
    312  f281							; [BIT DEPTH] Final: 4 (out of 8 bits)
    313  f281					      rol
    314  f281					      rol
    315  f281					      rol
    316  f281					      rol
    317  f281					      ENDM
    318  f281
    319  f281
    320  f281					      MAC	nibble_gem_kernel_a_1
    321  f281				   .if_1
    322  f281					      asl
    323  f281					      bcc	.else_1
    324  f281					      jmp	.endif_1
    325  f281				   .else_1
    326  f281				   .if_2
    327  f281					      asl
    328  f281					      bcc	.else_2
    329  f281					      ldx	#BC_STX
    330  f281					      stx	[KernelA_D_W + 0]
    331  f281					      ldx	#RESP1
    332  f281					      stx	[KernelA_D_W + 1]
    333  f281					      jmp	.endif_2
    334  f281				   .else_2
    335  f281					      ldx	RamKernelGemini1
    336  f281					      stx	[KernelA_D_W + 0]
    337  f281					      ldx	RamKernelGemini1Reg
    338  f281					      stx	[KernelA_D_W + 1]
    339  f281				   .endif_2
    340  f281				   .endif_1
    341  f281				   .if_3
    342  f281					      asl
    343  f281					      bcc	.else_3
    344  f281					      ldx	#NOP_REG
    345  f281					      stx	[KernelA_E_W + 1 + 0]
    346  f281					      ldx	#RESP1
    347  f281					      stx	[KernelA_G_W + 1 + 0]
    348  f281					      jmp	.endif_3
    349  f281				   .else_3
    350  f281					      ldx	#RESP1
    351  f281					      stx	[KernelA_E_W + 1 + 0]
    352  f281					      ldx	RamKernelGemini2
    353  f281					      stx	[KernelA_G_W + 0]
    354  f281					      ldx	RamKernelGemini2Reg
    355  f281					      stx	[KernelA_G_W + 1]
    356  f281				   .endif_3
    357  f281				   .if_4
    358  f281					      asl
    359  f281					      bcc	.else_4
    360  f281					      ldx	#RESP1
    361  f281					      stx	[KernelA_H_W + 1 + 0]
    362  f281					      jmp	.endif_4
    363  f281				   .else_4
    364  f281					      ldx	RamKernelGemini3
    365  f281					      stx	[KernelA_H_W + 0]
    366  f281					      ldx	RamKernelGemini3Reg
    367  f281					      stx	[KernelA_H_W + 1]
    368  f281				   .endif_4
    369  f281					      ENDM
    370  f281
    371  f281					      MAC	nibble_gem_kernel_a_2
    372  f281				   .if_1
    373  f281					      asl
    374  f281					      bcc	.else_1
    375  f281					      ldx	#BC_STA
    376  f281					      stx	[[KernelA_I_W + 0] + 0]
    377  f281					      ldx	#EMERALD_SP_RESET
    378  f281					      stx	[[KernelA_I_W + 0] + 1]
    379  f281					      ldx	#BC_STA
    380  f281					      stx	[[KernelA_J_W + 1] + 0]
    381  f281					      ldx	#PF1
    382  f281					      stx	[[KernelA_J_W + 1] + 1]
    383  f281					      ldx	#BC_PHP
    384  f281					      stx	[[KernelA_K_W + 1] + 0]
    385  f281					      ldx	#VDELP1
    386  f281					      stx	[RamKernelPhpTarget + 0]
    387  f281					      jmp	.endif_1
    388  f281				   .else_1
    389  f281					      ldx	#BC_PHP
    390  f281					      stx	[[KernelA_I_W + 0] + 0]
    391  f281					      ldx	#BC_STA
    392  f281					      stx	[[KernelA_J_W + 0] + 0]
    393  f281					      ldx	#PF1
    394  f281					      stx	[[KernelA_J_W + 0] + 1]
    395  f281					      ldx	RamKernelGemini4
    396  f281					      stx	[KernelA_K_W + 0]
    397  f281					      ldx	#EMERALD_SP
    398  f281					      stx	[KernelA_K_W + 1]
    399  f281					      ldx	#RESP1
    400  f281					      stx	[RamKernelPhpTarget + 0]
    401  f281				   .endif_1
    402  f281				   .if_2
    403  f281					      asl
    404  f281					      bcc	.else_2
    405  f281					      ldx	#BC_NOP
    406  f281					      stx	[[KernelA_F - $100] + 0]
    407  f281					      jmp	.endif_2
    408  f281				   .else_2
    409  f281					      ldx	BuildKernelMissile
    410  f281					      stx	[[KernelA_F - $100] + 0]
    411  f281				   .endif_2
    412  f281					      ldx	BuildKernelVdel1
    413  f281					      stx	[[KernelA_VDEL1 - $100] + 0]
    414  f281					      ldx	BuildKernelGrp0
    415  f281					      stx	[[KernelA_VDEL0 - $100] + 0]
    416  f281					      ldx	BuildKernelX
    417  f281					      stx	[RamKernelX + 0]
    418  f281					      ldx	BuildKernelY
    419  f281					      stx	[RamKernelY + 0]
    420  f281					      ENDM
    421  f281
    422  f281					      MAC	nibble_gem_kernel_b
    423  f281					      ldx	RamKernelGemini1
    424  f281					      stx	[KernelB_D_W + 0]
    425  f281				   .if_1
    426  f281					      asl
    427  f281					      bcc	.else_1
    428  f281					      ldx	#EMERALD_SP
    429  f281					      stx	[RamKernelPhpTarget + 0]
    430  f281					      ldx	#BC_STY
    431  f281					      stx	[[KernelB_E_W + 0] + 0]
    432  f281					      ldx	#EMERALD_SP_RESET
    433  f281					      stx	[[KernelB_E_W + 0] + 1]
    434  f281					      ldx	#BC_PHP
    435  f281					      stx	[[KernelB_F_W + 1] + 0]
    436  f281					      ldx	#BC_STA
    437  f281					      stx	[[KernelB_G_W + 0] + 0]
    438  f281					      ldx	#PF1
    439  f281					      stx	[[KernelB_G_W + 0] + 1]
    440  f281					      ldx	RamKernelGemini3
    441  f281					      stx	[[KernelB_H_W + 0] + 0]
    442  f281					      ldx	#EMERALD_SP
    443  f281					      stx	[[KernelB_H_W + 0] + 1]
    444  f281				   .if_2
    445  f281					      asl
    446  f281					      bcc	.else_2
    447  f281					      ldx	#$38
    448  f281					      stx	[[KernelB_P11_C - $100] + 0]
    449  f281					      ldx	#RamZeroByte
    450  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    451  f281					      jmp	.endif_2
    452  f281				   .else_2
    453  f281					      ldx	#$18
    454  f281					      stx	[[KernelB_P11_C - $100] + 0]
    455  f281					      ldx	#RamLowerSixByte
    456  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    457  f281				   .endif_2
    458  f281					      jmp	.endif_1
    459  f281				   .else_1
    460  f281					      ldx	RamKernelGemini2
    461  f281					      stx	[KernelB_F_W + 0]
    462  f281					      ldx	#EMERALD_SP
    463  f281					      stx	[KernelB_F_W + 1]
    464  f281				   .endif_1
    465  f281				   .if_3
    466  f281					      asl
    467  f281					      bcc	.else_3
    468  f281					      ldx	#EMERALD_SP
    469  f281					      stx	[RamKernelPhpTarget + 0]
    470  f281					      ldx	#BC_STY
    471  f281					      stx	[[KernelB_E_W + 0] + 0]
    472  f281					      ldx	#EMERALD_SP_RESET
    473  f281					      stx	[[KernelB_E_W + 0] + 1]
    474  f281					      ldx	RamKernelGemini2
    475  f281					      stx	[[KernelB_F_W + 1] + 0]
    476  f281					      ldx	#EMERALD_SP
    477  f281					      stx	[[KernelB_F_W + 1] + 1]
    478  f281					      ldx	#BC_STA
    479  f281					      stx	[[KernelB_G_W + 1] + 0]
    480  f281					      ldx	#PF1
    481  f281					      stx	[[KernelB_G_W + 1] + 1]
    482  f281					      ldx	#BC_PHP
    483  f281					      stx	[[KernelB_H_W + 1] + 0]
    484  f281				   .if_4
    485  f281					      asl
    486  f281					      bcc	.else_4
    487  f281					      ldx	#$38
    488  f281					      stx	[[KernelB_P11_C - $100] + 0]
    489  f281					      ldx	#RamZeroByte
    490  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    491  f281					      jmp	.endif_4
    492  f281				   .else_4
    493  f281					      ldx	#$18
    494  f281					      stx	[[KernelB_P11_C - $100] + 0]
    495  f281					      ldx	#RamLowerSixByte
    496  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    497  f281				   .endif_4
    498  f281					      jmp	.endif_3
    499  f281				   .else_3
    500  f281					      ldx	RamKernelGemini3
    501  f281					      stx	[KernelB_H_W + 0]
    502  f281					      ldx	#EMERALD_SP
    503  f281					      stx	[KernelB_H_W + 1]
    504  f281				   .endif_3
    505  f281					      ldx	RamKernelGemini4
    506  f281					      stx	[KernelB_J_W + 0]
    507  f281					      ldx	BuildKernelGrp0
    508  f281					      stx	[[KernelB_VDEL0 - $100] + 0]
    509  f281					      ldx	BuildKernelX
    510  f281					      stx	[RamKernelX + 0]
    511  f281					      ldx	BuildKernelY
    512  f281					      stx	[RamKernelY + 0]
    513  f281					      ENDM
    514  f281
    515  f281
------- FILE main.s
------- FILE nibble_shard.s LEVEL 2 PASS 2
      0  f281					      include	"nibble_shard.s"
      1  f281							; conflict: 11011000 #%0011 #%1000
      2  f281							; conflict: 11011001 #%0011 #%1000
      3  f281							; conflict: 11011010 #%0011 #%1000
      4  f281							; conflict: 11011011 #%0011 #%1000
      5  f281							; conflict: 11100100 #%1000 #%0011
      6  f281							; conflict: 11100101 #%1000 #%0011
      7  f281							; conflict: 11100110 #%1000 #%0011
      8  f281							; conflict: 11100111 #%1000 #%0011
      9  f281							; conflict: 01111000 #%1000 #%0001
     10  f281							; conflict: 01111001 #%1000 #%0001
     11  f281							; conflict: 01111010 #%1000 #%0001
     12  f281							; conflict: 01111011 #%1000 #%0001
     13  f281							; conflict: 10110100 #%1000 #%0001
     14  f281							; conflict: 10110101 #%1000 #%0001
     15  f281							; conflict: 10110110 #%1000 #%0001
     16  f281							; conflict: 10110111 #%1000 #%0001
     17  f300		       00 00 00 00*	      align	256
     18  f300		       00	   .shard_0   .byte.b	#0
     19  f301		       00	   .shard_1   .byte.b	#0
     20  f302		       00	   .shard_2   .byte.b	#0
     21  f303		       00	   .shard_3   .byte.b	#0
     22  f304		       00	   .shard_4   .byte.b	#0
     23  f305		       00	   .shard_5   .byte.b	#0
     24  f306		       00	   .shard_6   .byte.b	#0
     25  f307		       00	   .shard_7   .byte.b	#0
     26  f308		       00	   .shard_8   .byte.b	#0
     27  f309		       00	   .shard_9   .byte.b	#0
     28  f30a		       00	   .shard_10  .byte.b	#0
     29  f30b		       00	   .shard_11  .byte.b	#0
     30  f30c		       00	   .shard_12  .byte.b	#0
     31  f30d		       00	   .shard_13  .byte.b	#0
     32  f30e		       00	   .shard_14  .byte.b	#0
     33  f30f		       00	   .shard_15  .byte.b	#0
     34  f310		       00	   .shard_16  .byte.b	#0
     35  f311		       00	   .shard_17  .byte.b	#0
     36  f312		       00	   .shard_18  .byte.b	#0
     37  f313		       00	   .shard_19  .byte.b	#0
     38  f314		       00	   .shard_20  .byte.b	#0
     39  f315		       00	   .shard_21  .byte.b	#0
     40  f316		       00	   .shard_22  .byte.b	#0
     41  f317		       00	   .shard_23  .byte.b	#0
     42  f318		       00	   .shard_24  .byte.b	#0
     43  f319		       00	   .shard_25  .byte.b	#0
     44  f31a		       00	   .shard_26  .byte.b	#0
     45  f31b		       00	   .shard_27  .byte.b	#0
     46  f31c		       00	   .shard_28  .byte.b	#0
     47  f31d		       00	   .shard_29  .byte.b	#0
     48  f31e		       00	   .shard_30  .byte.b	#0
     49  f31f		       00	   .shard_31  .byte.b	#0
     50  f320		       00	   .shard_32  .byte.b	#0
     51  f321		       00	   .shard_33  .byte.b	#0
     52  f322		       00	   .shard_34  .byte.b	#0
     53  f323		       00	   .shard_35  .byte.b	#0
     54  f324		       00	   .shard_36  .byte.b	#0
     55  f325		       00	   .shard_37  .byte.b	#0
     56  f326		       00	   .shard_38  .byte.b	#0
     57  f327		       00	   .shard_39  .byte.b	#0
     58  f328		       00	   .shard_40  .byte.b	#0
     59  f329		       00	   .shard_41  .byte.b	#0
     60  f32a		       00	   .shard_42  .byte.b	#0
     61  f32b		       00	   .shard_43  .byte.b	#0
     62  f32c		       00	   .shard_44  .byte.b	#0
     63  f32d		       00	   .shard_45  .byte.b	#0
     64  f32e		       00	   .shard_46  .byte.b	#0
     65  f32f		       00	   .shard_47  .byte.b	#0
     66  f330		       00	   .shard_48  .byte.b	#0
     67  f331		       00	   .shard_49  .byte.b	#0
     68  f332		       00	   .shard_50  .byte.b	#0
     69  f333		       00	   .shard_51  .byte.b	#0
     70  f334		       00	   .shard_52  .byte.b	#0
     71  f335		       00	   .shard_53  .byte.b	#0
     72  f336		       00	   .shard_54  .byte.b	#0
     73  f337		       00	   .shard_55  .byte.b	#0
     74  f338		       00	   .shard_56  .byte.b	#0
     75  f339		       00	   .shard_57  .byte.b	#0
     76  f33a		       00	   .shard_58  .byte.b	#0
     77  f33b		       00	   .shard_59  .byte.b	#0
     78  f33c		       00	   .shard_60  .byte.b	#0
     79  f33d		       00	   .shard_61  .byte.b	#0
     80  f33e		       00	   .shard_62  .byte.b	#0
     81  f33f		       00	   .shard_63  .byte.b	#0
     82  f340		       00	   .shard_64  .byte.b	#0
     83  f341		       00	   .shard_65  .byte.b	#0
     84  f342		       00	   .shard_66  .byte.b	#0
     85  f343		       00	   .shard_67  .byte.b	#0
     86  f344		       00	   .shard_68  .byte.b	#0
     87  f345		       00	   .shard_69  .byte.b	#0
     88  f346		       00	   .shard_70  .byte.b	#0
     89  f347		       00	   .shard_71  .byte.b	#0
     90  f348		       00	   .shard_72  .byte.b	#0
     91  f349		       00	   .shard_73  .byte.b	#0
     92  f34a		       00	   .shard_74  .byte.b	#0
     93  f34b		       00	   .shard_75  .byte.b	#0
     94  f34c		       00	   .shard_76  .byte.b	#0
     95  f34d		       00	   .shard_77  .byte.b	#0
     96  f34e		       00	   .shard_78  .byte.b	#0
     97  f34f		       00	   .shard_79  .byte.b	#0
     98  f350		       00	   .shard_80  .byte.b	#0
     99  f351		       00	   .shard_81  .byte.b	#0
    100  f352		       00	   .shard_82  .byte.b	#0
    101  f353		       00	   .shard_83  .byte.b	#0
    102  f354		       00	   .shard_84  .byte.b	#0
    103  f355		       00	   .shard_85  .byte.b	#0
    104  f356		       00	   .shard_86  .byte.b	#0
    105  f357		       00	   .shard_87  .byte.b	#0
    106  f358		       00	   .shard_88  .byte.b	#0
    107  f359		       00	   .shard_89  .byte.b	#0
    108  f35a		       00	   .shard_90  .byte.b	#0
    109  f35b		       00	   .shard_91  .byte.b	#0
    110  f35c		       00	   .shard_92  .byte.b	#0
    111  f35d		       00	   .shard_93  .byte.b	#0
    112  f35e		       00	   .shard_94  .byte.b	#0
    113  f35f		       00	   .shard_95  .byte.b	#0
    114  f360		       00	   .shard_96  .byte.b	#0
    115  f361		       00	   .shard_97  .byte.b	#0
    116  f362		       00	   .shard_98  .byte.b	#0
    117  f363		       00	   .shard_99  .byte.b	#0
    118  f364		       00	   .shard_100 .byte.b	#0
    119  f365		       00	   .shard_101 .byte.b	#0
    120  f366		       00	   .shard_102 .byte.b	#0
    121  f367		       00	   .shard_103 .byte.b	#0
    122  f368		       00	   .shard_104 .byte.b	#0
    123  f369		       00	   .shard_105 .byte.b	#0
    124  f36a		       00	   .shard_106 .byte.b	#0
    125  f36b		       00	   .shard_107 .byte.b	#0
    126  f36c		       02	   .shard_108 .byte.b	#%0010
    127  f36d		       02	   .shard_109 .byte.b	#%0010
    128  f36e		       02	   .shard_110 .byte.b	#%0010
    129  f36f		       02	   .shard_111 .byte.b	#%0010
    130  f370		       00	   .shard_112 .byte.b	#0
    131  f371		       00	   .shard_113 .byte.b	#0
    132  f372		       00	   .shard_114 .byte.b	#0
    133  f373		       00	   .shard_115 .byte.b	#0
    134  f374		       00	   .shard_116 .byte.b	#0
    135  f375		       00	   .shard_117 .byte.b	#0
    136  f376		       00	   .shard_118 .byte.b	#0
    137  f377		       00	   .shard_119 .byte.b	#0
    138  f378		       08	   .shard_120 .byte.b	#%1000
    139  f379		       08	   .shard_121 .byte.b	#%1000
    140  f37a		       08	   .shard_122 .byte.b	#%1000
    141  f37b		       08	   .shard_123 .byte.b	#%1000
    142  f37c		       00	   .shard_124 .byte.b	#0
    143  f37d		       00	   .shard_125 .byte.b	#0
    144  f37e		       00	   .shard_126 .byte.b	#0
    145  f37f		       00	   .shard_127 .byte.b	#0
    146  f380		       00	   .shard_128 .byte.b	#0
    147  f381		       00	   .shard_129 .byte.b	#0
    148  f382		       00	   .shard_130 .byte.b	#0
    149  f383		       00	   .shard_131 .byte.b	#0
    150  f384		       00	   .shard_132 .byte.b	#0
    151  f385		       00	   .shard_133 .byte.b	#0
    152  f386		       00	   .shard_134 .byte.b	#0
    153  f387		       00	   .shard_135 .byte.b	#0
    154  f388		       00	   .shard_136 .byte.b	#0
    155  f389		       00	   .shard_137 .byte.b	#0
    156  f38a		       00	   .shard_138 .byte.b	#0
    157  f38b		       00	   .shard_139 .byte.b	#0
    158  f38c		       00	   .shard_140 .byte.b	#0
    159  f38d		       00	   .shard_141 .byte.b	#0
    160  f38e		       00	   .shard_142 .byte.b	#0
    161  f38f		       00	   .shard_143 .byte.b	#0
    162  f390		       00	   .shard_144 .byte.b	#0
    163  f391		       00	   .shard_145 .byte.b	#0
    164  f392		       00	   .shard_146 .byte.b	#0
    165  f393		       00	   .shard_147 .byte.b	#0
    166  f394		       00	   .shard_148 .byte.b	#0
    167  f395		       00	   .shard_149 .byte.b	#0
    168  f396		       00	   .shard_150 .byte.b	#0
    169  f397		       00	   .shard_151 .byte.b	#0
    170  f398		       00	   .shard_152 .byte.b	#0
    171  f399		       00	   .shard_153 .byte.b	#0
    172  f39a		       00	   .shard_154 .byte.b	#0
    173  f39b		       00	   .shard_155 .byte.b	#0
    174  f39c		       02	   .shard_156 .byte.b	#%0010
    175  f39d		       02	   .shard_157 .byte.b	#%0010
    176  f39e		       02	   .shard_158 .byte.b	#%0010
    177  f39f		       02	   .shard_159 .byte.b	#%0010
    178  f3a0		       00	   .shard_160 .byte.b	#0
    179  f3a1		       00	   .shard_161 .byte.b	#0
    180  f3a2		       00	   .shard_162 .byte.b	#0
    181  f3a3		       00	   .shard_163 .byte.b	#0
    182  f3a4		       00	   .shard_164 .byte.b	#0
    183  f3a5		       00	   .shard_165 .byte.b	#0
    184  f3a6		       00	   .shard_166 .byte.b	#0
    185  f3a7		       00	   .shard_167 .byte.b	#0
    186  f3a8		       00	   .shard_168 .byte.b	#0
    187  f3a9		       00	   .shard_169 .byte.b	#0
    188  f3aa		       00	   .shard_170 .byte.b	#0
    189  f3ab		       00	   .shard_171 .byte.b	#0
    190  f3ac		       00	   .shard_172 .byte.b	#0
    191  f3ad		       00	   .shard_173 .byte.b	#0
    192  f3ae		       00	   .shard_174 .byte.b	#0
    193  f3af		       00	   .shard_175 .byte.b	#0
    194  f3b0		       00	   .shard_176 .byte.b	#0
    195  f3b1		       00	   .shard_177 .byte.b	#0
    196  f3b2		       00	   .shard_178 .byte.b	#0
    197  f3b3		       00	   .shard_179 .byte.b	#0
    198  f3b4		       08	   .shard_180 .byte.b	#%1000
    199  f3b5		       08	   .shard_181 .byte.b	#%1000
    200  f3b6		       08	   .shard_182 .byte.b	#%1000
    201  f3b7		       08	   .shard_183 .byte.b	#%1000
    202  f3b8		       00	   .shard_184 .byte.b	#0
    203  f3b9		       00	   .shard_185 .byte.b	#0
    204  f3ba		       00	   .shard_186 .byte.b	#0
    205  f3bb		       00	   .shard_187 .byte.b	#0
    206  f3bc		       00	   .shard_188 .byte.b	#0
    207  f3bd		       00	   .shard_189 .byte.b	#0
    208  f3be		       00	   .shard_190 .byte.b	#0
    209  f3bf		       00	   .shard_191 .byte.b	#0
    210  f3c0		       00	   .shard_192 .byte.b	#0
    211  f3c1		       00	   .shard_193 .byte.b	#0
    212  f3c2		       00	   .shard_194 .byte.b	#0
    213  f3c3		       00	   .shard_195 .byte.b	#0
    214  f3c4		       00	   .shard_196 .byte.b	#0
    215  f3c5		       00	   .shard_197 .byte.b	#0
    216  f3c6		       00	   .shard_198 .byte.b	#0
    217  f3c7		       00	   .shard_199 .byte.b	#0
    218  f3c8		       00	   .shard_200 .byte.b	#0
    219  f3c9		       00	   .shard_201 .byte.b	#0
    220  f3ca		       00	   .shard_202 .byte.b	#0
    221  f3cb		       00	   .shard_203 .byte.b	#0
    222  f3cc		       00	   .shard_204 .byte.b	#0
    223  f3cd		       00	   .shard_205 .byte.b	#0
    224  f3ce		       00	   .shard_206 .byte.b	#0
    225  f3cf		       00	   .shard_207 .byte.b	#0
    226  f3d0		       00	   .shard_208 .byte.b	#0
    227  f3d1		       00	   .shard_209 .byte.b	#0
    228  f3d2		       00	   .shard_210 .byte.b	#0
    229  f3d3		       00	   .shard_211 .byte.b	#0
    230  f3d4		       00	   .shard_212 .byte.b	#0
    231  f3d5		       00	   .shard_213 .byte.b	#0
    232  f3d6		       00	   .shard_214 .byte.b	#0
    233  f3d7		       00	   .shard_215 .byte.b	#0
    234  f3d8		       03	   .shard_216 .byte.b	#%0011
    235  f3d9		       03	   .shard_217 .byte.b	#%0011
    236  f3da		       03	   .shard_218 .byte.b	#%0011
    237  f3db		       03	   .shard_219 .byte.b	#%0011
    238  f3dc		       00	   .shard_220 .byte.b	#0
    239  f3dd		       00	   .shard_221 .byte.b	#0
    240  f3de		       00	   .shard_222 .byte.b	#0
    241  f3df		       00	   .shard_223 .byte.b	#0
    242  f3e0		       00	   .shard_224 .byte.b	#0
    243  f3e1		       00	   .shard_225 .byte.b	#0
    244  f3e2		       00	   .shard_226 .byte.b	#0
    245  f3e3		       00	   .shard_227 .byte.b	#0
    246  f3e4		       08	   .shard_228 .byte.b	#%1000
    247  f3e5		       08	   .shard_229 .byte.b	#%1000
    248  f3e6		       08	   .shard_230 .byte.b	#%1000
    249  f3e7		       08	   .shard_231 .byte.b	#%1000
    250  f3e8		       00	   .shard_232 .byte.b	#0
    251  f3e9		       00	   .shard_233 .byte.b	#0
    252  f3ea		       00	   .shard_234 .byte.b	#0
    253  f3eb		       00	   .shard_235 .byte.b	#0
    254  f3ec		       00	   .shard_236 .byte.b	#0
    255  f3ed		       00	   .shard_237 .byte.b	#0
    256  f3ee		       00	   .shard_238 .byte.b	#0
    257  f3ef		       00	   .shard_239 .byte.b	#0
    258  f3f0		       00	   .shard_240 .byte.b	#0
    259  f3f1		       00	   .shard_241 .byte.b	#0
    260  f3f2		       00	   .shard_242 .byte.b	#0
    261  f3f3		       00	   .shard_243 .byte.b	#0
    262  f3f4		       00	   .shard_244 .byte.b	#0
    263  f3f5		       00	   .shard_245 .byte.b	#0
    264  f3f6		       00	   .shard_246 .byte.b	#0
    265  f3f7		       00	   .shard_247 .byte.b	#0
    266  f3f8		       00	   .shard_248 .byte.b	#0
    267  f3f9		       00	   .shard_249 .byte.b	#0
    268  f3fa		       00	   .shard_250 .byte.b	#0
    269  f3fb		       00	   .shard_251 .byte.b	#0
    270  f3fc		       00	   .shard_252 .byte.b	#0
    271  f3fd		       00	   .shard_253 .byte.b	#0
    272  f3fe		       00	   .shard_254 .byte.b	#0
    273  f3ff		       00	   .shard_255 .byte.b	#0
------- FILE main.s
------- FILE game_frame.s LEVEL 2 PASS 2
      0  f400					      include	"game_frame.s"
      1  f400
      2  f400							; Vertical Sync
      3  f400				   VerticalSync subroutine
      0  f400					      VERTICAL_SYNC
      1  f400		       a9 0e		      lda	#%1110
      2  f402		       85 02	   .VSLP1     sta	WSYNC
      3  f404		       85 00		      sta	VSYNC
      4  f406		       4a		      lsr
      5  f407		       d0 f9		      bne	.VSLP1
      5  f409
      6  f409				   FrameStart subroutine
      7  f409							; FIXME we can't skip this: ASSERT_RUNTIME "_scan == #0"
      8  f409
      9  f409				   VerticalBlank subroutine
      0  f409					      TIMER_SETUP	37
      1  f409				   .lines     SET	37
      2  f409		       a9 2b		      lda	#(((.lines)*76-14)/64)
      3  f40b		       85 02		      sta	WSYNC
      4  f40d		       8d 96 02 	      sta	TIM64T
     11  f410
     12  f410							; Scanline counter
     13  f410		       a9 10		      lda	#ROW_COUNT
     14  f412		       85 83		      sta	LoopCount
     15  f414
     16  f414							; Frame counter
     17  f414		       e6 84		      inc	FrameCount
     18  f416
     19  f416							; Skip every 8 frames for increasing demo index
     20  f416		       a5 84		      lda	FrameCount
     21  f418		       29 07		      and	#FrameSkip
     22  f41a		       c9 07		      cmp	#FrameSkip
     23  f41c		       d0 0d		      bne	.next_next_thing
     24  f41e
     25  f41e		       18		      clc
     26  f41f		       a5 8f		      lda	ROW_DEMO_INDEX
     27  f421		       69 04		      adc	#4
     28  f423		       c9 68		      cmp	#[level_01_end - level_01]
     29  f425		       90 02		      bcc	.next_thing_local
     30  f427		       a9 00		      lda	#0
     31  f429				   .next_thing_local
     32  f429		       85 8f		      sta	ROW_DEMO_INDEX
     33  f42b				   .next_next_thing
     34  f42b		       85 02		      sta	WSYNC
     35  f42d
     36  f42d							; Positioning
      0  f42d					      SLEEP	40
      1  f42d				   .CYCLES    SET	40
      2  f42d
      3  f42d				  -	      IF	.CYCLES < 2
      4  f42d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f42d				  -	      ERR
      6  f42d					      ENDIF
      7  f42d
      8  f42d				  -	      IF	.CYCLES & 1
      9  f42d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f42d				  -	      nop	0
     11  f42d				  -	      ELSE
     12  f42d				  -	      bit	VSYNC
     13  f42d				  -	      ENDIF
     14  f42d				  -.CYCLES    SET	.CYCLES - 3
     15  f42d					      ENDIF
     16  f42d
     17  f42d					      REPEAT	.CYCLES / 2
     18  f42d		       ea		      nop
     17  f42d					      REPEND
     18  f42e		       ea		      nop
     17  f42e					      REPEND
     18  f42f		       ea		      nop
     17  f42f					      REPEND
     18  f430		       ea		      nop
     17  f430					      REPEND
     18  f431		       ea		      nop
     17  f431					      REPEND
     18  f432		       ea		      nop
     17  f432					      REPEND
     18  f433		       ea		      nop
     17  f433					      REPEND
     18  f434		       ea		      nop
     17  f434					      REPEND
     18  f435		       ea		      nop
     17  f435					      REPEND
     18  f436		       ea		      nop
     17  f436					      REPEND
     18  f437		       ea		      nop
     17  f437					      REPEND
     18  f438		       ea		      nop
     17  f438					      REPEND
     18  f439		       ea		      nop
     17  f439					      REPEND
     18  f43a		       ea		      nop
     17  f43a					      REPEND
     18  f43b		       ea		      nop
     17  f43b					      REPEND
     18  f43c		       ea		      nop
     17  f43c					      REPEND
     18  f43d		       ea		      nop
     17  f43d					      REPEND
     18  f43e		       ea		      nop
     17  f43e					      REPEND
     18  f43f		       ea		      nop
     17  f43f					      REPEND
     18  f440		       ea		      nop
     19  f441					      REPEND
     38  f441		       85 11		      sta	EMERALD_SP_RESET	; position 1st player
     39  f443		       85 02		      sta	WSYNC
     40  f445
     41  f445							; Misc
     42  f445		       a9 00		      lda	#00
     43  f447		       85 1e		      sta	EMERALD_MI_ENABLE
     44  f449
     45  f449							; Assign dervied SpriteEnd value
     46  f449		       18		      clc
     47  f44a		       a9 c8		      lda	#HEIGHT_OFFSET
     48  f44c		       e5 8a		      sbc	YPos
     49  f44e		       85 86		      sta	SpriteEnd
     50  f450
     51  f450							; Player 1
     52  f450		       a5 87		      lda	XPos
     53  f452		       a2 00		      ldx	#0
     54  f454		       20 bd f5 	      jsr	SetHorizPos
     55  f457
     56  f457				   frame_setup subroutine
     57  f457							; Kernel A or B
     58  f457		       a9 01		      lda	#01
     59  f459		       25 84		      and	FrameCount
     60  f45b		       d0 20		      bne	frame_setup_kernel_b
     61  f45d
     62  f45d				   frame_setup_kernel_a subroutine
     63  f45d							; Load kernel into CBSRAM
     64  f45d		       20 5d f2 	      jsr	LoadKernelA
     65  f460
     66  f460							; Move missile
     67  f460		       85 02		      sta	WSYNC
      0  f462					      sleep	KERNEL_A_MISSILE_SLEEP
      1  f462				   .CYCLES    SET	KERNEL_A_MISSILE_SLEEP
      2  f462
      3  f462				  -	      IF	.CYCLES < 2
      4  f462				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f462				  -	      ERR
      6  f462					      ENDIF
      7  f462
      8  f462				  -	      IF	.CYCLES & 1
      9  f462				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f462				  -	      nop	0
     11  f462				  -	      ELSE
     12  f462				  -	      bit	VSYNC
     13  f462				  -	      ENDIF
     14  f462				  -.CYCLES    SET	.CYCLES - 3
     15  f462					      ENDIF
     16  f462
     17  f462					      REPEAT	.CYCLES / 2
     18  f462		       ea		      nop
     17  f462					      REPEND
     18  f463		       ea		      nop
     17  f463					      REPEND
     18  f464		       ea		      nop
     17  f464					      REPEND
     18  f465		       ea		      nop
     17  f465					      REPEND
     18  f466		       ea		      nop
     17  f466					      REPEND
     18  f467		       ea		      nop
     17  f467					      REPEND
     18  f468		       ea		      nop
     17  f468					      REPEND
     18  f469		       ea		      nop
     17  f469					      REPEND
     18  f46a		       ea		      nop
     17  f46a					      REPEND
     18  f46b		       ea		      nop
     17  f46b					      REPEND
     18  f46c		       ea		      nop
     17  f46c					      REPEND
     18  f46d		       ea		      nop
     17  f46d					      REPEND
     18  f46e		       ea		      nop
     17  f46e					      REPEND
     18  f46f		       ea		      nop
     19  f470					      REPEND
     69  f470		       85 13		      sta	EMERALD_MI_RESET
     70  f472		       a9 00		      lda	#KERNEL_A_MISSILE_HMOVE
     71  f474		       85 23		      sta	EMERALD_MI_HMOVE
     72  f476
     73  f476							; DEBUG: Set per-kernel color
     74  f476		       a2 cc		      ldx	#COL_EMERALD
     75  f478		       86 07		      stx	EMERALD_SP_COLOR
     76  f47a
     77  f47a		       4c a6 f4 	      jmp	frame_setup_complete
     78  f47d
     79  f47d				   frame_setup_kernel_b subroutine
     80  f47d							; Load kernel into CBSRAM
     81  f47d		       20 6f f2 	      jsr	LoadKernelB
     82  f480
     83  f480							; Move missile
     84  f480		       85 02		      sta	WSYNC
      0  f482					      sleep	KERNEL_B_MISSILE_SLEEP
      1  f482				   .CYCLES    SET	KERNEL_B_MISSILE_SLEEP
      2  f482
      3  f482				  -	      IF	.CYCLES < 2
      4  f482				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f482				  -	      ERR
      6  f482					      ENDIF
      7  f482
      8  f482					      IF	.CYCLES & 1
      9  f482					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f482		       04 00		      nop	0
     11  f484				  -	      ELSE
     12  f484				  -	      bit	VSYNC
     13  f484					      ENDIF
     14  f484				   .CYCLES    SET	.CYCLES - 3
     15  f484					      ENDIF
     16  f484
     17  f484					      REPEAT	.CYCLES / 2
     18  f484		       ea		      nop
     17  f484					      REPEND
     18  f485		       ea		      nop
     17  f485					      REPEND
     18  f486		       ea		      nop
     17  f486					      REPEND
     18  f487		       ea		      nop
     17  f487					      REPEND
     18  f488		       ea		      nop
     17  f488					      REPEND
     18  f489		       ea		      nop
     17  f489					      REPEND
     18  f48a		       ea		      nop
     17  f48a					      REPEND
     18  f48b		       ea		      nop
     17  f48b					      REPEND
     18  f48c		       ea		      nop
     17  f48c					      REPEND
     18  f48d		       ea		      nop
     17  f48d					      REPEND
     18  f48e		       ea		      nop
     17  f48e					      REPEND
     18  f48f		       ea		      nop
     17  f48f					      REPEND
     18  f490		       ea		      nop
     17  f490					      REPEND
     18  f491		       ea		      nop
     17  f491					      REPEND
     18  f492		       ea		      nop
     17  f492					      REPEND
     18  f493		       ea		      nop
     17  f493					      REPEND
     18  f494		       ea		      nop
     17  f494					      REPEND
     18  f495		       ea		      nop
     17  f495					      REPEND
     18  f496		       ea		      nop
     17  f496					      REPEND
     18  f497		       ea		      nop
     17  f497					      REPEND
     18  f498		       ea		      nop
     17  f498					      REPEND
     18  f499		       ea		      nop
     17  f499					      REPEND
     18  f49a		       ea		      nop
     17  f49a					      REPEND
     18  f49b		       ea		      nop
     19  f49c					      REPEND
     86  f49c		       85 13		      sta	EMERALD_MI_RESET
     87  f49e		       a9 10		      lda	#KERNEL_B_MISSILE_HMOVE
     88  f4a0		       85 23		      sta	EMERALD_MI_HMOVE
     89  f4a2
     90  f4a2							; DEBUG: Set per-kernel color
     91  f4a2		       a2 e4		      ldx	#$e4
     92  f4a4							; ldx #COL_EMERALD
     93  f4a4		       86 07		      stx	EMERALD_SP_COLOR
     94  f4a6
     95  f4a6				   frame_setup_complete
     96  f4a6
     97  f4a6							; Extract 26-bit string to full Gemini profile
     98  f4a6		       20 00 fa 	      jsr	gemini_populate
     99  f4a9							; Run nibble populate.
    100  f4a9		       20 2c f6 	      jsr	game_nibble_populate
    101  f4ac
    102  f4ac				   VerticalBlankEnd
    103  f4ac							; Wait until the end of Vertical blank.
      0  f4ac					      TIMER_WAIT
      1  f4ac				   .waittimer
      2  f4ac		       ad 84 02 	      lda	INTIM
      3  f4af		       d0 fb		      bne	.waittimer
      4  f4b1		       85 02		      sta	WSYNC
      0  f4b3					      ASSERT_RUNTIME	"_scan == #37"
      1  f4b3				   .COND      SET	"_scan == #37"
 ASSERT: breakif { pc== $f4b3  && !(  _scan == #37  ) }
      2  f4b3					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    106  f4b3
    107  f4b3							; Save stack pointer
    108  f4b3		       ba		      tsx
    109  f4b4		       86 96		      stx	RamStackBkp
    110  f4b6
    111  f4b6							; Start rendering the kernel.
    112  f4b6		       4c 02 fb 	      jmp	KernelBorder
    113  f4b9
    114  f500		       00 00 00 00*	      align	256	; TODO why
    115  f500
    116  f500				   FrameEnd   subroutine
    117  f500		       85 02		      sta	WSYNC
    118  f502
    119  f502							; Blank all background colors.
    120  f502		       a9 00		      lda	#0
    121  f504		       85 08		      sta	COLUPF
    122  f506		       85 0f		      sta	PF2
    123  f508		       85 0e		      sta	PF1
    124  f50a		       85 1c		      sta	EMERALD_SP
    125  f50c
    126  f50c							; Guide lines (2x)
    127  f50c		       a9 02		      lda	#SIGNAL_LINE
    128  f50e		       85 09		      sta	COLUBK
    129  f510					      REPEAT	6
    130  f510		       85 02		      sta	WSYNC
    129  f510					      REPEND
    130  f512		       85 02		      sta	WSYNC
    129  f512					      REPEND
    130  f514		       85 02		      sta	WSYNC
    129  f514					      REPEND
    130  f516		       85 02		      sta	WSYNC
    129  f516					      REPEND
    130  f518		       85 02		      sta	WSYNC
    129  f518					      REPEND
    130  f51a		       85 02		      sta	WSYNC
    131  f51c					      REPEND
    132  f51c		       a9 00		      lda	#$00
    133  f51e		       85 09		      sta	COLUBK
    134  f520
    135  f520							; Restore stack pointer
    136  f520		       a6 96		      ldx	RamStackBkp
    137  f522		       9a		      txs
    138  f523
    139  f523							; Display the rest of the blank screen.
      0  f523					      TIMER_SETUP	25
      1  f523				   .lines     SET	25
      2  f523		       a9 1d		      lda	#(((.lines)*76-14)/64)
      3  f525		       85 02		      sta	WSYNC
      4  f527		       8d 96 02 	      sta	TIM64T
    141  f52a		       85 02		      sta	WSYNC
      0  f52c					      TIMER_WAIT
      1  f52c				   .waittimer
      2  f52c		       ad 84 02 	      lda	INTIM
      3  f52f		       d0 fb		      bne	.waittimer
      4  f531		       85 02		      sta	WSYNC
      0  f533					      ASSERT_RUNTIME	"_scan == (#37 + #184)"
      1  f533				   .COND      SET	"_scan == (#37 + #184)"
 ASSERT: breakif { pc== $f533  && !(  _scan == (#37 + #184)  ) }
      2  f533					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    144  f533
    145  f533							; Overscan
    146  f533				   Overscan   subroutine
    147  f533		       85 01		      sta	VBLANK
      0  f535					      TIMER_SETUP	29
      1  f535				   .lines     SET	29
      2  f535		       a9 22		      lda	#(((.lines)*76-14)/64)
      3  f537		       85 02		      sta	WSYNC
      4  f539		       8d 96 02 	      sta	TIM64T
    149  f53c
    150  f53c		       20 4f f5 	      jsr	MoveJoystick
    151  f53f		       20 86 f5 	      jsr	SpeedCalculation
    152  f542		       20 e7 fa 	      jsr	game_state_tick
    153  f545
      0  f545					      TIMER_WAIT
      1  f545				   .waittimer
      2  f545		       ad 84 02 	      lda	INTIM
      3  f548		       d0 fb		      bne	.waittimer
      4  f54a		       85 02		      sta	WSYNC
      0  f54c					      ASSERT_RUNTIME	"_scan == (#37 + #184 + #29)"
      1  f54c				   .COND      SET	"_scan == (#37 + #184 + #29)"
 ASSERT: breakif { pc== $f54c  && !(  _scan == (#37 + #184 + #29)  ) }
      2  f54c					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    156  f54c
    157  f54c		       4c 00 f4 	      jmp	VerticalSync
------- FILE main.s
------- FILE game_input.s LEVEL 2 PASS 2
      0  f54f					      include	"game_input.s"
      1  f54f							; Handles input checking. Called from overscan.
      2  f54f
      3  f54f							; Read joystick movement and apply to object 0
      4  f54f				   MoveJoystick
      5  f54f							; Move vertically
      6  f54f							; (up and down are actually reversed since ypos starts at bottom)
      7  f54f							;     ldx YPos
      8  f54f		       a9 10		      lda	#%00010000	;Up?
      9  f551		       2c 80 02 	      bit	SWCHA
     10  f554		       d0 0d		      bne	SkipMoveUp
     11  f556
     12  f556		       18		      clc
     13  f557		       a5 89		      lda	Speed2
     14  f559		       69 0c		      adc	#12
     15  f55b		       85 89		      sta	Speed2
     16  f55d		       a5 88		      lda	Speed1
     17  f55f		       69 00		      adc	#00
     18  f561		       85 88		      sta	Speed1
     19  f563
     20  f563				   SkipMoveUp
     21  f563		       a6 87		      ldx	XPos
     22  f565
     23  f565							; Only check left/right on odd frames;
     24  f565							; TODO make this just a fractional speed
     25  f565							; rather than dropping frames
     26  f565		       a9 01		      lda	#01
     27  f567		       25 84		      and	FrameCount
     28  f569		       d0 18		      bne	SkipMoveRight
     29  f56b
     30  f56b
     31  f56b							; Move horizontally
     32  f56b		       a9 40		      lda	#%01000000	;Left?
     33  f56d		       2c 80 02 	      bit	SWCHA
     34  f570		       d0 05		      bne	SkipMoveLeft
     35  f572		       e0 1d		      cpx	#29
     36  f574		       90 01		      bcc	SkipMoveLeft
     37  f576		       ca		      dex
     38  f577
     39  f577							; Reflect
     40  f577							;     lda #$ff
     41  f577							;     sta REFP0
     42  f577				   SkipMoveLeft
     43  f577		       a9 80		      lda	#%10000000	;Right?
     44  f579		       2c 80 02 	      bit	SWCHA
     45  f57c		       d0 05		      bne	SkipMoveRight
     46  f57e		       e0 80		      cpx	#128
     47  f580		       b0 01		      bcs	SkipMoveRight
     48  f582		       e8		      inx
     49  f583
     50  f583							; Reflect
     51  f583							;     lda #$0
     52  f583							;     sta REFP0
     53  f583				   SkipMoveRight
     54  f583		       86 87		      stx	XPos
     55  f585		       60		      rts
     56  f586
     57  f586
     58  f586				   SpeedCalculation
     59  f586		       38		      sec
     60  f587		       a5 89		      lda	Speed2
     61  f589		       e9 07		      sbc	#7
     62  f58b		       85 89		      sta	Speed2
     63  f58d		       a5 88		      lda	Speed1
     64  f58f		       e9 00		      sbc	#0
     65  f591		       85 88		      sta	Speed1
     66  f593
     67  f593		       18		      clc
     68  f594		       a5 8b		      lda	YPos2
     69  f596		       65 89		      adc	Speed2
     70  f598		       85 8b		      sta	YPos2
     71  f59a		       a5 8a		      lda	YPos
     72  f59c		       65 88		      adc	Speed1
     73  f59e		       85 8a		      sta	YPos
     74  f5a0
     75  f5a0		       c9 48		      cmp	#FLOOR_OFFSET
     76  f5a2		       b0 0a		      bcs	NewThing2
     77  f5a4
     78  f5a4							; Reset to floor
     79  f5a4		       a9 48		      lda	#FLOOR_OFFSET
     80  f5a6		       85 8a		      sta	YPos
     81  f5a8		       a9 00		      lda	#0
     82  f5aa		       85 88		      sta	Speed1
     83  f5ac		       85 89		      sta	Speed2
     84  f5ae				   NewThing2
     85  f5ae
     86  f5ae		       c9 c0		      cmp	#CEILING_OFFSET
     87  f5b0		       90 0a		      bcc	.next
     88  f5b2
     89  f5b2							; Reset to ceiling
     90  f5b2		       a9 c0		      lda	#CEILING_OFFSET
     91  f5b4		       85 8a		      sta	YPos
     92  f5b6		       a9 00		      lda	#0
     93  f5b8		       85 88		      sta	Speed1
     94  f5ba		       85 89		      sta	Speed2
     95  f5bc				   .next
     96  f5bc		       60		      rts
     97  f5bd
     98  f5bd
     99  f5bd
    100  f5bd							; Subroutine
    101  f5bd				   SetHorizPos
    102  f5bd		       85 02		      sta	WSYNC	; start a new line
    103  f5bf		       24 00		      bit	0	; waste 3 cycles
    104  f5c1		       38		      sec		; set carry flag
    105  f5c2				   DivideLoop
    106  f5c2		       e9 0f		      sbc	#15	; subtract 15
    107  f5c4		       b0 fc		      bcs	DivideLoop	; branch until negative
    108  f5c6		       49 07		      eor	#7	; calculate fine offset
    109  f5c8		       0a		      asl
    110  f5c9		       0a		      asl
    111  f5ca		       0a		      asl
    112  f5cb		       0a		      asl
    113  f5cc		       95 10		      sta	JET_SP_RESET,x	; fix coarse position
    114  f5ce		       95 20		      sta	JET_SP_HMOVE,x	; set fine offset
    115  f5d0		       60		      rts		; return to caller
------- FILE main.s
------- FILE game_nibble.s LEVEL 2 PASS 2
      0  f5d1					      include	"game_nibble.s"
      1  f5d1							; Frame loop, including calling out to other kernels.
      2  f5d1
      3  f5d1		       00 aa	   SENTINEL   =	%010101010
      4  f5d1
      5  f5d1							; Reflected for Kernel A
      6  f5d1		       00 00	   G00	      =	%00000000
      7  f5d1		       00 60	   G01	      =	%01100000
      8  f5d1		       00 06	   G10	      =	%00000110
      9  f5d1		       00 66	   G11	      =	%01100110
     10  f5d1
     11  f5d1		       00 a9	   BC_LDA_IMM =	$a9
     12  f5d1		       00 85	   BC_STA     =	$85
     13  f5d1		       00 86	   BC_STX     =	$86
     14  f5d1		       00 84	   BC_STY     =	$84
     15  f5d1		       00 08	   BC_PHP     =	$08
     16  f5d1		       00 04	   BC_NOP     =	$04
     17  f5d1
     18  f5d1		       00 79	   NOP_REG    =	$79	; TODO is there a better reg to write to with NOP effects
     19  f5d1
     20  f5d1				   KernelA_D_W EQM	[KernelA_D - $100]
     21  f5d1				   KernelA_E_W EQM	[KernelA_E - $100]
     22  f5d1				   KernelA_G_W EQM	[KernelA_G - $100]
     23  f5d1				   KernelA_H_W EQM	[KernelA_H - $100]
     24  f5d1				   KernelA_I_W EQM	[KernelA_I - $100]
     25  f5d1				   KernelA_J_W EQM	[KernelA_J - $100]
     26  f5d1				   KernelA_K_W EQM	[KernelA_K - $100]
     27  f5d1
     28  f5d1				   KernelB_D_W EQM	[KernelB_D - $100]
     29  f5d1				   KernelB_E_W EQM	[KernelB_E - $100]
     30  f5d1				   KernelB_F_W EQM	[KernelB_F - $100]
     31  f5d1				   KernelB_G_W EQM	[KernelB_G - $100]
     32  f5d1				   KernelB_H_W EQM	[KernelB_H - $100]
     33  f5d1				   KernelB_I_W EQM	[KernelB_I - $100]
     34  f5d1				   KernelB_J_W EQM	[KernelB_J - $100]
     35  f5d1				   KernelB_K_W EQM	[KernelB_K - $100]
     36  f5d1
     37  f5d1							; Y=Gemini Sprite
     38  f5d1							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     39  f5d1							; processor flag Z is TRUE if this is RST.
     40  f5d1				   KernelA_GenReset subroutine
     41  f5d1		       c0 00		      cpy	#$00
     42  f5d3		       f0 01		      beq	.start
     43  f5d5		       60		      rts
     44  f5d6							; Current Gemini = $00
     45  f5d6				   .start
     46  f5d6		       a6 a8		      ldx	BuildKernelRST
     47  f5d8		       e0 aa		      cpx	#SENTINEL
     48  f5da		       d0 04		      bne	.set_else
     49  f5dc							; We have found the first (and only) RST on this line, set the marker var
     50  f5dc		       a2 ff		      ldx	#$ff
     51  f5de		       86 a8		      stx	BuildKernelRST
     52  f5e0				   .set_else
     53  f5e0		       a2 00		      ldx	#$00
     54  f5e2		       60		      rts
     55  f5e3
     56  f5e3							; Y=Gemini Sprite
     57  f5e3							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     58  f5e3							; processor flag Z is TRUE if this is RST.
     59  f5e3				   KernelB_GenPhp subroutine
     60  f5e3		       c0 60		      cpy	#G01
     61  f5e5		       f0 05		      beq	.start
     62  f5e7		       c0 66		      cpy	#G11
     63  f5e9		       f0 01		      beq	.start
     64  f5eb		       60		      rts
     65  f5ec							; Current Gemini = $00
     66  f5ec				   .start
     67  f5ec		       a6 a8		      ldx	BuildKernelRST
     68  f5ee		       e0 aa		      cpx	#SENTINEL
     69  f5f0		       d0 06		      bne	.set_else
     70  f5f2							; We have found the first (and only) RST on this line, set the marker var
     71  f5f2		       a2 ff		      ldx	#$ff
     72  f5f4		       86 a8		      stx	BuildKernelRST
     73  f5f6		       a2 00		      ldx	#$00
     74  f5f8				   .set_else
     75  f5f8		       60		      rts
     76  f5f9
     77  f5f9							; Allocates build-time registers for a new Gemini sprite value.
     78  f5f9							; register Y = the storage opcode to write to the result
     79  f5f9							;
     80  f5f9							; BuildKernelGrp0, BuildKernelX, BuildKernelY are compared in that order.
     81  f5f9							; BuildKernelX, BuildKernelY are upgraded if not set.
     82  f5f9							; Y=Gemini Sprite
     83  f5f9				   KernelB_UpdateRegs
     84  f5f9				   KernelA_UpdateRegs subroutine
     85  f5f9
     86  f5f9							; If equal to GRP0, return nop
     87  f5f9							; FIXME GRP0 might not always be up to date (should update each entry?)
     88  f5f9							; FIXME GOTTA REVERSE THE GRAPHICS ALSO
     89  f5f9							; cpy BuildKernelGrp0
     90  f5f9							; bne .set_start
     91  f5f9							; ; TODO if this is stx + NOP value, then register doesn't have to change as
     92  f5f9							; ; often in GEM1ASWITCH
     93  f5f9							; ldy #BC_NOP
     94  f5f9							; rts
     95  f5f9
     96  f5f9		       c4 a6		      cpy	BuildKernelX
     97  f5fb		       d0 03		      bne	.op_else
     98  f5fd		       a0 86		      ldy	#BC_STX
     99  f5ff		       60		      rts
    100  f600				   .op_else
    101  f600		       c4 a7		      cpy	BuildKernelY
    102  f602		       d0 03		      bne	.op_end
    103  f604		       a0 84		      ldy	#BC_STY
    104  f606		       60		      rts
    105  f607				   .op_end
    106  f607
    107  f607				   .set_start
    108  f607		       a6 a6		      ldx	BuildKernelX
    109  f609		       e0 aa		      cpx	#SENTINEL
    110  f60b		       d0 13		      bne	.set_else
    111  f60d
    112  f60d							; KA Missile opcode determination
    113  f60d				   DBG_CHECK_MISSILE_OPCODE
    114  f60d		       84 a6		      sty	BuildKernelX
    115  f60f		       66 a6		      ror	BuildKernelX	; D0
    116  f611		       66 a6		      ror	BuildKernelX	; D1
    117  f613		       a2 86		      ldx	#BC_STX
    118  f615		       b0 02		      bcs	[. + 4]
    119  f617		       a2 84		      ldx	#BC_STY
    120  f619		       86 ab		      stx	BuildKernelMissile
    121  f61b
    122  f61b		       84 a6		      sty	BuildKernelX
    123  f61d		       a0 86		      ldy	#BC_STX
    124  f61f		       60		      rts
    125  f620				   .set_else
    126  f620		       a6 a7		      ldx	BuildKernelY
    127  f622		       e0 aa		      cpx	#SENTINEL
    128  f624		       d0 05		      bne	.set_end
    129  f626		       84 a7		      sty	BuildKernelY
    130  f628		       a0 84		      ldy	#BC_STY
    131  f62a		       60		      rts
    132  f62b				   .set_end
    133  f62b							; Failed all
      0  f62b					      ASSERT_RUNTIME	"0"
      1  f62b				   .COND      SET	"0"
 ASSERT: breakif { pc== $f62b  && !(  0  ) }
      2  f62b					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    135  f62b		       60		      rts
    136  f62c
    137  f62c
    138  f62c				   game_nibble_populate
    139  f62c		       ad 00 f1 	      lda	$f100
    140  f62f		       85 80		      sta	DebugKernelID
    141  f631
    142  f631		       ad 84 fe 	      lda	shard_map
    143  f634		       a0 01		      ldy	#1	; gemini counter, starting at 1
    144  f636				   gemini_builder
    145  f636		       c0 01		      cpy	#1	; TODO top two bits of shard_map
    146  f638		       d0 00		      bne	.no_vd0
    147  f63a				   .no_vd0
    148  f63a
    149  f63a							; Nibble Kernel A
      0  f63a					      NIBBLE_START_KERNEL	gem_kernel_a_1, 40
      1 U00d6 ????				      seg.U	ignoreme
    151 U00d6 ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    152 U00d8 ????	       86 a6		      stx	BuildKernelX
    153 U00da ????	       86 a7		      stx	BuildKernelY
    154 U00dc ????	       86 a8		      stx	BuildKernelRST
    155 U00de ????
    156 U00de ????						; Gemini 1A
    157 U00de ????			   .K_1A
    158 U00de ????	       a4 b2		      ldy	[DO_GEMS_A + 0]
    159 U00e0 ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U00e3 ????				      NIBBLE_IF	eq
    161 U00e3 ????						; Special: Encoding RST0
    162 U00e3 ????						; Rewrite lda RamKernelPF1 to be #immediate
    163 U00e3 ????	       a0 a9		      ldy	#BC_LDA_IMM
    164 U00e5 ????	       8c 15 f0 	      sty	[KernelA_B - $100]
    165 U00e8 ????	       a0 a0		      ldy	#%10100000
    166 U00ea ????	       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
    167 U00ed ????						; Store 1A in GRP0
    168 U00ed ????	       a4 b3		      ldy	[DO_GEMS_A + 1]
    169 U00ef ????	       84 a9		      sty	BuildKernelGrp0
    170 U00f1 ????						; Gemini 1A is RESPx
    171 U00f1 ????	       a0 11		      ldy	#EMERALD_SP_RESET
    172 U00f3 ????	       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
    173 U00f6 ????						; Turn 3-cycle NOP into 4-cycle
    174 U00f6 ????	       a0 14		      ldy	#$14	; TODO what is this
    175 U00f8 ????	       8c 19 f0 	      sty	[KernelA_D - $100]
      0 U00fb ????				      NIBBLE_ELSE
    177 U00fb ????						; Store 0A in GRP0
    178 U00fb ????	       a4 b2		      ldy	[DO_GEMS_A + 0]
    179 U00fd ????	       84 a9		      sty	BuildKernelGrp0
    180 U00ff ????
    181 U00ff ????	       a4 b3		      ldy	[DO_GEMS_A + 1]
    182 U0101 ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U0104 ????				      NIBBLE_IF	eq
    184 U0104 ????						; GEM1ASWITCH
      0 U0104 ????				      NIBBLE_WRITE	KernelA_D_W, #BC_STX, #RESP1	; RESET
      0 U0104 ????				      NIBBLE_ELSE
    187 U0104 ????						; Calculate the 1A value
    188 U0104 ????	       ac d4 fa 	      ldy	SHARD_LUT_RF1
    189 U0107 ????	       c0 01		      cpy	#1
    190 U0109 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    191 U010b ????	       a0 11		      ldy	#RESP1
    192 U010d ????	       2c		      .byte.b	$2C	; .bit (ABS)
    193 U010e ????	       a0 1c		      ldy	#GRP1
    194 U0110 ????	       84 9e		      sty	RamKernelGemini1Reg
    195 U0112 ????
    196 U0112 ????						; Set opcode
    197 U0112 ????	       ae d4 fa 	      ldx	SHARD_LUT_RF1
    198 U0115 ????	       e0 01		      cpx	#1
    199 U0117 ????	       a0 86		      ldy	#BC_STX	; Don't allocate
    200 U0119 ????	       f0 05		      .byte.b	$F0, #5	; beq +4
    201 U011b ????	       a4 b3		      ldy	[DO_GEMS_A + 1]
    202 U011d ????	       20 f9 f5 	      jsr	KernelA_UpdateRegs
    203 U0120 ????	       84 9d		      sty	RamKernelGemini1
    204 U0122 ????
      0 U0122 ????				      NIBBLE_WRITE	KernelA_D_W, RamKernelGemini1, RamKernelGemini1Reg
      0 U0122 ????				      NIBBLE_END_IF
      0 U0122 ????				      NIBBLE_END_IF
    208 U0122 ????
    209 U0122 ????						; BuildKernelX, BuildKernelY are upgraded if not set
    210 U0122 ????						; Gemini 2A
    211 U0122 ????			   .K_2A
    212 U0122 ????	       a4 b4		      ldy	[DO_GEMS_A + 2]
    213 U0124 ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U0127 ????				      NIBBLE_IF	eq
      0 U0127 ????				      NIBBLE_WRITE	KernelA_E_W + 1, #NOP_REG	; NOP
      0 U0127 ????				      NIBBLE_WRITE	KernelA_G_W + 1, #RESP1	; RESET
      0 U0127 ????				      NIBBLE_ELSE
    218 U0127 ????						; Set opcode
    219 U0127 ????	       a4 b4		      ldy	[DO_GEMS_A + 2]
    220 U0129 ????	       20 f9 f5 	      jsr	KernelA_UpdateRegs
    221 U012c ????	       84 9f		      sty	RamKernelGemini2
    222 U012e ????
    223 U012e ????						; Set opcode target
    224 U012e ????	       ac d4 fa 	      ldy	SHARD_LUT_RF1
    225 U0131 ????	       c0 02		      cpy	#2
    226 U0133 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    227 U0135 ????	       a0 11		      ldy	#RESP1
    228 U0137 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    229 U0138 ????	       a0 1c		      ldy	#GRP1
    230 U013a ????	       84 a0		      sty	RamKernelGemini2Reg
    231 U013c ????
      0 U013c ????				      NIBBLE_WRITE	KernelA_E_W + 1, #RESP1
      0 U013c ????				      NIBBLE_WRITE	KernelA_G_W, RamKernelGemini2, RamKernelGemini2Reg	; STX
      0 U013c ????				      NIBBLE_END_IF
    235 U013c ????
    236 U013c ????						; Gemini 3A
    237 U013c ????			   .K_3A
    238 U013c ????	       a4 b5		      ldy	[DO_GEMS_A + 3]
    239 U013e ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U0141 ????				      NIBBLE_IF	eq
      0 U0141 ????				      NIBBLE_WRITE	KernelA_H_W + 1, #RESP1	; RESET
      0 U0141 ????				      NIBBLE_ELSE
    243 U0141 ????						; Set opcode
    244 U0141 ????	       a4 b5		      ldy	[DO_GEMS_A + 3]
    245 U0143 ????	       20 f9 f5 	      jsr	KernelA_UpdateRegs
    246 U0146 ????	       84 a1		      sty	RamKernelGemini3
    247 U0148 ????
    248 U0148 ????						; Set opcode target
    249 U0148 ????	       ac d4 fa 	      ldy	SHARD_LUT_RF1
    250 U014b ????	       c0 03		      cpy	#3
    251 U014d ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    252 U014f ????	       a0 11		      ldy	#RESP1
    253 U0151 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    254 U0152 ????	       a0 1c		      ldy	#GRP1
    255 U0154 ????	       84 a2		      sty	RamKernelGemini3Reg
    256 U0156 ????
      0 U0156 ????				      NIBBLE_WRITE	KernelA_H_W, RamKernelGemini3, RamKernelGemini3Reg	; STY
      0 U0156 ????				      NIBBLE_END_IF
      0 U0156 ????				      NIBBLE_END_KERNEL
      1  f63a					      seg	CodeBank3
    260  f63a
      0  f63a					      NIBBLE_START_KERNEL	gem_kernel_a_2, 40
      1 U0156 ????				      seg.U	ignoreme
    262 U0156 ????						; VD1 default
    263 U0156 ????	       a6 b3		      ldx	[DO_GEMS_A + 1]
    264 U0158 ????	       86 aa		      stx	BuildKernelVdel1
    265 U015a ????
    266 U015a ????						; Gemini 4A
    267 U015a ????	       ae d5 fa 	      ldx	SHARD_LUT_VD1
    268 U015d ????	       e0 04		      cpx	#4
      0 U015f ????				      NIBBLE_IF	ne
      0 U015f ????				      NIBBLE_WRITE	[KernelA_I_W + 0], #BC_STA, #EMERALD_SP_RESET
      0 U015f ????				      NIBBLE_WRITE	[KernelA_J_W + 1], #BC_STA, #PF1
      0 U015f ????				      NIBBLE_WRITE	[KernelA_K_W + 1], #BC_PHP
    273 U015f ????
    274 U015f ????						; Set PHP
      0 U015f ????				      NIBBLE_WRITE	RamKernelPhpTarget, #VDELP1
    276 U015f ????
    277 U015f ????						; Update VDEL1
    278 U015f ????	       a6 b6		      ldx	[DO_GEMS_A + 4]
    279 U0161 ????	       86 aa		      stx	BuildKernelVdel1
      0 U0163 ????				      NIBBLE_ELSE
    281 U0163 ????	       a4 b6		      ldy	[DO_GEMS_A + 4]
    282 U0165 ????	       20 f9 f5 	      jsr	KernelA_UpdateRegs
    283 U0168 ????	       84 a3		      sty	RamKernelGemini4
    284 U016a ????
      0 U016a ????				      NIBBLE_WRITE	[KernelA_I_W + 0], #BC_PHP
      0 U016a ????				      NIBBLE_WRITE	[KernelA_J_W + 0], #BC_STA, #PF1
      0 U016a ????				      NIBBLE_WRITE	KernelA_K_W, RamKernelGemini4, #EMERALD_SP
    288 U016a ????
    289 U016a ????						; Set PHP
      0 U016a ????				      NIBBLE_WRITE	RamKernelPhpTarget, #RESP1
      0 U016a ????				      NIBBLE_END_IF
    292 U016a ????
    293 U016a ????						; Misisle
    294 U016a ????	       a4 b0		      ldy	DO_MISS_A
      0 U016c ????				      NIBBLE_IF	eq	; Disabled
      0 U016c ????				      NIBBLE_WRITE	[KernelA_F - $100], #BC_NOP
      0 U016c ????				      NIBBLE_ELSE
      0 U016c ????				      NIBBLE_WRITE	[KernelA_F - $100], BuildKernelMissile
      0 U016c ????				      NIBBLE_END_IF
    300 U016c ????
    301 U016c ????						; VD1
      0 U016c ????				      NIBBLE_WRITE	[KernelA_VDEL1 - $100], BuildKernelVdel1
    303 U016c ????						; GRP0
      0 U016c ????				      NIBBLE_WRITE	[KernelA_VDEL0 - $100], BuildKernelGrp0
    305 U016c ????						; X
      0 U016c ????				      NIBBLE_WRITE	RamKernelX, BuildKernelX
    307 U016c ????						; Y
      0 U016c ????				      NIBBLE_WRITE	RamKernelY, BuildKernelY
    309 U016c ????
    310 U016c ????						; Gemini 5A
    311 U016c ????						; TODO eventually...?
      0 U016c ????				      NIBBLE_END_KERNEL
      1  f63a					      seg	CodeBank3
    313  f63a
    314  f63a							; Nibble Kernel B
      0  f63a					      NIBBLE_START_KERNEL	gem_kernel_b, 40
      1 U016c ????				      seg.U	ignoreme
    316 U016c ????						; Php target default
    317 U016c ????	       a2 11		      ldx	#RESP1
    318 U016e ????	       86 9a		      stx	RamKernelPhpTarget
    319 U0170 ????
    320 U0170 ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    321 U0172 ????	       86 a6		      stx	BuildKernelX
    322 U0174 ????	       86 a7		      stx	BuildKernelY
    323 U0176 ????	       86 a8		      stx	BuildKernelRST
    324 U0178 ????
    325 U0178 ????						; Gemini 0B
    326 U0178 ????	       a4 b8		      ldy	[DO_GEMS_B + 0]
    327 U017a ????	       84 a9		      sty	BuildKernelGrp0
    328 U017c ????						; NIBBLE_WRITE KernelB_D_W, RamKernelGemini0
    329 U017c ????
    330 U017c ????						; Gemini 1B
    331 U017c ????	       a4 b9		      ldy	[DO_GEMS_B + 1]
    332 U017e ????	       20 f9 f5 	      jsr	KernelA_UpdateRegs
    333 U0181 ????	       84 9d		      sty	RamKernelGemini1
      0 U0183 ????				      NIBBLE_WRITE	KernelB_D_W, RamKernelGemini1
    335 U0183 ????
    336 U0183 ????						; Calculate Gemini 2B
    337 U0183 ????	       a4 ba		      ldy	[DO_GEMS_B + 2]
    338 U0185 ????	       20 f9 f5 	      jsr	KernelB_UpdateRegs
    339 U0188 ????	       84 9f		      sty	RamKernelGemini2
    340 U018a ????						; Calculate Gemini 3B
    341 U018a ????	       a4 bb		      ldy	[DO_GEMS_B + 3]
    342 U018c ????	       20 f9 f5 	      jsr	KernelB_UpdateRegs
    343 U018f ????	       84 a1		      sty	RamKernelGemini3
    344 U0191 ????
    345 U0191 ????						; Gemini 2B
    346 U0191 ????	       a4 ba		      ldy	[DO_GEMS_B + 2]
    347 U0193 ????	       20 e3 f5 	      jsr	KernelB_GenPhp
      0 U0196 ????				      NIBBLE_IF	eq
    349 U0196 ????						; Write to PHP in 2B
      0 U0196 ????				      NIBBLE_WRITE	RamKernelPhpTarget, #EMERALD_SP
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_E_W + 0], #BC_STY, #EMERALD_SP_RESET	; 2B
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_F_W + 1], #BC_PHP
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_G_W + 0], #BC_STA, #PF1
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_H_W + 0], RamKernelGemini3, #EMERALD_SP	; 3B
    355 U0196 ????
    356 U0196 ????	       c4 66		      cpy	G11
      0 U0198 ????				      NIBBLE_IF	ne
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$38	; sec
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamZeroByte
      0 U0198 ????				      NIBBLE_ELSE
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$18	; clc
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamLowerSixByte
      0 U0198 ????				      NIBBLE_END_IF
      0 U0198 ????				      NIBBLE_ELSE
      0 U0198 ????				      NIBBLE_WRITE	KernelB_F_W, RamKernelGemini2, #EMERALD_SP
      0 U0198 ????				      NIBBLE_END_IF
    367 U0198 ????
    368 U0198 ????						; Gemini 3B
    369 U0198 ????	       a4 bb		      ldy	[DO_GEMS_B + 3]
    370 U019a ????	       20 e3 f5 	      jsr	KernelB_GenPhp
      0 U019d ????				      NIBBLE_IF	ne
    372 U019d ????						; Write to PHP in 3B
      0 U019d ????				      NIBBLE_WRITE	RamKernelPhpTarget, #EMERALD_SP
      0 U019d ????				      NIBBLE_WRITE	[KernelB_E_W + 0], #BC_STY, #EMERALD_SP_RESET
      0 U019d ????				      NIBBLE_WRITE	[KernelB_F_W + 1], RamKernelGemini2, #EMERALD_SP	; 2B
      0 U019d ????				      NIBBLE_WRITE	[KernelB_G_W + 1], #BC_STA, #PF1
      0 U019d ????				      NIBBLE_WRITE	[KernelB_H_W + 1], #BC_PHP	; 3B
    378 U019d ????
    379 U019d ????						; TODO compare this in the outside by checking KernelB_GenPhp value
    380 U019d ????	       c4 66		      cpy	G11
      0 U019f ????				      NIBBLE_IF	eq
      0 U019f ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$38	; sec
      0 U019f ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamZeroByte
      0 U019f ????				      NIBBLE_ELSE
      0 U019f ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$18	; clc
      0 U019f ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamLowerSixByte
      0 U019f ????				      NIBBLE_END_IF
      0 U019f ????				      NIBBLE_ELSE
      0 U019f ????				      NIBBLE_WRITE	KernelB_H_W, RamKernelGemini3, #EMERALD_SP
      0 U019f ????				      NIBBLE_END_IF
    391 U019f ????
    392 U019f ????						; Gemini 4B
    393 U019f ????	       a4 bc		      ldy	[DO_GEMS_B + 4]
    394 U01a1 ????	       20 f9 f5 	      jsr	KernelA_UpdateRegs
    395 U01a4 ????	       84 a3		      sty	RamKernelGemini4
      0 U01a6 ????				      NIBBLE_WRITE	KernelB_J_W, RamKernelGemini4
    397 U01a6 ????
    398 U01a6 ????						; TODO if no PHP, rewrite previous section:
    399 U01a6 ????						; NIBBLE_IF cs
    400 U01a6 ????						;     ; Write to PHP in reset command
    401 U01a6 ????						;     NIBBLE_WRITE [KernelB_E_W + 0], #BC_PHP
    402 U01a6 ????						;     NIBBLE_WRITE [KernelB_F_W + 0], #BC_STY, #EMERALD_SP ; 2B
    403 U01a6 ????						;     NIBBLE_WRITE [KernelB_G_W + 0], #BC_STA, #PF1
    404 U01a6 ????						;     NIBBLE_WRITE [KernelB_H_W + 0], #BC_STY, #EMERALD_SP ; 3B
    405 U01a6 ????						; NIBBLE_END_IF
    406 U01a6 ????
    407 U01a6 ????						; Make adjustments for sprites.
    408 U01a6 ????	       66 a9		      ror	BuildKernelGrp0
    409 U01a8 ????	       66 a6		      ror	BuildKernelX
    410 U01aa ????	       66 a7		      ror	BuildKernelY
    411 U01ac ????
    412 U01ac ????						; ; VD1
    413 U01ac ????						; NIBBLE_WRITE [KernelB_VDEL1 - $100], BuildKernelVdel1
    414 U01ac ????						; GRP0
      0 U01ac ????				      NIBBLE_WRITE	[KernelB_VDEL0 - $100], BuildKernelGrp0
    416 U01ac ????						; X
      0 U01ac ????				      NIBBLE_WRITE	RamKernelX, BuildKernelX
    418 U01ac ????						; Y
      0 U01ac ????				      NIBBLE_WRITE	RamKernelY, BuildKernelY
    420 U01ac ????
      0 U01ac ????				      NIBBLE_END_KERNEL
      1  f63a					      seg	CodeBank3
    422  f63a
    423  f63a							; TODO do this for all rows
    424  f63a				   DBG_NIBBLE_BUILD subroutine
    425  f63a		       ae 00 f1 	      ldx	$f100
    426  f63d		       e0 0a		      cpx	#$a
    427  f63f		       f0 03		      beq	[. + 5]
    428  f641		       4c 26 f7 	      jmp	.kernel_b
    429  f644				   .kernel_a
      0  f644					      NIBBLE_gem_kernel_a_1_BUILD		; TODO can this be implied
      1  f644		       a9 00		      lda	#0
      2  f646		       a2 aa		      ldx	#SENTINEL
      3  f648		       86 a6		      stx	BuildKernelX
      4  f64a		       86 a7		      stx	BuildKernelY
      5  f64c		       86 a8		      stx	BuildKernelRST
      6  f64e
      7  f64e				   .K_1A
      8  f64e		       a4 b2		      ldy	[DO_GEMS_A + 0]
      9  f650		       20 d1 f5 	      jsr	KernelA_GenReset
     10  f653				   .if_1
     11  f653		       d0 1e		      bne	.else_1
     12  f655		       38		      sec
     13  f656		       2a		      rol
     14  f657
     15  f657
     16  f657		       a0 a9		      ldy	#BC_LDA_IMM
     17  f659		       8c 15 f0 	      sty	[KernelA_B - $100]
     18  f65c		       a0 a0		      ldy	#%10100000
     19  f65e		       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
     20  f661
     21  f661		       a4 b3		      ldy	[DO_GEMS_A + 1]
     22  f663		       84 a9		      sty	BuildKernelGrp0
     23  f665
     24  f665		       a0 11		      ldy	#EMERALD_SP_RESET
     25  f667		       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
     26  f66a
     27  f66a		       a0 14		      ldy	#$14
     28  f66c		       8c 19 f0 	      sty	[KernelA_D - $100]
     29  f66f		       4c a5 f6 	      jmp	.endif_1
     30  f672
     31  f672		       2a		      rol
     32  f673
     33  f673				   .else_1
     34  f673		       18		      clc
     35  f674		       2a		      rol
     36  f675
     37  f675		       a4 b2		      ldy	[DO_GEMS_A + 0]
     38  f677		       84 a9		      sty	BuildKernelGrp0
     39  f679		       a4 b3		      ldy	[DO_GEMS_A + 1]
     40  f67b		       20 d1 f5 	      jsr	KernelA_GenReset
     41  f67e				   .if_2
     42  f67e		       d0 05		      bne	.else_2
     43  f680		       38		      sec
     44  f681		       2a		      rol
     45  f682
     46  f682		       4c a5 f6 	      jmp	.endif_2
     47  f685
     48  f685
     49  f685				   .else_2
     50  f685		       18		      clc
     51  f686		       2a		      rol
     52  f687
     53  f687		       ac d4 fa 	      ldy	SHARD_LUT_RF1
     54  f68a		       c0 01		      cpy	#1
     55  f68c		       d0 03		      .byte.b	$D0, #3
     56  f68e		       a0 11		      ldy	#RESP1
     57  f690		       2c		      .byte.b	$2C
     58  f691		       a0 1c		      ldy	#GRP1
     59  f693		       84 9e		      sty	RamKernelGemini1Reg
     60  f695
     61  f695		       ae d4 fa 	      ldx	SHARD_LUT_RF1
     62  f698		       e0 01		      cpx	#1
     63  f69a		       a0 86		      ldy	#BC_STX
     64  f69c		       f0 05		      .byte.b	$F0, #5
     65  f69e		       a4 b3		      ldy	[DO_GEMS_A + 1]
     66  f6a0		       20 f9 f5 	      jsr	KernelA_UpdateRegs
     67  f6a3		       84 9d		      sty	RamKernelGemini1
     68  f6a5
     69  f6a5
     70  f6a5				   .endif_2
     71  f6a5
     72  f6a5
     73  f6a5				   .endif_1
     74  f6a5
     75  f6a5
     76  f6a5				   .K_2A
     77  f6a5		       a4 b4		      ldy	[DO_GEMS_A + 2]
     78  f6a7		       20 d1 f5 	      jsr	KernelA_GenReset
     79  f6aa				   .if_3
     80  f6aa		       d0 05		      bne	.else_3
     81  f6ac		       38		      sec
     82  f6ad		       2a		      rol
     83  f6ae		       4c c8 f6 	      jmp	.endif_3
     84  f6b1
     85  f6b1
     86  f6b1				   .else_3
     87  f6b1		       18		      clc
     88  f6b2		       2a		      rol
     89  f6b3
     90  f6b3		       a4 b4		      ldy	[DO_GEMS_A + 2]
     91  f6b5		       20 f9 f5 	      jsr	KernelA_UpdateRegs
     92  f6b8		       84 9f		      sty	RamKernelGemini2
     93  f6ba
     94  f6ba		       ac d4 fa 	      ldy	SHARD_LUT_RF1
     95  f6bd		       c0 02		      cpy	#2
     96  f6bf		       d0 03		      .byte.b	$D0, #3
     97  f6c1		       a0 11		      ldy	#RESP1
     98  f6c3		       2c		      .byte.b	$2C
     99  f6c4		       a0 1c		      ldy	#GRP1
    100  f6c6		       84 a0		      sty	RamKernelGemini2Reg
    101  f6c8
    102  f6c8
    103  f6c8				   .endif_3
    104  f6c8
    105  f6c8				   .K_3A
    106  f6c8		       a4 b5		      ldy	[DO_GEMS_A + 3]
    107  f6ca		       20 d1 f5 	      jsr	KernelA_GenReset
    108  f6cd				   .if_4
    109  f6cd		       d0 05		      bne	.else_4
    110  f6cf		       38		      sec
    111  f6d0		       2a		      rol
    112  f6d1		       4c eb f6 	      jmp	.endif_4
    113  f6d4
    114  f6d4
    115  f6d4				   .else_4
    116  f6d4		       18		      clc
    117  f6d5		       2a		      rol
    118  f6d6
    119  f6d6		       a4 b5		      ldy	[DO_GEMS_A + 3]
    120  f6d8		       20 f9 f5 	      jsr	KernelA_UpdateRegs
    121  f6db		       84 a1		      sty	RamKernelGemini3
    122  f6dd
    123  f6dd		       ac d4 fa 	      ldy	SHARD_LUT_RF1
    124  f6e0		       c0 03		      cpy	#3
    125  f6e2		       d0 03		      .byte.b	$D0, #3
    126  f6e4		       a0 11		      ldy	#RESP1
    127  f6e6		       2c		      .byte.b	$2C
    128  f6e7		       a0 1c		      ldy	#GRP1
    129  f6e9		       84 a2		      sty	RamKernelGemini3Reg
    130  f6eb
    131  f6eb
    132  f6eb				   .endif_4
    133  f6eb
    134  f6eb		       2a		      rol
    135  f6ec		       2a		      rol
    136  f6ed		       2a		      rol
    137  f6ee		       2a		      rol
    431  f6ef		       85 91		      sta	RamNibbleVar1
      0  f6f1					      NIBBLE_gem_kernel_a_2_BUILD		; TODO can this be implied
      1  f6f1		       a9 00		      lda	#0
      2  f6f3
      3  f6f3		       a6 b3		      ldx	[DO_GEMS_A + 1]
      4  f6f5		       86 aa		      stx	BuildKernelVdel1
      5  f6f7
      6  f6f7		       ae d5 fa 	      ldx	SHARD_LUT_VD1
      7  f6fa		       e0 04		      cpx	#4
      8  f6fc				   .if_1
      9  f6fc		       f0 09		      beq	.else_1
     10  f6fe		       38		      sec
     11  f6ff		       2a		      rol
     12  f700
     13  f700
     14  f700		       a6 b6		      ldx	[DO_GEMS_A + 4]
     15  f702		       86 aa		      stx	BuildKernelVdel1
     16  f704		       4c 10 f7 	      jmp	.endif_1
     17  f707
     18  f707
     19  f707				   .else_1
     20  f707		       18		      clc
     21  f708		       2a		      rol
     22  f709		       a4 b6		      ldy	[DO_GEMS_A + 4]
     23  f70b		       20 f9 f5 	      jsr	KernelA_UpdateRegs
     24  f70e		       84 a3		      sty	RamKernelGemini4
     25  f710
     26  f710
     27  f710
     28  f710				   .endif_1
     29  f710
     30  f710		       a4 b0		      ldy	DO_MISS_A
     31  f712				   .if_2
     32  f712		       d0 05		      bne	.else_2
     33  f714		       38		      sec
     34  f715		       2a		      rol
     35  f716		       4c 1b f7 	      jmp	.endif_2
     36  f719
     37  f719
     38  f719				   .else_2
     39  f719		       18		      clc
     40  f71a		       2a		      rol
     41  f71b
     42  f71b
     43  f71b				   .endif_2
     44  f71b
     45  f71b
     46  f71b
     47  f71b
     48  f71b
     49  f71b
     50  f71b
     51  f71b		       2a		      rol
     52  f71c		       2a		      rol
     53  f71d		       2a		      rol
     54  f71e		       2a		      rol
     55  f71f		       2a		      rol
     56  f720		       2a		      rol
    433  f721		       85 92		      sta	RamNibbleVar2
    434  f723		       4c 94 f7 	      jmp	.next
    435  f726				   .kernel_b
      0  f726					      NIBBLE_gem_kernel_b_BUILD		; TODO can this be implied
      1  f726		       a9 00		      lda	#0
      2  f728
      3  f728		       a2 11		      ldx	#RESP1
      4  f72a		       86 9a		      stx	RamKernelPhpTarget
      5  f72c		       a2 aa		      ldx	#SENTINEL
      6  f72e		       86 a6		      stx	BuildKernelX
      7  f730		       86 a7		      stx	BuildKernelY
      8  f732		       86 a8		      stx	BuildKernelRST
      9  f734
     10  f734		       a4 b8		      ldy	[DO_GEMS_B + 0]
     11  f736		       84 a9		      sty	BuildKernelGrp0
     12  f738
     13  f738
     14  f738		       a4 b9		      ldy	[DO_GEMS_B + 1]
     15  f73a		       20 f9 f5 	      jsr	KernelA_UpdateRegs
     16  f73d		       84 9d		      sty	RamKernelGemini1
     17  f73f
     18  f73f		       a4 ba		      ldy	[DO_GEMS_B + 2]
     19  f741		       20 f9 f5 	      jsr	KernelB_UpdateRegs
     20  f744		       84 9f		      sty	RamKernelGemini2
     21  f746
     22  f746		       a4 bb		      ldy	[DO_GEMS_B + 3]
     23  f748		       20 f9 f5 	      jsr	KernelB_UpdateRegs
     24  f74b		       84 a1		      sty	RamKernelGemini3
     25  f74d
     26  f74d		       a4 ba		      ldy	[DO_GEMS_B + 2]
     27  f74f		       20 e3 f5 	      jsr	KernelB_GenPhp
     28  f752				   .if_1
     29  f752		       d0 10		      bne	.else_1
     30  f754		       38		      sec
     31  f755		       2a		      rol
     32  f756
     33  f756		       c4 66		      cpy	G11
     34  f758				   .if_2
     35  f758		       f0 05		      beq	.else_2
     36  f75a		       38		      sec
     37  f75b		       2a		      rol
     38  f75c		       4c 61 f7 	      jmp	.endif_2
     39  f75f
     40  f75f
     41  f75f				   .else_2
     42  f75f		       18		      clc
     43  f760		       2a		      rol
     44  f761
     45  f761
     46  f761				   .endif_2
     47  f761		       4c 67 f7 	      jmp	.endif_1
     48  f764
     49  f764
     50  f764				   .else_1
     51  f764		       18		      clc
     52  f765		       2a		      rol
     53  f766
     54  f766
     55  f766		       2a		      rol
     56  f767				   .endif_1
     57  f767
     58  f767		       a4 bb		      ldy	[DO_GEMS_B + 3]
     59  f769		       20 e3 f5 	      jsr	KernelB_GenPhp
     60  f76c				   .if_3
     61  f76c		       f0 10		      beq	.else_3
     62  f76e		       38		      sec
     63  f76f		       2a		      rol
     64  f770
     65  f770
     66  f770		       c4 66		      cpy	G11
     67  f772				   .if_4
     68  f772		       d0 05		      bne	.else_4
     69  f774		       38		      sec
     70  f775		       2a		      rol
     71  f776		       4c 7b f7 	      jmp	.endif_4
     72  f779
     73  f779
     74  f779				   .else_4
     75  f779		       18		      clc
     76  f77a		       2a		      rol
     77  f77b
     78  f77b
     79  f77b				   .endif_4
     80  f77b		       4c 81 f7 	      jmp	.endif_3
     81  f77e
     82  f77e
     83  f77e				   .else_3
     84  f77e		       18		      clc
     85  f77f		       2a		      rol
     86  f780
     87  f780
     88  f780		       2a		      rol
     89  f781				   .endif_3
     90  f781
     91  f781		       a4 bc		      ldy	[DO_GEMS_B + 4]
     92  f783		       20 f9 f5 	      jsr	KernelA_UpdateRegs
     93  f786		       84 a3		      sty	RamKernelGemini4
     94  f788
     95  f788
     96  f788
     97  f788
     98  f788
     99  f788
    100  f788
    101  f788
    102  f788
    103  f788		       66 a9		      ror	BuildKernelGrp0
    104  f78a		       66 a6		      ror	BuildKernelX
    105  f78c		       66 a7		      ror	BuildKernelY
    106  f78e
    107  f78e
    108  f78e
    109  f78e
    110  f78e
    111  f78e
    112  f78e		       2a		      rol
    113  f78f		       2a		      rol
    114  f790		       2a		      rol
    115  f791		       2a		      rol
    437  f792		       85 91		      sta	RamNibbleVar1
    438  f794				   .next
    439  f794
    440  f794							; TODO move this into the row kernel
    441  f794				   DBG_NIBBLE_RUN subroutine
    442  f794		       ae 00 f1 	      ldx	$f100
    443  f797		       e0 0a		      cpx	#$a
    444  f799		       f0 03		      beq	[. + 5]
    445  f79b		       4c 5b f8 	      jmp	.kernel_b
    446  f79e				   .kernel_a
    447  f79e		       a5 91		      lda	RamNibbleVar1
      0  f7a0					      NIBBLE_gem_kernel_a_1
      1  f7a0				   .if_1
      2  f7a0		       0a		      asl
      3  f7a1		       90 03		      bcc	.else_1
      4  f7a3		       4c c0 f7 	      jmp	.endif_1
      5  f7a6				   .else_1
      6  f7a6				   .if_2
      7  f7a6		       0a		      asl
      8  f7a7		       90 0d		      bcc	.else_2
      9  f7a9		       a2 86		      ldx	#BC_STX
     10  f7ab		       8e 19 f0 	      stx	[KernelA_D_W + 0]
     11  f7ae		       a2 11		      ldx	#RESP1
     12  f7b0		       8e 1a f0 	      stx	[KernelA_D_W + 1]
     13  f7b3		       4c c0 f7 	      jmp	.endif_2
     14  f7b6				   .else_2
     15  f7b6		       a6 9d		      ldx	RamKernelGemini1
     16  f7b8		       8e 19 f0 	      stx	[KernelA_D_W + 0]
     17  f7bb		       a6 9e		      ldx	RamKernelGemini1Reg
     18  f7bd		       8e 1a f0 	      stx	[KernelA_D_W + 1]
     19  f7c0				   .endif_2
     20  f7c0				   .endif_1
     21  f7c0				   .if_3
     22  f7c0		       0a		      asl
     23  f7c1		       90 0d		      bcc	.else_3
     24  f7c3		       a2 79		      ldx	#NOP_REG
     25  f7c5		       8e 1c f0 	      stx	[KernelA_E_W + 1 + 0]
     26  f7c8		       a2 11		      ldx	#RESP1
     27  f7ca		       8e 20 f0 	      stx	[KernelA_G_W + 1 + 0]
     28  f7cd		       4c df f7 	      jmp	.endif_3
     29  f7d0				   .else_3
     30  f7d0		       a2 11		      ldx	#RESP1
     31  f7d2		       8e 1c f0 	      stx	[KernelA_E_W + 1 + 0]
     32  f7d5		       a6 9f		      ldx	RamKernelGemini2
     33  f7d7		       8e 1f f0 	      stx	[KernelA_G_W + 0]
     34  f7da		       a6 a0		      ldx	RamKernelGemini2Reg
     35  f7dc		       8e 20 f0 	      stx	[KernelA_G_W + 1]
     36  f7df				   .endif_3
     37  f7df				   .if_4
     38  f7df		       0a		      asl
     39  f7e0		       90 08		      bcc	.else_4
     40  f7e2		       a2 11		      ldx	#RESP1
     41  f7e4		       8e 22 f0 	      stx	[KernelA_H_W + 1 + 0]
     42  f7e7		       4c f4 f7 	      jmp	.endif_4
     43  f7ea				   .else_4
     44  f7ea		       a6 a1		      ldx	RamKernelGemini3
     45  f7ec		       8e 21 f0 	      stx	[KernelA_H_W + 0]
     46  f7ef		       a6 a2		      ldx	RamKernelGemini3Reg
     47  f7f1		       8e 22 f0 	      stx	[KernelA_H_W + 1]
     48  f7f4				   .endif_4
    449  f7f4		       a5 92		      lda	RamNibbleVar2
      0  f7f6					      NIBBLE_gem_kernel_a_2
      1  f7f6				   .if_1
      2  f7f6		       0a		      asl
      3  f7f7		       90 20		      bcc	.else_1
      4  f7f9		       a2 85		      ldx	#BC_STA
      5  f7fb		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
      6  f7fe		       a2 11		      ldx	#EMERALD_SP_RESET
      7  f800		       8e 24 f0 	      stx	[[KernelA_I_W + 0] + 1]
      8  f803		       a2 85		      ldx	#BC_STA
      9  f805		       8e 25 f0 	      stx	[[KernelA_J_W + 1] + 0]
     10  f808		       a2 0e		      ldx	#PF1
     11  f80a		       8e 26 f0 	      stx	[[KernelA_J_W + 1] + 1]
     12  f80d		       a2 08		      ldx	#BC_PHP
     13  f80f		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
     14  f812		       a2 26		      ldx	#VDELP1
     15  f814		       86 9a		      stx	[RamKernelPhpTarget + 0]
     16  f816		       4c 36 f8 	      jmp	.endif_1
     17  f819				   .else_1
     18  f819		       a2 08		      ldx	#BC_PHP
     19  f81b		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
     20  f81e		       a2 85		      ldx	#BC_STA
     21  f820		       8e 24 f0 	      stx	[[KernelA_J_W + 0] + 0]
     22  f823		       a2 0e		      ldx	#PF1
     23  f825		       8e 25 f0 	      stx	[[KernelA_J_W + 0] + 1]
     24  f828		       a6 a3		      ldx	RamKernelGemini4
     25  f82a		       8e 26 f0 	      stx	[KernelA_K_W + 0]
     26  f82d		       a2 1c		      ldx	#EMERALD_SP
     27  f82f		       8e 27 f0 	      stx	[KernelA_K_W + 1]
     28  f832		       a2 11		      ldx	#RESP1
     29  f834		       86 9a		      stx	[RamKernelPhpTarget + 0]
     30  f836				   .endif_1
     31  f836				   .if_2
     32  f836		       0a		      asl
     33  f837		       90 08		      bcc	.else_2
     34  f839		       a2 04		      ldx	#BC_NOP
     35  f83b		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     36  f83e		       4c 46 f8 	      jmp	.endif_2
     37  f841				   .else_2
     38  f841		       a6 ab		      ldx	BuildKernelMissile
     39  f843		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     40  f846				   .endif_2
     41  f846		       a6 aa		      ldx	BuildKernelVdel1
     42  f848		       8e 2f f0 	      stx	[[KernelA_VDEL1 - $100] + 0]
     43  f84b		       a6 a9		      ldx	BuildKernelGrp0
     44  f84d		       8e 07 f0 	      stx	[[KernelA_VDEL0 - $100] + 0]
     45  f850		       a6 a6		      ldx	BuildKernelX
     46  f852		       86 9b		      stx	[RamKernelX + 0]
     47  f854		       a6 a7		      ldx	BuildKernelY
     48  f856		       86 9c		      stx	[RamKernelY + 0]
    451  f858		       4c 16 f9 	      jmp	.next
    452  f85b				   .kernel_b
    453  f85b		       a5 91		      lda	RamNibbleVar1
      0  f85d					      NIBBLE_gem_kernel_b
      1  f85d		       a6 9d		      ldx	RamKernelGemini1
      2  f85f		       8e 1b f0 	      stx	[KernelB_D_W + 0]
      3  f862				   .if_1
      4  f862		       0a		      asl
      5  f863		       90 44		      bcc	.else_1
      6  f865		       a2 1c		      ldx	#EMERALD_SP
      7  f867		       86 9a		      stx	[RamKernelPhpTarget + 0]
      8  f869		       a2 84		      ldx	#BC_STY
      9  f86b		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     10  f86e		       a2 11		      ldx	#EMERALD_SP_RESET
     11  f870		       8e 1e f0 	      stx	[[KernelB_E_W + 0] + 1]
     12  f873		       a2 08		      ldx	#BC_PHP
     13  f875		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     14  f878		       a2 85		      ldx	#BC_STA
     15  f87a		       8e 20 f0 	      stx	[[KernelB_G_W + 0] + 0]
     16  f87d		       a2 0e		      ldx	#PF1
     17  f87f		       8e 21 f0 	      stx	[[KernelB_G_W + 0] + 1]
     18  f882		       a6 a1		      ldx	RamKernelGemini3
     19  f884		       8e 22 f0 	      stx	[[KernelB_H_W + 0] + 0]
     20  f887		       a2 1c		      ldx	#EMERALD_SP
     21  f889		       8e 23 f0 	      stx	[[KernelB_H_W + 0] + 1]
     22  f88c				   .if_2
     23  f88c		       0a		      asl
     24  f88d		       90 0d		      bcc	.else_2
     25  f88f		       a2 38		      ldx	#$38
     26  f891		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     27  f894		       a2 93		      ldx	#RamZeroByte
     28  f896		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     29  f899		       4c a6 f8 	      jmp	.endif_2
     30  f89c				   .else_2
     31  f89c		       a2 18		      ldx	#$18
     32  f89e		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     33  f8a1		       a2 94		      ldx	#RamLowerSixByte
     34  f8a3		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     35  f8a6				   .endif_2
     36  f8a6		       4c b3 f8 	      jmp	.endif_1
     37  f8a9				   .else_1
     38  f8a9		       a6 9f		      ldx	RamKernelGemini2
     39  f8ab		       8e 1e f0 	      stx	[KernelB_F_W + 0]
     40  f8ae		       a2 1c		      ldx	#EMERALD_SP
     41  f8b0		       8e 1f f0 	      stx	[KernelB_F_W + 1]
     42  f8b3				   .endif_1
     43  f8b3				   .if_3
     44  f8b3		       0a		      asl
     45  f8b4		       90 44		      bcc	.else_3
     46  f8b6		       a2 1c		      ldx	#EMERALD_SP
     47  f8b8		       86 9a		      stx	[RamKernelPhpTarget + 0]
     48  f8ba		       a2 84		      ldx	#BC_STY
     49  f8bc		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     50  f8bf		       a2 11		      ldx	#EMERALD_SP_RESET
     51  f8c1		       8e 1e f0 	      stx	[[KernelB_E_W + 0] + 1]
     52  f8c4		       a6 9f		      ldx	RamKernelGemini2
     53  f8c6		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     54  f8c9		       a2 1c		      ldx	#EMERALD_SP
     55  f8cb		       8e 20 f0 	      stx	[[KernelB_F_W + 1] + 1]
     56  f8ce		       a2 85		      ldx	#BC_STA
     57  f8d0		       8e 21 f0 	      stx	[[KernelB_G_W + 1] + 0]
     58  f8d3		       a2 0e		      ldx	#PF1
     59  f8d5		       8e 22 f0 	      stx	[[KernelB_G_W + 1] + 1]
     60  f8d8		       a2 08		      ldx	#BC_PHP
     61  f8da		       8e 23 f0 	      stx	[[KernelB_H_W + 1] + 0]
     62  f8dd				   .if_4
     63  f8dd		       0a		      asl
     64  f8de		       90 0d		      bcc	.else_4
     65  f8e0		       a2 38		      ldx	#$38
     66  f8e2		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     67  f8e5		       a2 93		      ldx	#RamZeroByte
     68  f8e7		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     69  f8ea		       4c f7 f8 	      jmp	.endif_4
     70  f8ed				   .else_4
     71  f8ed		       a2 18		      ldx	#$18
     72  f8ef		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     73  f8f2		       a2 94		      ldx	#RamLowerSixByte
     74  f8f4		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     75  f8f7				   .endif_4
     76  f8f7		       4c 04 f9 	      jmp	.endif_3
     77  f8fa				   .else_3
     78  f8fa		       a6 a1		      ldx	RamKernelGemini3
     79  f8fc		       8e 22 f0 	      stx	[KernelB_H_W + 0]
     80  f8ff		       a2 1c		      ldx	#EMERALD_SP
     81  f901		       8e 23 f0 	      stx	[KernelB_H_W + 1]
     82  f904				   .endif_3
     83  f904		       a6 a3		      ldx	RamKernelGemini4
     84  f906		       8e 26 f0 	      stx	[KernelB_J_W + 0]
     85  f909		       a6 a9		      ldx	BuildKernelGrp0
     86  f90b		       8e 07 f0 	      stx	[[KernelB_VDEL0 - $100] + 0]
     87  f90e		       a6 a6		      ldx	BuildKernelX
     88  f910		       86 9b		      stx	[RamKernelX + 0]
     89  f912		       a6 a7		      ldx	BuildKernelY
     90  f914		       86 9c		      stx	[RamKernelY + 0]
    455  f916				   .next
    456  f916		       60		      rts
    457  f917
    458  f917
    459  f917							; Populate Gemini array from level_for_game
    460  f917
    461  f917					      mac	gemini_populate
    462  f917				   .TARGET    SET	{1}
    463  f917					      lda	RamNibbleTemp
    464  f917					      and	#%00000011
    465  f917					      tay
    466  f917					      lda	GEMINI_LOOKUP,y
    467  f917					      sta	.TARGET
    468  f917					      endm
    469  f917
    470  f917					      mac	gemini_populate_missile
    471  f917				   .TARGET    SET	{1}
    472  f917					      lda	RamNibbleTemp
    473  f917					      and	#%00000001
    474  f917					      sta	.TARGET
    475  f917					      endm
    476  f917
    477  fa00		       00 00 00 00*	      align	256
    478  fa00
    479  fa00				   gemini_populate
    480  fa00		       a6 af		      ldx	level_for_game + 3
    481  fa02		       86 90		      stx	RamNibbleTemp
      0  fa04					      GEMINI_POPULATE	DO_GEMS_B + 5
      1  fa04				   .TARGET    SET	DO_GEMS_B + 5
      2  fa04		       a5 90		      lda	RamNibbleTemp
      3  fa06		       29 03		      and	#%00000011
      4  fa08		       a8		      tay
      5  fa09		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa0c		       85 bd		      sta	.TARGET
    483  fa0e		       66 90		      ror	RamNibbleTemp
    484  fa10		       66 90		      ror	RamNibbleTemp
      0  fa12					      GEMINI_POPULATE	DO_GEMS_A + 5
      1  fa12				   .TARGET    SET	DO_GEMS_A + 5
      2  fa12		       a5 90		      lda	RamNibbleTemp
      3  fa14		       29 03		      and	#%00000011
      4  fa16		       a8		      tay
      5  fa17		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa1a		       85 b7		      sta	.TARGET
    486  fa1c		       66 90		      ror	RamNibbleTemp
    487  fa1e		       66 90		      ror	RamNibbleTemp
      0  fa20					      GEMINI_POPULATE	DO_GEMS_B + 4
      1  fa20				   .TARGET    SET	DO_GEMS_B + 4
      2  fa20		       a5 90		      lda	RamNibbleTemp
      3  fa22		       29 03		      and	#%00000011
      4  fa24		       a8		      tay
      5  fa25		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa28		       85 bc		      sta	.TARGET
    489  fa2a		       66 90		      ror	RamNibbleTemp
    490  fa2c		       66 90		      ror	RamNibbleTemp
      0  fa2e					      GEMINI_POPULATE	DO_GEMS_A + 4
      1  fa2e				   .TARGET    SET	DO_GEMS_A + 4
      2  fa2e		       a5 90		      lda	RamNibbleTemp
      3  fa30		       29 03		      and	#%00000011
      4  fa32		       a8		      tay
      5  fa33		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa36		       85 b6		      sta	.TARGET
    492  fa38		       66 90		      ror	RamNibbleTemp
    493  fa3a		       66 90		      ror	RamNibbleTemp
    494  fa3c
    495  fa3c		       a6 ae		      ldx	level_for_game + 2
    496  fa3e		       86 90		      stx	RamNibbleTemp
      0  fa40					      GEMINI_POPULATE_MISSILE	DO_MISS_B
      1  fa40				   .TARGET    SET	DO_MISS_B
      2  fa40		       a5 90		      lda	RamNibbleTemp
      3  fa42		       29 01		      and	#%00000001
      4  fa44		       85 b1		      sta	.TARGET
    498  fa46		       66 90		      ror	RamNibbleTemp
      0  fa48					      GEMINI_POPULATE	DO_GEMS_B + 3
      1  fa48				   .TARGET    SET	DO_GEMS_B + 3
      2  fa48		       a5 90		      lda	RamNibbleTemp
      3  fa4a		       29 03		      and	#%00000011
      4  fa4c		       a8		      tay
      5  fa4d		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa50		       85 bb		      sta	.TARGET
    500  fa52		       66 90		      ror	RamNibbleTemp
    501  fa54		       66 90		      ror	RamNibbleTemp
      0  fa56					      GEMINI_POPULATE	DO_GEMS_A + 3
      1  fa56				   .TARGET    SET	DO_GEMS_A + 3
      2  fa56		       a5 90		      lda	RamNibbleTemp
      3  fa58		       29 03		      and	#%00000011
      4  fa5a		       a8		      tay
      5  fa5b		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa5e		       85 b5		      sta	.TARGET
    503  fa60		       66 90		      ror	RamNibbleTemp
    504  fa62		       66 90		      ror	RamNibbleTemp
      0  fa64					      GEMINI_POPULATE	DO_GEMS_B + 2
      1  fa64				   .TARGET    SET	DO_GEMS_B + 2
      2  fa64		       a5 90		      lda	RamNibbleTemp
      3  fa66		       29 03		      and	#%00000011
      4  fa68		       a8		      tay
      5  fa69		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa6c		       85 ba		      sta	.TARGET
    506  fa6e		       66 90		      ror	RamNibbleTemp
    507  fa70		       66 90		      ror	RamNibbleTemp
    508  fa72
    509  fa72		       66 90		      ror	RamNibbleTemp
    510  fa74		       a6 ad		      ldx	level_for_game + 1
    511  fa76		       86 90		      stx	RamNibbleTemp
    512  fa78		       26 90		      rol	RamNibbleTemp
      0  fa7a					      GEMINI_POPULATE	DO_GEMS_A + 2
      1  fa7a				   .TARGET    SET	DO_GEMS_A + 2
      2  fa7a		       a5 90		      lda	RamNibbleTemp
      3  fa7c		       29 03		      and	#%00000011
      4  fa7e		       a8		      tay
      5  fa7f		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa82		       85 b4		      sta	.TARGET
    514  fa84
    515  fa84		       a6 ad		      ldx	level_for_game + 1
    516  fa86		       86 90		      stx	RamNibbleTemp
    517  fa88		       66 90		      ror	RamNibbleTemp
      0  fa8a					      GEMINI_POPULATE_MISSILE	DO_MISS_A
      1  fa8a				   .TARGET    SET	DO_MISS_A
      2  fa8a		       a5 90		      lda	RamNibbleTemp
      3  fa8c		       29 01		      and	#%00000001
      4  fa8e		       85 b0		      sta	.TARGET
    519  fa90		       66 90		      ror	RamNibbleTemp
      0  fa92					      GEMINI_POPULATE	DO_GEMS_B + 1
      1  fa92				   .TARGET    SET	DO_GEMS_B + 1
      2  fa92		       a5 90		      lda	RamNibbleTemp
      3  fa94		       29 03		      and	#%00000011
      4  fa96		       a8		      tay
      5  fa97		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fa9a		       85 b9		      sta	.TARGET
    521  fa9c		       66 90		      ror	RamNibbleTemp
    522  fa9e		       66 90		      ror	RamNibbleTemp
      0  faa0					      GEMINI_POPULATE	DO_GEMS_A + 1
      1  faa0				   .TARGET    SET	DO_GEMS_A + 1
      2  faa0		       a5 90		      lda	RamNibbleTemp
      3  faa2		       29 03		      and	#%00000011
      4  faa4		       a8		      tay
      5  faa5		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  faa8		       85 b3		      sta	.TARGET
    524  faaa		       66 90		      ror	RamNibbleTemp
    525  faac		       66 90		      ror	RamNibbleTemp
      0  faae					      GEMINI_POPULATE	DO_GEMS_B + 0
      1  faae				   .TARGET    SET	DO_GEMS_B + 0
      2  faae		       a5 90		      lda	RamNibbleTemp
      3  fab0		       29 03		      and	#%00000011
      4  fab2		       a8		      tay
      5  fab3		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fab6		       85 b8		      sta	.TARGET
    527  fab8		       66 90		      ror	RamNibbleTemp
    528  faba		       66 90		      ror	RamNibbleTemp
    529  fabc
    530  fabc		       a6 ac		      ldx	level_for_game + 0
    531  fabe		       86 90		      stx	RamNibbleTemp
      0  fac0					      GEMINI_POPULATE	DO_GEMS_A + 0
      1  fac0				   .TARGET    SET	DO_GEMS_A + 0
      2  fac0		       a5 90		      lda	RamNibbleTemp
      3  fac2		       29 03		      and	#%00000011
      4  fac4		       a8		      tay
      5  fac5		       b9 d0 fa 	      lda	GEMINI_LOOKUP,y
      6  fac8		       85 b2		      sta	.TARGET
    533  faca		       66 90		      ror	RamNibbleTemp
    534  facc		       66 90		      ror	RamNibbleTemp
    535  face
    536  face		       60		      rts
    537  facf				   gemini_populate_end
    538  facf
    539  fad0		       00		      align	16
    540  fad0
    541  fad0				   GEMINI_LOOKUP
    542  fad0		       00 60 06 66	      .byte.b	G00, G01, G10, G11
    543  fad4
    544  fad4				   SHARD_LUT_RF1
    545  fad4		       00		      .byte.b	#0
    546  fad5				   SHARD_LUT_VD1
    547  fad5		       00		      .byte.b	#0
    548  fad6
------- FILE main.s
------- FILE game_state.s LEVEL 2 PASS 2
      0  fad6					      include	"game_state.s"
      1  fad6				   game_state_setup
      2  fad6							; Set up the level
      3  fad6		       a9 fb		      lda	#%11111011
      4  fad8		       85 ac		      sta	[level_for_game + 0]
      5  fada		       a9 ff		      lda	#%11111111
      6  fadc		       85 ad		      sta	[level_for_game + 1]
      7  fade		       a9 ff		      lda	#%11111111
      8  fae0		       85 ae		      sta	[level_for_game + 2]
      9  fae2		       a9 ff		      lda	#%11111111
     10  fae4		       85 af		      sta	[level_for_game + 3]
     11  fae6		       60		      rts
     12  fae7
     13  fae7				   game_state_tick
     14  fae7		       a5 84		      lda	FrameCount
     15  fae9		       29 0f		      and	#%1111
     16  faeb		       d0 14		      bne	.skiprotate
     17  faed		       a5 af		      lda	level_for_game + 3
     18  faef		       6a		      ror
     19  faf0				   .rollall
      0  faf0					      _ROR32	level_for_game, level_for_game
      1  faf0		       00 ac	   VLA	      EQU	level_for_game
      2  faf0		       00 ac	   RES	      EQU	level_for_game
      3  faf0				  -	      IF	VLA != RES
      4  faf0				  -	      LDA	VLA+0
      5  faf0				  -	      ROR	A
      6  faf0				  -	      STA	RES+0
      7  faf0				  -	      LDA	VLA+1
      8  faf0				  -	      ROR	A
      9  faf0				  -	      STA	RES+1
     10  faf0				  -	      LDA	VLA+2
     11  faf0				  -	      ROR	A
     12  faf0				  -	      STA	RES+2
     13  faf0				  -	      LDA	VLA+3
     14  faf0				  -	      ROR	A
     15  faf0				  -	      STA	RES+3
     16  faf0					      ELSE
     17  faf0		       66 ac		      ROR	VLA+0
     18  faf2		       66 ad		      ROR	VLA+1
     19  faf4		       66 ae		      ROR	VLA+2
     20  faf6		       66 af		      ROR	VLA+3
     21  faf8					      ENDIF
     21  faf8
     22  faf8		       a9 fb		      lda	#%11111011
     23  fafa		       c5 ae		      cmp	[level_for_game + 2]
     24  fafc		       d0 03		      bne	.skiprotate
     25  fafe		       4c d6 fa 	      jmp	game_state_setup
     26  fb01				   .skiprotate
     27  fb01		       60		      rts
------- FILE main.s
------- FILE kernel_border.s LEVEL 2 PASS 2
      0  fb02					      include	"kernel_border.s"
      1  fb02							; Visible Kernel
      2  fb02
      3  fb02				   KernelBorder subroutine
      4  fb02		       85 02		      sta	WSYNC	; ??? Is this needed?
      5  fb04
      6  fb04							; First HMOVE
      7  fb04		       85 2a		      sta	HMOVE
      8  fb06
      9  fb06							; Border top
     10  fb06		       a9 00		      lda	#0
     11  fb08		       85 08		      sta	COLUPF
     12  fb0a		       85 0e		      sta	PF1
     13  fb0c		       85 0f		      sta	PF2
     14  fb0e		       a9 02		      lda	#SIGNAL_LINE
     15  fb10		       85 09		      sta	COLUBK
     16  fb12
     17  fb12					      REPEAT	6
     18  fb12		       85 02		      sta	WSYNC
     17  fb12					      REPEND
     18  fb14		       85 02		      sta	WSYNC
     17  fb14					      REPEND
     18  fb16		       85 02		      sta	WSYNC
     17  fb16					      REPEND
     18  fb18		       85 02		      sta	WSYNC
     17  fb18					      REPEND
     18  fb1a		       85 02		      sta	WSYNC
     17  fb1a					      REPEND
     18  fb1c		       85 02		      sta	WSYNC
     19  fb1e					      REPEND
     20  fb1e
     21  fb1e		       a9 00		      lda	#0
     22  fb20		       85 09		      sta	COLUBK
     23  fb22		       85 02		      sta	WSYNC
     24  fb24
     25  fb24							; Start top border
     26  fb24				   border_top
     27  fb24							; Make the playfield solid.
     28  fb24		       a9 3f		      lda	#%00111111
     29  fb26		       85 0e		      sta	PF1
     30  fb28		       a9 ff		      lda	#%11111111
     31  fb2a		       85 0f		      sta	PF2
     32  fb2c
     33  fb2c		       a9 42		      lda	#COL_BG
     34  fb2e		       a0 00		      ldy	#0
     35  fb30
     36  fb30							; X_XXXX_XX
     37  fb30							; Commented lines removed to save on space.
     38  fb30		       85 08		      sta	COLUPF
     39  fb32		       85 02		      sta	WSYNC
     40  fb34		       84 08		      sty	COLUPF
     41  fb36		       85 02		      sta	WSYNC
     42  fb38		       85 08		      sta	COLUPF
     43  fb3a		       85 02		      sta	WSYNC
     44  fb3c							; sta COLUPF
     45  fb3c		       85 02		      sta	WSYNC
     46  fb3e							; sta COLUPF
     47  fb3e		       85 02		      sta	WSYNC
     48  fb40		       84 08		      sty	COLUPF
     49  fb42		       85 02		      sta	WSYNC
     50  fb44		       85 08		      sta	COLUPF
     51  fb46
     52  fb46		       85 02		      sta	WSYNC
     53  fb48							; sta COLUPF
     54  fb48
     55  fb48				   PlayArea
     56  fb48							; PF is now the playing area
      0  fb48					      ASSERT_RUNTIME	"_scycles == #0"
      1  fb48				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fb48  && !(  _scycles == #0  ) }
      2  fb48					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  fb48					      sleep	61
      1  fb48				   .CYCLES    SET	61
      2  fb48
      3  fb48				  -	      IF	.CYCLES < 2
      4  fb48				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb48				  -	      ERR
      6  fb48					      ENDIF
      7  fb48
      8  fb48					      IF	.CYCLES & 1
      9  fb48					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb48		       04 00		      nop	0
     11  fb4a				  -	      ELSE
     12  fb4a				  -	      bit	VSYNC
     13  fb4a					      ENDIF
     14  fb4a				   .CYCLES    SET	.CYCLES - 3
     15  fb4a					      ENDIF
     16  fb4a
     17  fb4a					      REPEAT	.CYCLES / 2
     18  fb4a		       ea		      nop
     17  fb4a					      REPEND
     18  fb4b		       ea		      nop
     17  fb4b					      REPEND
     18  fb4c		       ea		      nop
     17  fb4c					      REPEND
     18  fb4d		       ea		      nop
     17  fb4d					      REPEND
     18  fb4e		       ea		      nop
     17  fb4e					      REPEND
     18  fb4f		       ea		      nop
     17  fb4f					      REPEND
     18  fb50		       ea		      nop
     17  fb50					      REPEND
     18  fb51		       ea		      nop
     17  fb51					      REPEND
     18  fb52		       ea		      nop
     17  fb52					      REPEND
     18  fb53		       ea		      nop
     17  fb53					      REPEND
     18  fb54		       ea		      nop
     17  fb54					      REPEND
     18  fb55		       ea		      nop
     17  fb55					      REPEND
     18  fb56		       ea		      nop
     17  fb56					      REPEND
     18  fb57		       ea		      nop
     17  fb57					      REPEND
     18  fb58		       ea		      nop
     17  fb58					      REPEND
     18  fb59		       ea		      nop
     17  fb59					      REPEND
     18  fb5a		       ea		      nop
     17  fb5a					      REPEND
     18  fb5b		       ea		      nop
     17  fb5b					      REPEND
     18  fb5c		       ea		      nop
     17  fb5c					      REPEND
     18  fb5d		       ea		      nop
     17  fb5d					      REPEND
     18  fb5e		       ea		      nop
     17  fb5e					      REPEND
     18  fb5f		       ea		      nop
     17  fb5f					      REPEND
     18  fb60		       ea		      nop
     17  fb60					      REPEND
     18  fb61		       ea		      nop
     17  fb61					      REPEND
     18  fb62		       ea		      nop
     17  fb62					      REPEND
     18  fb63		       ea		      nop
     17  fb63					      REPEND
     18  fb64		       ea		      nop
     17  fb64					      REPEND
     18  fb65		       ea		      nop
     17  fb65					      REPEND
     18  fb66		       ea		      nop
     19  fb67					      REPEND
     59  fb67		       a9 00		      lda	#%00000000
     60  fb69		       85 0d		      sta	PF0
     61  fb6b		       a9 20		      lda	#%00100000
     62  fb6d		       85 0e		      sta	PF1
     63  fb6f		       a9 00		      lda	#%00000000
     64  fb71		       85 0f		      sta	PF2
      0  fb73					      ASSERT_RUNTIME	"_scycles == #0"
      1  fb73				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fb73  && !(  _scycles == #0  ) }
      2  fb73					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  fb73					      sleep	7
      1  fb73				   .CYCLES    SET	7
      2  fb73
      3  fb73				  -	      IF	.CYCLES < 2
      4  fb73				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb73				  -	      ERR
      6  fb73					      ENDIF
      7  fb73
      8  fb73					      IF	.CYCLES & 1
      9  fb73					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb73		       04 00		      nop	0
     11  fb75				  -	      ELSE
     12  fb75				  -	      bit	VSYNC
     13  fb75					      ENDIF
     14  fb75				   .CYCLES    SET	.CYCLES - 3
     15  fb75					      ENDIF
     16  fb75
     17  fb75					      REPEAT	.CYCLES / 2
     18  fb75		       ea		      nop
     17  fb75					      REPEND
     18  fb76		       ea		      nop
     19  fb77					      REPEND
     67  fb77		       4c a9 fb 	      jmp	row_start
     68  fb7a							; enter row on cycle 10.
     69  fb7a
     70  fb7a							; reset the background for bottom of playfield
     71  fb7a				   border_bottom
     72  fb7a							;sta WSYNC
     73  fb7a
     74  fb7a							; Form the bottom of the level frame.
     75  fb7a		       a9 3f		      lda	#%00111111
     76  fb7c		       85 0e		      sta	PF1
     77  fb7e		       a9 ff		      lda	#%11111111
     78  fb80		       85 0f		      sta	PF2
     79  fb82
     80  fb82							; Clear all sprites.
     81  fb82		       a9 00		      lda	#0
     82  fb84		       85 1c		      sta	EMERALD_SP
     83  fb86		       85 1b		      sta	JET_SP
     84  fb88		       85 1e		      sta	EMERALD_MI_ENABLE
     85  fb8a
     86  fb8a		       a9 42		      lda	#COL_BG
     87  fb8c		       a0 00		      ldy	#0
     88  fb8e		       85 02		      sta	WSYNC
     89  fb90
     90  fb90		       84 08		      sty	COLUPF
     91  fb92		       85 02		      sta	WSYNC
     92  fb94
     93  fb94		       85 08		      sta	COLUPF
     94  fb96		       85 02		      sta	WSYNC
     95  fb98
     96  fb98		       85 02		      sta	WSYNC
     97  fb9a
     98  fb9a		       85 02		      sta	WSYNC
     99  fb9c
    100  fb9c		       84 08		      sty	COLUPF
    101  fb9e		       85 02		      sta	WSYNC
    102  fba0
    103  fba0		       85 08		      sta	COLUPF
    104  fba2		       85 02		      sta	WSYNC
    105  fba4		       85 02		      sta	WSYNC
    106  fba6		       4c 00 f5 	      jmp	FrameEnd
------- FILE main.s
------- FILE kernel_row.s LEVEL 2 PASS 2
      0  fba9					      include	"kernel_row.s"
      1  fba9							; Frame Start
      2  fba9
      3  fba9							; Macros for calculating sprite values (GRPx).
      4  fba9
      5  fba9							; mac jet_spritedata_calc
      6  fba9							;
      7  fba9							; loads the offset from Frame0 in Y, and the sprite value in A, and stores it in
      8  fba9							; GRP0.
      9  fba9					      mac	jet_spritedata_calc
     10  fba9					      dec	RamRowJetpackIndex
     11  fba9					      ldy	RamRowJetpackIndex
     12  fba9					      ldx	Frame0,Y
     13  fba9					      stx	JET_SP
     14  fba9					      endm
     15  fba9
     16  fba9				   row_start
     17  fba9
     18  fba9							; [scanline 1]
     19  fba9				   row_1
     20  fba9							; Enter after scanline starts on row "9" and wraps
      0  fba9					      ASSERT_RUNTIME	"_scycles == #10"
      1  fba9				   .COND      SET	"_scycles == #10"
 ASSERT: breakif { pc== $fba9  && !(  _scycles == #10  ) }
      2  fba9					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     22  fba9
     23  fba9							; Load sprite details
     24  fba9		       a9 0f		      lda	[#SPRITE_HEIGHT + #7]
     25  fbab		       c5 86		      cmp	SpriteEnd	; 5c
     26  fbad		       a9 00		      lda	#0	; 2c
     27  fbaf							; constant 6c: if carry set, load SpriteEnd into y
     28  fbaf		       b0 01		      .byte.b	$b0, $01	; 2c / 3c (taken)  : bcs +01 (skipping 1-byte bit instr)
     29  fbb1		       0c		      .byte.b	$0c	; 4c / 0c		: bit (skip next two bytes)
     30  fbb2		       a5 86		      lda	SpriteEnd
     31  fbb4		       69 08		      adc	#8
     32  fbb6		       85 97		      sta	RamRowJetpackIndex
     33  fbb8
     34  fbb8							; Load sprite
     35  fbb8		       c6 97		      dec	RamRowJetpackIndex
     36  fbba		       a4 97		      ldy	RamRowJetpackIndex
     37  fbbc		       be 00 fe 	      ldx	Frame0,Y
     38  fbbf		       86 1b		      stx	JET_SP
     39  fbc1
     40  fbc1							; TODO assert cycle is not in visible range!
     41  fbc1
     42  fbc1							; [[[Nibble VM.]]]
     43  fbc1		       85 02		      sta	WSYNC
     44  fbc3
     45  fbc3							; sleep 46
     46  fbc3
      0  fbc3					      ASSERT_RUNTIME	"_scycles == #0"
      1  fbc3				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fbc3  && !(  _scycles == #0  ) }
      2  fbc3					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     48  fbc3
     49  fbc3							; [scanline 2]
     50  fbc3				   row_2
      0  fbc3					      jet_spritedata_calc
      1  fbc3		       c6 97		      dec	RamRowJetpackIndex
      2  fbc5		       a4 97		      ldy	RamRowJetpackIndex
      3  fbc7		       be 00 fe 	      ldx	Frame0,Y
      4  fbca		       86 1b		      stx	JET_SP
      0  fbcc					      sleep	5
      1  fbcc				   .CYCLES    SET	5
      2  fbcc
      3  fbcc				  -	      IF	.CYCLES < 2
      4  fbcc				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbcc				  -	      ERR
      6  fbcc					      ENDIF
      7  fbcc
      8  fbcc					      IF	.CYCLES & 1
      9  fbcc					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbcc		       04 00		      nop	0
     11  fbce				  -	      ELSE
     12  fbce				  -	      bit	VSYNC
     13  fbce					      ENDIF
     14  fbce				   .CYCLES    SET	.CYCLES - 3
     15  fbce					      ENDIF
     16  fbce
     17  fbce					      REPEAT	.CYCLES / 2
     18  fbce		       ea		      nop
     19  fbcf					      REPEND
     53  fbcf
     54  fbcf							; Black out playfield
     55  fbcf							; TODO This should be done with playfield pixels, not color.
     56  fbcf		       a9 00		      lda	#0
     57  fbd1		       85 08		      sta	COLUPF
     58  fbd3
     59  fbd3							; [[[Nibble VM.]]]
      0  fbd3					      sleep	25
      1  fbd3				   .CYCLES    SET	25
      2  fbd3
      3  fbd3				  -	      IF	.CYCLES < 2
      4  fbd3				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbd3				  -	      ERR
      6  fbd3					      ENDIF
      7  fbd3
      8  fbd3					      IF	.CYCLES & 1
      9  fbd3					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbd3		       04 00		      nop	0
     11  fbd5				  -	      ELSE
     12  fbd5				  -	      bit	VSYNC
     13  fbd5					      ENDIF
     14  fbd5				   .CYCLES    SET	.CYCLES - 3
     15  fbd5					      ENDIF
     16  fbd5
     17  fbd5					      REPEAT	.CYCLES / 2
     18  fbd5		       ea		      nop
     17  fbd5					      REPEND
     18  fbd6		       ea		      nop
     17  fbd6					      REPEND
     18  fbd7		       ea		      nop
     17  fbd7					      REPEND
     18  fbd8		       ea		      nop
     17  fbd8					      REPEND
     18  fbd9		       ea		      nop
     17  fbd9					      REPEND
     18  fbda		       ea		      nop
     17  fbda					      REPEND
     18  fbdb		       ea		      nop
     17  fbdb					      REPEND
     18  fbdc		       ea		      nop
     17  fbdc					      REPEND
     18  fbdd		       ea		      nop
     17  fbdd					      REPEND
     18  fbde		       ea		      nop
     17  fbde					      REPEND
     18  fbdf		       ea		      nop
     19  fbe0					      REPEND
     61  fbe0
     62  fbe0							; Load PF1 value
     63  fbe0		       a9 3f		      lda	#%00111111
     64  fbe2		       85 98		      sta	RamPF1Value
     65  fbe4
     66  fbe4		       a9 04		      lda	#4
     67  fbe6		       8d 96 02 	      sta	TIM64T
     68  fbe9
     69  fbe9							; Enable playfield at end of scanline
     70  fbe9		       a9 42		      lda	#COL_BG
     71  fbeb		       85 08		      sta	COLUPF
     72  fbed
     73  fbed							; Set stack pointer for PHP use from RamKernelPhpTarget.
     74  fbed		       a6 9a		      ldx	RamKernelPhpTarget
     75  fbef		       ca		      dex
     76  fbf0		       9a		      txs
     77  fbf1
     78  fbf1							; Set overflow flag
     79  fbf1		       24 95		      bit	RamFFByte
     80  fbf3
      0  fbf3					      ASSERT_RUNTIME	"_scycles == #0"
      1  fbf3				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fbf3  && !(  _scycles == #0  ) }
      2  fbf3					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     82  fbf3
     83  fbf3							; [scanline 3]
     84  fbf3				   row_3
     85  fbf3							; Current row and next two rows.
     86  fbf3		       a4 97		      ldy	RamRowJetpackIndex
     87  fbf5		       88		      dey
     88  fbf6		       be 00 fe 	      ldx	Frame0,Y
     89  fbf9		       86 1b		      stx	JET_SP
     90  fbfb		       88		      dey
     91  fbfc		       be 00 fe 	      ldx	Frame0,Y
     92  fbff		       86 99		      stx	RamKernelGRP0
     93  fc01		       88		      dey
     94  fc02		       be 00 fe 	      ldx	Frame0,Y
     95  fc05		       8e 03 f0 	      stx	[KernelA_GRP0 - $100]
     96  fc08		       84 97		      sty	RamRowJetpackIndex
     97  fc0a
     98  fc0a							; Idle.
      0  fc0a					      sleep	22
      1  fc0a				   .CYCLES    SET	22
      2  fc0a
      3  fc0a				  -	      IF	.CYCLES < 2
      4  fc0a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc0a				  -	      ERR
      6  fc0a					      ENDIF
      7  fc0a
      8  fc0a				  -	      IF	.CYCLES & 1
      9  fc0a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc0a				  -	      nop	0
     11  fc0a				  -	      ELSE
     12  fc0a				  -	      bit	VSYNC
     13  fc0a				  -	      ENDIF
     14  fc0a				  -.CYCLES    SET	.CYCLES - 3
     15  fc0a					      ENDIF
     16  fc0a
     17  fc0a					      REPEAT	.CYCLES / 2
     18  fc0a		       ea		      nop
     17  fc0a					      REPEND
     18  fc0b		       ea		      nop
     17  fc0b					      REPEND
     18  fc0c		       ea		      nop
     17  fc0c					      REPEND
     18  fc0d		       ea		      nop
     17  fc0d					      REPEND
     18  fc0e		       ea		      nop
     17  fc0e					      REPEND
     18  fc0f		       ea		      nop
     17  fc0f					      REPEND
     18  fc10		       ea		      nop
     17  fc10					      REPEND
     18  fc11		       ea		      nop
     17  fc11					      REPEND
     18  fc12		       ea		      nop
     17  fc12					      REPEND
     18  fc13		       ea		      nop
     17  fc13					      REPEND
     18  fc14		       ea		      nop
     19  fc15					      REPEND
    100  fc15
    101  fc15							; Setup for kernel
    102  fc15		       38		      sec		; clear carry bit
    103  fc16		       a6 9b		      ldx	RamKernelX
    104  fc18		       a4 9c		      ldy	RamKernelY
    105  fc1a
    106  fc1a							; Jump immediately into scanlines 4-5 aka "kernel_gem"
    107  fc1a		       a5 aa		      lda	BuildKernelVdel1
    108  fc1c		       85 1c		      sta	EMERALD_SP
    109  fc1e		       a5 99		      lda	RamKernelGRP0	; Load sprite 2 into A
    110  fc20							; [scanline 4]
    111  fc20							; [scanline 5]
      0  fc20					      ASSERT_RUNTIME	"_scycles == #73"
      1  fc20				   .COND      SET	"_scycles == #73"
 ASSERT: breakif { pc== $fc20  && !(  _scycles == #73  ) }
      2  fc20					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    113  fc20		       4c 04 f1 	      jmp	CBSRAM_KERNEL_ENTRY
    114  fc23
    115  fc23							; [scanline 6]
    116  fc23
    117  fc23							; Try to avoid page crossing in jet_spritedata_calc
    118  fc23							; TODO enforce this with ASSERT_RUNTIME instead?
    119  fc30		       00 00 00 00*	      align	16
    120  fc30
    121  fc30				   row_after_kernel
    122  fc30				   row_6
      0  fc30					      ASSERT_RUNTIME	"_scycles == #0"
      1  fc30				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fc30  && !(  _scycles == #0  ) }
      2  fc30					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    124  fc30
    125  fc30							; Cleanup from the kernel.
    126  fc30		       a9 00		      lda	#0
    127  fc32		       85 1e		      sta	EMERALD_MI_ENABLE
    128  fc34		       85 1c		      sta	EMERALD_SP
    129  fc36		       85 08		      sta	COLUPF
    130  fc38		       85 26		      sta	VDELP1
    131  fc3a
    132  fc3a		       a9 20		      lda	#%00100000
    133  fc3c		       85 0e		      sta	PF1
    134  fc3e
      0  fc3e					      jet_spritedata_calc
      1  fc3e		       c6 97		      dec	RamRowJetpackIndex
      2  fc40		       a4 97		      ldy	RamRowJetpackIndex
      3  fc42		       be 00 fe 	      ldx	Frame0,Y
      4  fc45		       86 1b		      stx	JET_SP
    136  fc47
    137  fc47							; Idle.
    138  fc47		       85 02		      sta	WSYNC
    139  fc49
    140  fc49							; [scanline 7]
    141  fc49				   row_7
      0  fc49					      jet_spritedata_calc
      1  fc49		       c6 97		      dec	RamRowJetpackIndex
      2  fc4b		       a4 97		      ldy	RamRowJetpackIndex
      3  fc4d		       be 00 fe 	      ldx	Frame0,Y
      4  fc50		       86 1b		      stx	JET_SP
      0  fc52					      sleep	5
      1  fc52				   .CYCLES    SET	5
      2  fc52
      3  fc52				  -	      IF	.CYCLES < 2
      4  fc52				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc52				  -	      ERR
      6  fc52					      ENDIF
      7  fc52
      8  fc52					      IF	.CYCLES & 1
      9  fc52					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc52		       04 00		      nop	0
     11  fc54				  -	      ELSE
     12  fc54				  -	      bit	VSYNC
     13  fc54					      ENDIF
     14  fc54				   .CYCLES    SET	.CYCLES - 3
     15  fc54					      ENDIF
     16  fc54
     17  fc54					      REPEAT	.CYCLES / 2
     18  fc54		       ea		      nop
     19  fc55					      REPEND
      0  fc55					      ASSERT_RUNTIME	"_scycles == #20"
      1  fc55				   .COND      SET	"_scycles == #20"
 ASSERT: breakif { pc== $fc55  && !(  _scycles == #20  ) }
      2  fc55					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    145  fc55
    146  fc55		       a9 42		      lda	#COL_BG
    147  fc57		       85 08		      sta	COLUPF
    148  fc59
    149  fc59							; FRAMESWITCH
    150  fc59		       a9 01		      lda	#01
    151  fc5b		       25 84		      and	FrameCount
    152  fc5d		       d0 11		      bne	loadframe2
    153  fc5f
    154  fc5f							; Perform gem loading for Kernel A.
    155  fc5f
    156  fc5f				   loadframe1
      0  fc5f					      ASSERT_RUNTIME	"_scycles == #32"
      1  fc5f				   .COND      SET	"_scycles == #32"
 ASSERT: breakif { pc== $fc5f  && !(  _scycles == #32  ) }
      2  fc5f					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    158  fc5f
    159  fc5f							; Emerald byte setting 1A
    160  fc5f							; ldx #0
    161  fc5f							; lda KERNEL_STORAGE_R,X
    162  fc5f							; sta GEM_00_W
    163  fc5f							; inx
    164  fc5f							; lda KERNEL_STORAGE_R,X
    165  fc5f							; sta GEM_04_W
    166  fc5f							; inx
    167  fc5f							; lda KERNEL_STORAGE_R,X
    168  fc5f							; sta GEM_09_W
    169  fc5f							; inx
    170  fc5f
    171  fc5f		       85 02		      sta	WSYNC
    172  fc61
    173  fc61							; [scanline 8]
      0  fc61					      jet_spritedata_calc
      1  fc61		       c6 97		      dec	RamRowJetpackIndex
      2  fc63		       a4 97		      ldy	RamRowJetpackIndex
      3  fc65		       be 00 fe 	      ldx	Frame0,Y
      4  fc68		       86 1b		      stx	JET_SP
      0  fc6a					      sleep	5
      1  fc6a				   .CYCLES    SET	5
      2  fc6a
      3  fc6a				  -	      IF	.CYCLES < 2
      4  fc6a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc6a				  -	      ERR
      6  fc6a					      ENDIF
      7  fc6a
      8  fc6a					      IF	.CYCLES & 1
      9  fc6a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc6a		       04 00		      nop	0
     11  fc6c				  -	      ELSE
     12  fc6c				  -	      bit	VSYNC
     13  fc6c					      ENDIF
     14  fc6c				   .CYCLES    SET	.CYCLES - 3
     15  fc6c					      ENDIF
     16  fc6c
     17  fc6c					      REPEAT	.CYCLES / 2
     18  fc6c		       ea		      nop
     19  fc6d					      REPEND
    176  fc6d
    177  fc6d							; Emerald byte setting 1B
    178  fc6d							; lda KERNEL_STORAGE_R,X
    179  fc6d							; sta GEM_13_W
    180  fc6d							; inx
    181  fc6d							; lda KERNEL_STORAGE_R,X
    182  fc6d							; sta GEM_17_W
    183  fc6d							; inx
    184  fc6d							; lda KERNEL_STORAGE_R,X
    185  fc6d							; sta GEM_18_W
    186  fc6d							; inx
    187  fc6d							; lda KERNEL_STORAGE_R,X
    188  fc6d							; sta GEM_22_W
    189  fc6d
    190  fc6d		       4c 81 fc 	      jmp	row_8_end
    191  fc70
    192  fc70							; Perform gem loading for Kernel B.
    193  fc70
    194  fc70				   loadframe2
      0  fc70					      ASSERT_RUNTIME	"_scycles == #33"
      1  fc70				   .COND      SET	"_scycles == #33"
 ASSERT: breakif { pc== $fc70  && !(  _scycles == #33  ) }
      2  fc70					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    196  fc70
    197  fc70							; Emerald byte setting 2A
    198  fc70							; ldx #[storage_02 - storage]
    199  fc70							; lda KERNEL_STORAGE_R,X
    200  fc70							; sta GEM_02_W
    201  fc70							; inx
    202  fc70							; lda KERNEL_STORAGE_R,X
    203  fc70							; sta GEM_06_W
    204  fc70							; inx
    205  fc70							; lda KERNEL_STORAGE_R,X
    206  fc70							; sta GEM_08_W
    207  fc70							; inx
    208  fc70
    209  fc70		       85 02		      sta	WSYNC
    210  fc72
    211  fc72							; [scanline 8]
    212  fc72				   row_8
      0  fc72					      jet_spritedata_calc
      1  fc72		       c6 97		      dec	RamRowJetpackIndex
      2  fc74		       a4 97		      ldy	RamRowJetpackIndex
      3  fc76		       be 00 fe 	      ldx	Frame0,Y
      4  fc79		       86 1b		      stx	JET_SP
      0  fc7b					      sleep	5
      1  fc7b				   .CYCLES    SET	5
      2  fc7b
      3  fc7b				  -	      IF	.CYCLES < 2
      4  fc7b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc7b				  -	      ERR
      6  fc7b					      ENDIF
      7  fc7b
      8  fc7b					      IF	.CYCLES & 1
      9  fc7b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc7b		       04 00		      nop	0
     11  fc7d				  -	      ELSE
     12  fc7d				  -	      bit	VSYNC
     13  fc7d					      ENDIF
     14  fc7d				   .CYCLES    SET	.CYCLES - 3
     15  fc7d					      ENDIF
     16  fc7d
     17  fc7d					      REPEAT	.CYCLES / 2
     18  fc7d		       ea		      nop
     19  fc7e					      REPEND
    215  fc7e
    216  fc7e							; Emerald byte setting 2B
    217  fc7e							; lda KERNEL_STORAGE_R,X
    218  fc7e							; sta GEM_11_W
    219  fc7e							; inx
    220  fc7e							; lda KERNEL_STORAGE_R,X
    221  fc7e							; sta GEM_15_W
    222  fc7e							; inx
    223  fc7e							; lda KERNEL_STORAGE_R,X
    224  fc7e							; sta GEM_20_W
    225  fc7e							; inx
    226  fc7e							; lda KERNEL_STORAGE_R,X
    227  fc7e							; sta GEM_24_W
    228  fc7e
    229  fc7e		       4c 81 fc 	      jmp	row_8_end
    230  fc81
    231  fc81							; Common row 8 return.
    232  fc81
    233  fc81				   row_8_end
    234  fc81							; Decrease SpriteEnd
    235  fc81		       38		      sec
    236  fc82		       a5 86		      lda	SpriteEnd
    237  fc84		       e9 08		      sbc	#8
    238  fc86		       85 86		      sta	SpriteEnd
    239  fc88
    240  fc88							; Idle.
    241  fc88		       85 02		      sta	WSYNC
    242  fc8a
    243  fc8a							; [scanline 8]
    244  fc8a							; Repeat loop until LoopCount < 0
    245  fc8a		       c6 83		      dec	LoopCount
    246  fc8c		       f0 03		      beq	row_end
    247  fc8e		       4c a9 fb 	      jmp	row_start
    248  fc91				   row_end
    249  fc91		       4c 7a fb 	      jmp	border_bottom
------- FILE main.s
------- FILE kernel_gem.s LEVEL 2 PASS 2
      0  fc94					      include	"kernel_gem.s"
      1  fc94							;
      2  fc94							; Gem Kernels
      3  fc94							;
      4  fc94							; Gems are displayed in alternating kernels. This chart shows
      5  fc94							; which kernel is responsible for which gem, with missiles denoted.
      6  fc94							;
      7  fc94							;  1:	 |SS  SS  MSS  |SS   SS  SS  |	      kernel 1 (S = Sprite, M = missile)
      8  fc94							;  2:	 |  SS	SS   SS|  SSM  SS  SS|	      kernel 2
      9  fc94							;  =	 |1122112221122|1122111221122|	      kernel #
     10  fc94							;  #	 0^	 8^	  17^	    26^       gem index
     11  fc94							;
     12  fc94							; The middle bar indicates where the pattern reverses.
     13  fc94							;
     14  fc94							; Because we can repeat a sprite multiple times, and reset the sprite
     15  fc94							; occurance mid-line, we can render close to half of the 26 gems a line
     16  fc94							; requires with a single sprite. By alternating sprites each frame with an...
     17  fc94							; acceptable amount of flicker (15Hz) we can render almost all the gems on each
     18  fc94							; line, except for two. These are instead rendered by the missile, which
     19  fc94							; corresponds to the sprite and must have the same color and repeat pattern.
     20  fc94
     21  fc94							; for copying
     22  fd00		       00 00 00 00*	      align	256
     23  fd00
     24  fd00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     25  fd00							;
     26  fd00							; GEM KERNEL A
     27  fd00							;
     28  fd00
     29  fd00				   kernel_1_start subroutine
     30  fd00					      rorg	$f100
     31  fd00
     32  fd00							; Kernel Marker
     33  fd00		       0a		      .byte.b	$A
     34  fd01
     35  fd01				   KernelA_early
      0  fd01					      ASSERT_RUNTIME_KERNEL	$A, "v == #1"
      1  fd01				   .KERNEL    SET	$A
      2  fd01				   .COND      SET	"v == #1"
 ASSERT: breakif { pc== $f101  && ( *$f100 ==  $a   ) && ! (  v == #1  ) }
      3  fd01					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     37  fd01		       b8		      clv
     38  fd02
     39  fd02							; Early code to set next Player GRP0. Immediate value is overwritten
     40  fd02		       a9 ff		      lda	#$ff
     41  fd02		       f1 03	   KernelA_GRP0 =	. - 1
     42  fd04
     43  fd04				   KernelA    subroutine
      0  fd04					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #0"
      1  fd04				   .KERNEL    SET	$A
      2  fd04				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $a   ) && ! (  _scycles == #0  ) }
      3  fd04					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     45  fd04
     46  fd04							; Write Player from accumulator. When writing to the other sprite, the
     47  fd04							; TIA will copy Gemini 0A into visible sprite register
     48  fd04		       85 1b		      sta	JET_SP
     49  fd06							; Write Gemini 1A into visible sprite register
     50  fd06		       a9 66		      lda	#%01100110
     51  fd06		       f1 07	   KernelA_VDEL0 =	. - 1
     52  fd08		       85 1c		      sta	EMERALD_SP
     53  fd0a
     54  fd0a							; Register config
     55  fd0a		       a9 08		      lda	#%00001000
     56  fd0c		       85 0c		      sta	REFP1
     57  fd0e
     58  fd0e		       a9 20		      lda	#%00100000
     59  fd10		       85 0e		      sta	PF1
     60  fd12
     61  fd12							; Reset stack pointer
     62  fd12		       68		      pla
     63  fd13
     64  fd13							; 22c is critical start of precise GRP0 timing for Kernel A
      0  fd13					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #22"
      1  fd13				   .KERNEL    SET	$A
      2  fd13				   .COND      SET	"_scycles == #22"
 ASSERT: breakif { pc== $f113  && ( *$f100 ==  $a   ) && ! (  _scycles == #22  ) }
      3  fd13					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     66  fd13				   KernelA_A
     67  fd13		       85 11		      sta	EMERALD_SP_RESET	; RESPx must be strobed on cycle 25c.
     68  fd15
     69  fd15							; RST0 vvv
     70  fd15				   KernelA_B
     71  fd15		       a5 98		      lda	RamPF1Value
     72  fd17				   KernelA_C
     73  fd17		       84 26		      sty	VDELP1	; disable delayed sprite
     74  fd19				   KernelA_D
     75  fd19							; sty EMERALD_SP ; Gemini 1A
      0  fd19					      sleep	3
      1  fd19				   .CYCLES    SET	3
      2  fd19
      3  fd19				  -	      IF	.CYCLES < 2
      4  fd19				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd19				  -	      ERR
      6  fd19					      ENDIF
      7  fd19
      8  fd19					      IF	.CYCLES & 1
      9  fd19					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd19		       04 00		      nop	0
     11  fd1b				  -	      ELSE
     12  fd1b				  -	      bit	VSYNC
     13  fd1b					      ENDIF
     14  fd1b				   .CYCLES    SET	.CYCLES - 3
     15  fd1b					      ENDIF
     16  fd1b
     17  fd1b				  -	      REPEAT	.CYCLES / 2
     18  fd1b				  -	      nop
     19  fd1b					      REPEND
     77  fd1b							; RST0 ^^^
     78  fd1b
     79  fd1b				   KernelA_E
     80  fd1b		       85 11		      sta	EMERALD_SP_RESET	; Reset "medium close" NUSIZ repetition
     81  fd1d				   KernelA_F
     82  fd1d		       86 1e		      stx	EMERALD_MI_ENABLE	; Enable the missile (if register uses the %0xx00110 pattern)
     83  fd1f				   KernelA_G
     84  fd1f		       84 1c		      sty	EMERALD_SP	; Gemini 2A
     85  fd21
     86  fd21				   KernelA_H
     87  fd21		       84 1c		      sty	EMERALD_SP	; Gemini 3A, modified for RST2 along with HMM1
     88  fd23
      0  fd23					      ASSERT_RUNTIME_KERNEL	$A, "c == #1"
      1  fd23				   .KERNEL    SET	$A
      2  fd23				   .COND      SET	"c == #1"
 ASSERT: breakif { pc== $f123  && ( *$f100 ==  $a   ) && ! (  c == #1  ) }
      3  fd23					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     90  fd23							; RST4 vvv
     91  fd23				   KernelA_I
     92  fd23		       08		      php		; Reset "medium close" NUSIZ repetition
     93  fd24				   KernelA_J		; unchanging
     94  fd24		       85 0e		      sta	PF1	; Write asymmetrical playfield register
     95  fd26				   KernelA_K
     96  fd26		       84 1c		      sty	EMERALD_SP	; Gemini 4A
     97  fd28							; RST4 ^^^
     98  fd28
     99  fd28				   KernelA_L
    100  fd28		       a5 93		      lda	RamZeroByte	; FIXME this doesn't belong here
    101  fd2a				   KernelA_M
    102  fd2a		       84 26		      sty	VDELP1	; Gemini 5A ; need a way to skip this vlaue
    103  fd2c				   KernelA_N
    104  fd2c		       85 1e		      sta	EMERALD_MI_ENABLE	; disable missile FIXME better place for this?
    105  fd2e				   KernelA_O
    106  fd2e		       a9 66		      lda	#%01100110
    107  fd2e		       f1 2f	   KernelA_VDEL1 =	. - 1
    108  fd30
    109  fd30							; End visible line
      0  fd30					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #66"
      1  fd30				   .KERNEL    SET	$A
      2  fd30				   .COND      SET	"_scycles == #66"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $a   ) && ! (  _scycles == #66  ) }
      3  fd30					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    111  fd30				   KernelA_branch
    112  fd30		       85 1c		      sta	EMERALD_SP	; set VDEL1
    113  fd32
    114  fd32							; Branch or return.
    115  fd32		       70 cd		      bvs	KernelA_early
      0  fd34					      sleep	2
      1  fd34				   .CYCLES    SET	2
      2  fd34
      3  fd34				  -	      IF	.CYCLES < 2
      4  fd34				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd34				  -	      ERR
      6  fd34					      ENDIF
      7  fd34
      8  fd34				  -	      IF	.CYCLES & 1
      9  fd34				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd34				  -	      nop	0
     11  fd34				  -	      ELSE
     12  fd34				  -	      bit	VSYNC
     13  fd34				  -	      ENDIF
     14  fd34				  -.CYCLES    SET	.CYCLES - 3
     15  fd34					      ENDIF
     16  fd34
     17  fd34					      REPEAT	.CYCLES / 2
     18  fd34		       ea		      nop
     19  fd35					      REPEND
    117  fd35		       4c 30 fc 	      jmp	row_after_kernel
    118  fd38
    119  fd38					      rend
    120  fd38				   kernel_1_end
      0  fd38					      ASSERT_SIZE	kernel_1_start, kernel_1_end, $40
      1  fd38				   .STARTA    SET	kernel_1_start
      2  fd38				   .ENDA      SET	kernel_1_end
      3  fd38				   .LEN       SET	$40
      4  fd38				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fd38				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fd38				  -	      err
      7  fd38					      endif
    122  fd38
    123  fd38							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    124  fd38							;
    125  fd38							; GEM KERNEL B
    126  fd38							;
    127  fd38
    128  fd38				   kernel_2_start subroutine
    129  fd38					      rorg	$f100
    130  fd38
    131  fd38							; Kernel Marker
    132  fd38		       0b		      .byte.b	$B
    133  fd39
    134  fd39		       b8		      clv
    135  fd3a
    136  fd3a				   KernelB_early
    137  fd3a							; Early code to set next GRP0 image. Value is overwritten
    138  fd3a		       a9 ff		      lda	#$ff
    139  fd3a		       f1 03	   KernelB_GRP0 =	. - 1
    140  fd3c
    141  fd3c				   KernelB    subroutine
      0  fd3c					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #0"
      1  fd3c				   .KERNEL    SET	$B
      2  fd3c				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $b   ) && ! (  _scycles == #0  ) }
      3  fd3c					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    143  fd3c
    144  fd3c							; Write Player from accumulator. When writing to the other sprite, the
    145  fd3c							; TIA will copy Gemini 0A into visible sprite register
    146  fd3c		       85 1b		      sta	JET_SP
    147  fd3e		       a9 aa		      lda	#%10101010
    148  fd3e		       f1 07	   KernelB_VDEL0 =	. - 1
    149  fd40							; Write Gemini 1A into delayed sprite register
    150  fd40		       85 1c		      sta	EMERALD_SP
    151  fd42
    152  fd42							; Reset stack
    153  fd42		       68		      pla
    154  fd43
    155  fd43							; Register config
    156  fd43		       a9 ff		      lda	#$ff
    157  fd45		       85 1e		      sta	EMERALD_MI_ENABLE	; enable missile
    158  fd47
    159  fd47							; Set processor register bit for PHP sprite rendering.
    160  fd47		       38		      sec
    161  fd47		       f1 0f	   KernelB_P11_C =	. - 1
    162  fd48
    163  fd48							; 6c
    164  fd48		       a9 20		      lda	#%00100000
    165  fd4a		       8d 0e 00 	      sta.w	PF1
    166  fd4d
    167  fd4d							; 25c is critical start of precise GRP0 timing for Kernel B
      0  fd4d					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #25"
      1  fd4d				   .KERNEL    SET	$B
      2  fd4d				   .COND      SET	"_scycles == #25"
 ASSERT: breakif { pc== $f115  && ( *$f100 ==  $b   ) && ! (  _scycles == #25  ) }
      3  fd4d					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    169  fd4d				   KernelB_A
    170  fd4d		       85 11		      sta	EMERALD_SP_RESET
    171  fd4f				   KernelB_B
    172  fd4f		       24 93		      bit	RamZeroByte
    173  fd51				   KernelB_C
    174  fd51							; Load PF1 value into accumulator
    175  fd51		       a5 98		      lda	RamPF1Value
    176  fd53				   KernelB_D
    177  fd53		       86 1c		      stx	EMERALD_SP	; Gemini 1B
    178  fd55
    179  fd55							; below has one php load (could just be RESET)
    180  fd55				   KernelB_E
    181  fd55		       08		      php
    182  fd56				   KernelB_F
    183  fd56		       84 1c		      sty	EMERALD_SP	; Gemini 2B
    184  fd58				   KernelB_G
    185  fd58		       85 0e		      sta	PF1
    186  fd5a				   KernelB_H
    187  fd5a		       84 1c		      sty	EMERALD_SP	; Gemini 3B; TODO write php instead fixed
    188  fd5c							; above has one PHP load
    189  fd5c
    190  fd5c				   KernelB_I
    191  fd5c		       85 11		      sta	EMERALD_SP_RESET
    192  fd5e				   KernelB_J
    193  fd5e		       84 1c		      sty	EMERALD_SP	; Gemini 4B
    194  fd60				   KernelB_K
    195  fd60		       86 1e		      stx	EMERALD_MI_ENABLE
    196  fd62				   KernelB_L
    197  fd62		       86 1c		      stx	EMERALD_SP	; Gemini 5B
    198  fd64
    199  fd64				   KernelB_M
      0  fd64					      sleep	3
      1  fd64				   .CYCLES    SET	3
      2  fd64
      3  fd64				  -	      IF	.CYCLES < 2
      4  fd64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd64				  -	      ERR
      6  fd64					      ENDIF
      7  fd64
      8  fd64					      IF	.CYCLES & 1
      9  fd64					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd64		       04 00		      nop	0
     11  fd66				  -	      ELSE
     12  fd66				  -	      bit	VSYNC
     13  fd66					      ENDIF
     14  fd66				   .CYCLES    SET	.CYCLES - 3
     15  fd66					      ENDIF
     16  fd66
     17  fd66				  -	      REPEAT	.CYCLES / 2
     18  fd66				  -	      nop
     19  fd66					      REPEND
    201  fd66				   KernelB_N
      0  fd66					      sleep	3
      1  fd66				   .CYCLES    SET	3
      2  fd66
      3  fd66				  -	      IF	.CYCLES < 2
      4  fd66				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd66				  -	      ERR
      6  fd66					      ENDIF
      7  fd66
      8  fd66					      IF	.CYCLES & 1
      9  fd66					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd66		       04 00		      nop	0
     11  fd68				  -	      ELSE
     12  fd68				  -	      bit	VSYNC
     13  fd68					      ENDIF
     14  fd68				   .CYCLES    SET	.CYCLES - 3
     15  fd68					      ENDIF
     16  fd68
     17  fd68				  -	      REPEAT	.CYCLES / 2
     18  fd68				  -	      nop
     19  fd68					      REPEND
    203  fd68
    204  fd68							; End visible line
      0  fd68					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #67"
      1  fd68				   .KERNEL    SET	$B
      2  fd68				   .COND      SET	"_scycles == #67"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $b   ) && ! (  _scycles == #67  ) }
      3  fd68					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    206  fd68
    207  fd68				   KernelB_branch
    208  fd68		       ad 84 02 	      lda	INTIM
    209  fd6b		       d0 cd		      bne	KernelB_early
    210  fd6d		       4c 30 fc 	      jmp	row_after_kernel
    211  fd70
    212  fd70					      rend
    213  fd70				   kernel_2_end
      0  fd70					      ASSERT_SIZE	kernel_2_start, kernel_2_end, $40
      1  fd70				   .STARTA    SET	kernel_2_start
      2  fd70				   .ENDA      SET	kernel_2_end
      3  fd70				   .LEN       SET	$40
      4  fd70				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fd70				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fd70				  -	      err
      7  fd70					      endif
------- FILE main.s
------- FILE data_sprites.s LEVEL 2 PASS 2
      0  fd70					      include	"data_sprites.s"
      1  fd70
      2  fe00		       00 00 00 00*	      align	256
      3  fe00
      4  fe00				   Frame0
      5  fe00							; 8 buffer
      6  fe00		       00		      .byte.b	#%00000000
      7  fe01		       00		      .byte.b	#%00000000
      8  fe02		       00		      .byte.b	#%00000000
      9  fe03		       00		      .byte.b	#%00000000
     10  fe04		       00		      .byte.b	#%00000000
     11  fe05		       00		      .byte.b	#%00000000
     12  fe06		       00		      .byte.b	#%00000000
     13  fe07		       00		      .byte.b	#%00000000
     14  fe08
     15  fe08							; 8 rows
     16  fe08		       60		      .byte.b	#%01100000
     17  fe09		       60		      .byte.b	#%01100000
     18  fe0a		       60		      .byte.b	#%01100000
     19  fe0b		       c0		      .byte.b	#%11000000
     20  fe0c		       c0		      .byte.b	#%11000000
     21  fe0d		       f0		      .byte.b	#%11110000
     22  fe0e		       c0		      .byte.b	#%11000000
     23  fe0f		       c0		      .byte.b	#%11000000
     24  fe10
     25  fe10							; 8 buffer
     26  fe10		       00		      .byte.b	#%00000000
     27  fe11		       00		      .byte.b	#%00000000
     28  fe12		       00		      .byte.b	#%00000000
     29  fe13		       00		      .byte.b	#%00000000
     30  fe14		       00		      .byte.b	#%00000000
     31  fe15		       00		      .byte.b	#%00000000
     32  fe16		       00		      .byte.b	#%00000000
     33  fe17		       00		      .byte.b	#%00000000
------- FILE main.s
------- FILE data_levels.s LEVEL 2 PASS 2
      0  fe18					      include	"data_levels.s"
      1  fe18					      align	8
      2  fe18							; first bit of byte 2 & 3 are unused for simplicity
      3  fe18
      4  fe18				   level_00
      5  fe18		       f0 1f 1f 0f	      .byte.b	%11110000, %00011111, %00011111, %00001111
      6  fe1c
      7  fe1c				   level_01
      8  fe1c		       0a 1e 00 00	      .byte.b	%1010, %0011110, %0000000, %00000000
      9  fe20		       05 1e 00 00	      .byte.b	%0101, %0011110, %0000000, %00000000
     10  fe24		       02 47 40 00	      .byte.b	%0010, %1000111, %1000000, %00000000
     11  fe28		       01 27 40 00	      .byte.b	%0001, %0100111, %1000000, %00000000
     12  fe2c		       00 57 7c 00	      .byte.b	%0000, %1010111, %1111100, %00000000
     13  fe30		       00 28 3c 00	      .byte.b	%0000, %0101000, %0111100, %00000000
     14  fe34		       00 14 3c 00	      .byte.b	%0000, %0010100, %0111100, %00000000
     15  fe38		       00 0a 3c 00	      .byte.b	%0000, %0001010, %0111100, %00000000
     16  fe3c		       00 05 3c 00	      .byte.b	%0000, %0000101, %0111100, %00000000
     17  fe40		       00 02 43 c0	      .byte.b	%0000, %0000010, %1000011, %11000000
     18  fe44		       00 01 23 c0	      .byte.b	%0000, %0000001, %0100011, %11000000
     19  fe48		       00 00 53 c0	      .byte.b	%0000, %0000000, %1010011, %11000000
     20  fe4c		       00 00 2b c0	      .byte.b	%0000, %0000000, %0101011, %11000000
     21  fe50		       00 00 14 3c	      .byte.b	%0000, %0000000, %0010100, %00111100
     22  fe54		       00 00 0a 3c	      .byte.b	%0000, %0000000, %0001010, %00111100
     23  fe58		       00 00 05 3c	      .byte.b	%0000, %0000000, %0000101, %00111100
     24  fe5c		       00 00 02 bc	      .byte.b	%0000, %0000000, %0000010, %10111100
     25  fe60		       0c 00 01 43	      .byte.b	%1100, %0000000, %0000001, %01000011
     26  fe64		       0c 00 00 a3	      .byte.b	%1100, %0000000, %0000000, %10100011
     27  fe68		       0c 00 00 53	      .byte.b	%1100, %0000000, %0000000, %01010011
     28  fe6c		       0c 00 00 2b	      .byte.b	%1100, %0000000, %0000000, %00101011
     29  fe70		       03 60 00 14	      .byte.b	%0011, %1100000, %0000000, %00010100
     30  fe74		       03 60 00 0a	      .byte.b	%0011, %1100000, %0000000, %00001010
     31  fe78		       03 60 00 05	      .byte.b	%0011, %1100000, %0000000, %00000101
     32  fe7c		       0b 60 00 02	      .byte.b	%1011, %1100000, %0000000, %00000010
     33  fe80		       04 1e 00 01	      .byte.b	%0100, %0011110, %0000000, %00000001
     34  fe84				   level_01_end
     35  fe84
     36  fe84
     37  fe84				   shard_map
     38  fe84		       40		      .byte.b	%01000000	; [1, 0, 0]
     39  fe85				   shard_map_end
------- FILE main.s
    163  fe85
    164  fffc					      org	$fffc
    165  fffc		       09 f2		      .word.w	Start
    166  fffe		       09 f2		      .word.w	Start
