------- FILE main.s LEVEL 1 PASS 2
      1  fffe					      processor	6502
      2  10000 ????
      3  10000 ????						; Nibble null methods
      4  10000 ????				       mac	nibble_start_kernel
      5  10000 ????				       seg.U	ignoreme	; comment out rest of code
      6  10000 ????				       endm
      7  10000 ????				       mac	nibble_var
      8  10000 ????				       endm
      9  10000 ????				       mac	nibble_var_sty
     10  10000 ????				       endm
     11  10000 ????				       mac	nibble_if
     12  10000 ????				       endm
     13  10000 ????				       mac	nibble_write_imm
     14  10000 ????				       endm
     15  10000 ????				       mac	nibble_write_var
     16  10000 ????				       endm
     17  10000 ????				       mac	nibble_write_opcode
     18  10000 ????				       endm
     19  10000 ????				       mac	nibble_else
     20  10000 ????				       endm
     21  10000 ????				       mac	nibble_end_if
     22  10000 ????				       endm
     23  10000 ????				       mac	nibble_end_kernel
     24  10000 ????				       seg	CodeBank3
     25  10000 ????				       endm
     26  10000 ????
     27  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     28  10000 ????				       mac	assert_runtime
     29  10000 ????			    .COND      SET	{1}
     30  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     31  10000 ????				       endm
     32  10000 ????
     33  10000 ????
     34  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     35  10000 ????				       mac	assert_runtime_kernel
     36  10000 ????			    .KERNEL    SET	{1}
     37  10000 ????			    .COND      SET	{2}
     38  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     39  10000 ????				       endm
     40  10000 ????
     41  10000 ????						; Static assertions for size
     42  10000 ????				       mac	assert_size
     43  10000 ????			    .STARTA    SET	{1}
     44  10000 ????			    .ENDA      SET	{2}
     45  10000 ????			    .LEN       SET	{3}
     46  10000 ????				       if	[[.ENDA - .STARTA] >= .LEN]
     47  10000 ????				       echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
     48  10000 ????				       err
     49  10000 ????				       endif
     50  10000 ????				       endm
     51  10000 ????				       mac	assert_size_exact
     52  10000 ????			    .STARTA    SET	{1}
     53  10000 ????			    .ENDA      SET	{2}
     54  10000 ????			    .LEN       SET	{3}
     55  10000 ????				       if	[[.ENDA - .STARTA] != .LEN]
     56  10000 ????				       echo	""
     57  10000 ????				       echo	"Error: Violated size limit", [.ENDA - .STARTA], "vs", .LEN
     58  10000 ????				       err
     59  10000 ????				       endif
     60  10000 ????				       endm
     61  10000 ????
     62  10000 ????						; Global headers
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE main.s
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????
    163  0000 ????						; EOF
------- FILE main.s
------- FILE xmacro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"xmacro.h"
      1  0000 ????
      2  0000 ????						;-------------------------------------------------------
      3  0000 ????						; Usage: TIMER_SETUP lines
      4  0000 ????						; where lines is the number of scanlines to skip (> 2).
      5  0000 ????						; The timer will be set so that it expires before this number
      6  0000 ????						; of scanlines. A WSYNC will be done first.
      7  0000 ????
      8  0000 ????				      MAC	timer_setup
      9  0000 ????			   .lines     SET	{1}
     10  0000 ????				      lda	#(((.lines)*76-14)/64)
     11  0000 ????				      sta	WSYNC
     12  0000 ????				      sta	TIM64T
     13  0000 ????				      ENDM
     14  0000 ????
     15  0000 ????						;-------------------------------------------------------
     16  0000 ????						; Use with TIMER_SETUP to wait for timer to complete.
     17  0000 ????						; You may want to do a WSYNC afterwards, since the timer
     18  0000 ????						; is not accurate to the beginning/end of a scanline.
     19  0000 ????
     20  0000 ????				      MAC	timer_wait
     21  0000 ????			   .waittimer
     22  0000 ????				      lda	INTIM
     23  0000 ????				      bne	.waittimer
     24  0000 ????				      sta	WSYNC
     25  0000 ????				      ENDM
     26  0000 ????
------- FILE main.s
     66  0000 ????
     67  0000 ????						; RAM and constants
------- FILE game_define.s LEVEL 2 PASS 2
      0  0000 ????				      include	"game_define.s"
      1 U0000 ????				      seg.u	CompileFlags
      2 U0000 ????
      3 U0000 ????	       00 01	   ONLY_KERNEL_A =	1
      4 U0000 ????						; ONLY_KERNEL_B = 1
      5 U0000 ????
      6 U0000 ????
      7 U0000 ????				      seg.u	Defines
      8 U0000 ????
      9 U0000 ????	       00 10	   ROW_COUNT  =	16
     10 U0000 ????	       00 02	   SIGNAL_LINE =	$02
     11 U0000 ????	       00 07	   FrameSkip  =	%111	; Tick (every 8 frames)
     12 U0000 ????
     13 U0000 ????						; RAM+ memory map
     14 U0000 ????
     15 U0000 ????	       f0 00	   CBSRAM_KERNEL_WRITE =	$f000
     16 U0000 ????	       f1 00	   CBSRAM_KERNEL_READ =	$f100
     17 U0000 ????	       f1 00	   CBSRAM_KERNEL_READ_ID =	CBSRAM_KERNEL_READ
     18 U0000 ????	       f1 04	   CBSRAM_KERNEL_ENTRY =	[CBSRAM_KERNEL_READ + 4]
     19 U0000 ????	       f1 40	   CBSRAM_KERNEL_READ_END =	[CBSRAM_KERNEL_READ + $40]
     20 U0000 ????
     21 U0000 ????	       f0 40	   RAMP_STORAGE_W =	$f040	; is this just max(frame_1_end, frame_2_end) ?
     22 U0000 ????	       f1 40	   RAMP_STORAGE_R =	$f140
     23 U0000 ????
     24 U0000 ????	       f0 80	   CBSRAM_NIBBLE_WRITE =	$f080
     25 U0000 ????	       f1 80	   CBSRAM_NIBBLE_READ =	$f180
     26 U0000 ????
     27 U0000 ????
     28 U0000 ????						; NUSIZ values
     29 U0000 ????
     30 U0000 ????	       00 13	   THREE_COPIES =	%00010011
     31 U0000 ????
     32 U0000 ????
     33 U0000 ????						; Colors
     34 U0000 ????
     35 U0000 ????	       00 42	   COL_BG     =	$42
     36 U0000 ????	       00 cc	   COL_EMERALD =	$CC
     37 U0000 ????	       00 cc	   COL_EMERALD_2 =	$CC
     38 U0000 ????
     39 U0000 ????
     40 U0000 ????						; HMOVE values for missiles
     41 U0000 ????
     42 U0000 ????	       00 1c	   KERNEL_A_MISSILE_SLEEP =	28
     43 U0000 ????	       00 00	   KERNEL_A_MISSILE_HMOVE =	$00
     44 U0000 ????
     45 U0000 ????	       00 33	   KERNEL_B_MISSILE_SLEEP =	51
     46 U0000 ????	       00 10	   KERNEL_B_MISSILE_HMOVE =	$10
     47 U0000 ????
     48 U0000 ????						; Missile values when 2A=RST
     49 U0000 ????						; KERNEL_B_MISSILE_SLEEP equ 46
     50 U0000 ????						; KERNEL_B_MISSILE_HMOVE equ $20
     51 U0000 ????
     52 U0000 ????
     53 U0000 ????						; Sprite details
     54 U0000 ????
     55 U0000 ????	       00 07	   EMERALD_SP_COLOR =	COLUP1
     56 U0000 ????	       00 1c	   EMERALD_SP =	GRP1
     57 U0000 ????	       00 1e	   EMERALD_MI_ENABLE =	ENAM1
     58 U0000 ????	       00 11	   EMERALD_SP_RESET =	RESP1
     59 U0000 ????	       00 13	   EMERALD_MI_RESET =	RESM1
     60 U0000 ????	       00 21	   EMERALD_SP_HMOVE =	HMP1
     61 U0000 ????	       00 23	   EMERALD_MI_HMOVE =	HMM1
     62 U0000 ????	       00 05	   EMERALD_COPIES =	NUSIZ1
     63 U0000 ????
     64 U0000 ????	       00 1b	   JET_SP     =	GRP0
     65 U0000 ????	       00 10	   JET_SP_RESET =	RESP0
     66 U0000 ????	       00 20	   JET_SP_HMOVE =	HMP0
     67 U0000 ????	       00 06	   JET_SP_COLOR =	COLUP0
     68 U0000 ????
     69 U0000 ????
     70 U0000 ????						; Game dimensionsn
     71 U0000 ????
     72 U0000 ????						; Spriteend is HEIGHT_OFFSET - YPos
     73 U0000 ????	       00 08	   SPRITE_HEIGHT =	8
     74 U0000 ????	       00 c8	   HEIGHT_OFFSET =	200
     75 U0000 ????
     76 U0000 ????						; Compared with YPos
     77 U0000 ????	       00 48	   FLOOR_OFFSET =	72
     78 U0000 ????	       00 c0	   CEILING_OFFSET =	192
     79 U0000 ????
     80 U0000 ????						; Starting player position
     81 U0000 ????	       00 48	   YPosStart  =	72
     82 U0000 ????	       00 58	   XPosStart  =	88
     83 U0000 ????
     84 U0000 ????						; Top left corner
     85 U0000 ????						; YPosStart equ 190
     86 U0000 ????						; XPosStart equ 28
------- FILE main.s
------- FILE game_vars.s LEVEL 2 PASS 2
      0 U0000 ????				      include	"game_vars.s"
      1 U00f6 ????				      seg.u	Variables
      2 U00f6 ????
      3 U0080					      org	$80
      4 U0080
      5 U0080		       00	   DebugKernelID byte.b		; which kernel are we running this frame? (for debugging)
      6 U0081
      7 U0081		       00 00 00 00*coolest_level ds	$3f
      8 U00c0
      9 U00c0					      align	16
     10 U00c0
     11 U00c0		       00 c0	   NIBBLE_VAR_START =	.
     12 U00c0
     13 U00c0							; Nibble Variables
     14 U00c0		       00	   NibbleVar1 byte.b
     15 U00c1		       00	   NibbleVar2 byte.b
     16 U00c2		       00	   NibbleGemini1 byte.b
     17 U00c3		       00	   NibbleGemini1Reg byte.b
     18 U00c4		       00	   NibbleGemini2 byte.b
     19 U00c5		       00	   NibbleGemini2Reg byte.b
     20 U00c6		       00	   NibbleGemini3 byte.b
     21 U00c7		       00	   NibbleGemini3Reg byte.b
     22 U00c8		       00	   NibbleGemini4 byte.b
     23 U00c9		       00	   NibbleMissile byte.b
     24 U00ca		       00	   NibbleVdel1 byte.b
     25 U00cb		       00	   NibbleGrp0 byte.b
     26 U00cc		       00	   NibbleX    byte.b
     27 U00cd		       00	   NibbleY    byte.b
     28 U00ce		       00	   NibblePhp  byte.b
     29 U00cf		       00	   NibblePs   byte.b
     30 U00d0
     31 U00d0		       00 d0	   NIBBLE_VAR_END =	.
     32 U00d0		       00 10	   NIBBLE_VAR_COUNT =	NIBBLE_VAR_END - NIBBLE_VAR_START
     33 U00d0
     34 U00d0					      align	16
     35 U00d0
     36 U00d0							; Misc Nibble support
     37 U00d0		       00	   RamKernelGrp0 byte.b
     38 U00d1		       00	   BuildKernelRST byte.b
     39 U00d2
     40 U00d2		       00	   Temp       byte.b
     41 U00d3		       00	   Temp2      byte.b
     42 U00d4
     43 U00d4							; Counters
     44 U00d4		       00	   LoopCount  byte.b
     45 U00d5		       00	   FrameCount byte.b
     46 U00d6
     47 U00d6		       00	   SpriteEnd  byte.b
     48 U00d7		       00	   XPos       byte.b		; X position of player sprite
     49 U00d8
     50 U00d8
     51 U00d8		       00	   Speed1     byte.b
     52 U00d9		       00	   Speed2     byte.b
     53 U00da
     54 U00da		       00	   YPos       byte.b		; Y position of player sprite
     55 U00db		       00	   YPos2      byte.b
     56 U00dc
     57 U00dc		       00	   ROW_DEMO_INDEX byte.b
     58 U00dd
     59 U00dd		       00	   RamNibbleTemp byte.b
     60 U00de		       00	   RamZeroByte byte.b
     61 U00df		       00	   RamLowerSixByte byte.b
     62 U00e0		       00	   RamFFByte  byte.b
     63 U00e1		       00	   RamStackBkp byte.b
     64 U00e2		       00	   RamPF1Value byte.b
     65 U00e3
     66 U00e3		       00	   RamRowJetpackIndex byte.b		; sprite counter
     67 U00e4
     68 U00e4		       00	   level_for_game byte.b
     69 U00e5		       00		      byte.b
     70 U00e6		       00		      byte.b
     71 U00e7		       00		      byte.b
     72 U00e8
     73 U00e8		       00	   DO_MISS_A  byte.b
     74 U00e9		       00	   DO_MISS_B  byte.b
     75 U00ea		       00	   DO_GEMS_A  byte.b
     76 U00eb		       00		      byte.b
     77 U00ec		       00		      byte.b
     78 U00ed		       00		      byte.b
     79 U00ee		       00		      byte.b
     80 U00ef		       00		      byte.b
     81 U00f0		       00	   DO_GEMS_B  byte.b
     82 U00f1		       00		      byte.b
     83 U00f2		       00		      byte.b
     84 U00f3		       00		      byte.b
     85 U00f4		       00		      byte.b
     86 U00f5		       00		      byte.b
------- FILE main.s
     70 U00f6
     71 U00f6							; Bank 1
     72  e000 ????				      seg	CodeBank1
     73  d000					      org	$D000
     74  d000					      rorg	$F000
     75  d000		       00	   BANK1      byte.b
     76  d200					      org	$d200
     77  d200					      rorg	$d200
     78  d200				   Bank1Start
     79  d200		       ad fa ff 	      lda	$fffa
     80  d203		       ea		      nop
     81  d204		       ea		      nop
     82  d205		       ea		      nop
     83  d206
     84  dffc					      org	$dffc
     85  dffc					      rorg	$fffc
     86  dffc		       00 d2		      .word.w	Bank1Start
     87  dffe		       00 d2		      .word.w	Bank1Start
     88  e000
     89  e000							; Bank 2
     90  f000 ????				      seg	CodeBank2
     91  e000					      org	$E000
     92  e000					      rorg	$F000
     93  e000		       00	   BANK2      byte.b
     94  e200					      org	$e200
     95  e200					      rorg	$f200
     96  e200				   Bank2Start
     97  e200		       ad fa ff 	      lda	$fffa
     98  e203		       ea		      nop
     99  e204		       ea		      nop
    100  e205		       ea		      nop
    101  e206
    102  effc					      org	$effc
    103  effc					      rorg	$fffc
    104  effc		       00 f2		      .word.w	Bank2Start
    105  effe		       00 f2		      .word.w	Bank2Start
    106  f000
    107  f000							; Bank 3
    108  10000 ????				       seg	CodeBank3
    109  f000					      org	$F000
    110  f000					      rorg	$F000
    111  f000		       00	   BANK3      byte.b
    112  f200					      org	$f200
    113  f200					      rorg	$f200
    114  f200				   Bank3Start
    115  f200		       ad fa ff 	      lda	$fffa
    116  f203		       ea		      nop
    117  f204		       ea		      nop
    118  f205		       ea		      nop
    119  f206		       4c 09 f2 	      jmp	Start
    120  f209
    121  f209							; Bank 3 source code
------- FILE game_init.s LEVEL 2 PASS 2
      0  f209					      include	"game_init.s"
      1  f209							; Game Initialization after power on or reset
      2  f209
      3  f209				   IFTRACKER  SET	1
      4  f209
      5  f209				   IFTRACKER  SET	2
      6  f209
      7  f209				   Start
      0  f209					      CLEAN_START
      1  f209		       78		      sei
      2  f20a		       d8		      cld
      3  f20b
      4  f20b		       a2 00		      ldx	#0
      5  f20d		       8a		      txa
      6  f20e		       a8		      tay
      7  f20f		       ca	   .CLEAR_STACK dex
      8  f210		       9a		      txs
      9  f211		       48		      pha
     10  f212		       d0 fb		      bne	.CLEAR_STACK
     11  f214
      9  f214
     10  f214							; Disable interrupt flag in processor status (it's useless anyway)
     11  f214		       58		      cli
     12  f215
     13  f215				   InitSetup
     14  f215		       a9 00		      lda	#0
     15  f217		       85 d5		      sta	FrameCount
     16  f219
     17  f219							; P0 has three copies
     18  f219		       a9 13		      lda	#%00010011
     19  f21b		       85 05		      sta	EMERALD_COPIES
     20  f21d
     21  f21d		       a9 00		      lda	#$00
     22  f21f		       85 09		      sta	COLUBK
     23  f221		       a9 01		      lda	#%00000001
     24  f223		       85 0a		      sta	CTRLPF	; reflect playfield
     25  f225
     26  f225							; Disable VDEL
     27  f225		       a9 00		      lda	#0
     28  f227		       85 25		      sta	VDELP0
     29  f229		       85 26		      sta	VDELP1
     30  f22b
     31  f22b							; Player 0
     32  f22b		       a2 cc		      ldx	#COL_EMERALD
     33  f22d		       86 07		      stx	EMERALD_SP_COLOR
     34  f22f
     35  f22f							; Player 1
     36  f22f		       a9 0f		      lda	#$0f
     37  f231		       85 06		      sta	JET_SP_COLOR
     38  f233		       a9 00		      lda	#$00
     39  f235		       85 1b		      sta	JET_SP
     40  f237
     41  f237							; Positions
     42  f237		       a9 48		      lda	#YPosStart
     43  f239		       85 da		      sta	YPos
     44  f23b		       a9 58		      lda	#XPosStart
     45  f23d		       85 d7		      sta	XPos
     46  f23f		       a9 00		      lda	#0
     47  f241		       85 d8		      sta	Speed1
     48  f243		       85 d9		      sta	Speed2
     49  f245		       85 db		      sta	YPos2
     50  f247
     51  f247		       a9 00		      lda	#0
     52  f249		       85 dc		      sta	ROW_DEMO_INDEX
     53  f24b
     54  f24b							; Store 0 into RamZeroByte
     55  f24b		       a9 00		      lda	#0
     56  f24d		       85 de		      sta	RamZeroByte
     57  f24f		       a9 3f		      lda	#%00111111
     58  f251		       85 df		      sta	RamLowerSixByte
     59  f253		       a9 ff		      lda	#$ff
     60  f255		       85 e0		      sta	RamFFByte
     61  f257
     62  f257							; Setup level.
     63  f257		       20 3a fb 	      jsr	game_state_setup
     64  f25a
     65  f25a							; Start with overscan (calculation start of frame)
     66  f25a		       4c 00 f4 	      jmp	Overscan
------- FILE main.s
------- FILE kernel_loader.s LEVEL 2 PASS 2
      0  f25d					      include	"kernel_loader.s"
      1  f25d							; Copies the gem kernels to RAM
      2  f25d
      3  f25d							; Copy Kernel A to CBSRAM
      4  f25d				   LoadKernelA subroutine
      5  f25d		       a0 37		      ldy	#(kernel_1_end - kernel_1_start)-1
      6  f25f				   .loop
      7  f25f		       b9 00 fe 	      lda	kernel_1_start,Y
      8  f262		       99 00 10 	      sta	$1000,Y
      9  f265		       88		      dey
     10  f266		       d0 f7		      bne	.loop
     11  f268		       ad 00 fe 	      lda	kernel_1_start
     12  f26b		       8d 00 10 	      sta	$1000
     13  f26e		       60		      rts
     14  f26f
     15  f26f							; Copy Kernel B to CBSRAM
     16  f26f				   LoadKernelB subroutine
     17  f26f		       a0 37		      ldy	#(kernel_2_end - kernel_2_start)-1
     18  f271				   .loop
     19  f271		       b9 38 fe 	      lda	kernel_2_start,Y
     20  f274		       99 00 10 	      sta	$1000,Y
     21  f277		       88		      dey
     22  f278		       d0 f7		      bne	.loop
     23  f27a		       ad 38 fe 	      lda	kernel_2_start
     24  f27d		       8d 00 10 	      sta	$1000
     25  f280		       60		      rts
------- FILE main.s
------- FILE nibble_build.s LEVEL 2 PASS 2
      0  f281					      include	"nibble_build.s"
      1  f281					      MAC	nibble_gem_kernel_a_1_build
      2  f281					      lda	#0
      3  f281							; NIBBLE_VAR NibbleGemini4
      4  f281							; NIBBLE_VAR NibbleMissile
      5  f281							; NIBBLE_VAR NibbleVdel1
      6  f281					      ldy	#SENTINEL
      7  f281					      sty	BuildKernelRST
      8  f281					      sty	NibbleX
      9  f281					      sty	NibbleY
     10  f281							; Gemini 1A
     11  f281				   .K_1A
     12  f281					      ldy	[DO_GEMS_A + 0]
     13  f281					      jsr	KernelA_GenReset
     14  f281				   .if_1
     15  f281					      bne	.else_1
     16  f281					      sec
     17  f281					      rol
     18  f281							; Special: Encoding RST0
     19  f281							; Rewrite lda RamKernelPF1 to be #immediate
     20  f281					      ldy	#BC_LDA_IMM
     21  f281					      sty	[KernelA_B - $100]
     22  f281					      ldy	#%10100000
     23  f281					      sty	[KernelA_B - $100 + 1]
     24  f281							; Store 1A in GRP0
     25  f281					      ldy	[DO_GEMS_A + 1]
     26  f281					      sty	NibbleGrp0
     27  f281					      sty	RamKernelGrp0
     28  f281							; Gemini 1A is RESPx
     29  f281					      ldy	#EMERALD_SP_RESET
     30  f281					      sty	[KernelA_C - $100 + 1]
     31  f281							; Turn 3-cycle NOP into 4-cycle
     32  f281					      ldy	#$14
     33  f281					      sty	[KernelA_D - $100]
     34  f281					      rol
     35  f281					      jmp	.endif_1
     36  f281							; [BIT DEPTH] #1 If-End @ 1
     37  f281				   .else_1
     38  f281					      clc
     39  f281					      rol
     40  f281							; Store 0A in GRP0
     41  f281					      ldy	[DO_GEMS_A + 0]
     42  f281					      sty	NibbleGrp0
     43  f281					      sty	RamKernelGrp0
     44  f281					      ldy	[DO_GEMS_A + 1]
     45  f281					      jsr	KernelA_GenReset
     46  f281				   .if_2
     47  f281					      bne	.else_2
     48  f281					      sec
     49  f281					      rol
     50  f281							; GEM1ASWITCH
     51  f281					      jmp	.endif_2
     52  f281							; [BIT DEPTH] #2 If-End @ 2
     53  f281				   .else_2
     54  f281					      clc
     55  f281					      rol
     56  f281							; Calculate the 1A value
     57  f281					      ldy	SHARD_LUT_RF1
     58  f281					      cpy	#1
     59  f281					      .byte	$D0, #3
     60  f281					      ldy	#RESP1
     61  f281					      .byte	$2C
     62  f281					      ldy	#GRP1
     63  f281					      sty	NibbleGemini1Reg
     64  f281							; Set opcode
     65  f281					      ldx	SHARD_LUT_RF1
     66  f281					      cpx	#1
     67  f281					      ldy	#BC_STX
     68  f281					      .byte	$F0, #5
     69  f281					      ldy	[DO_GEMS_A + 1]
     70  f281					      jsr	KernelA_UpdateRegs
     71  f281					      sty	NibbleGemini1
     72  f281							; [BIT DEPTH] #2 *If-End @ 2
     73  f281							; [BIT DEPTH] #2 Else-End @ 2
     74  f281				   .endif_2
     75  f281							; [BIT DEPTH] #1 *If-End @ 1
     76  f281							; [BIT DEPTH] #2 Else-End @ 2
     77  f281				   .endif_1
     78  f281							; Stop preserving GRP0
     79  f281					      ldy	#SENTINEL
     80  f281					      sty	RamKernelGrp0
     81  f281							; NibbleX, NibbleY are upgraded if not set
     82  f281							; Gemini 2A
     83  f281				   .K_2A
     84  f281					      ldy	[DO_GEMS_A + 2]
     85  f281					      jsr	KernelA_GenReset
     86  f281				   .if_3
     87  f281					      bne	.else_3
     88  f281					      sec
     89  f281					      rol
     90  f281					      jmp	.endif_3
     91  f281							; [BIT DEPTH] #3 If-End @ 3
     92  f281				   .else_3
     93  f281					      clc
     94  f281					      rol
     95  f281							; Set opcode
     96  f281					      ldy	[DO_GEMS_A + 2]
     97  f281					      jsr	KernelA_UpdateRegs
     98  f281					      sty	NibbleGemini2
     99  f281							; Set opcode target
    100  f281					      ldy	SHARD_LUT_RF1
    101  f281					      cpy	#2
    102  f281					      .byte	$D0, #3
    103  f281					      ldy	#RESP1
    104  f281					      .byte	$2C
    105  f281					      ldy	#GRP1
    106  f281					      sty	NibbleGemini2Reg
    107  f281							; [BIT DEPTH] #3 *If-End @ 3
    108  f281							; [BIT DEPTH] #3 Else-End @ 3
    109  f281				   .endif_3
    110  f281							; Gemini 3A
    111  f281				   .K_3A
    112  f281					      ldy	[DO_GEMS_A + 3]
    113  f281					      jsr	KernelA_GenReset
    114  f281				   .if_4
    115  f281					      bne	.else_4
    116  f281					      sec
    117  f281					      rol
    118  f281					      jmp	.endif_4
    119  f281							; [BIT DEPTH] #4 If-End @ 4
    120  f281				   .else_4
    121  f281					      clc
    122  f281					      rol
    123  f281							; Set opcode
    124  f281					      ldy	[DO_GEMS_A + 3]
    125  f281					      jsr	KernelA_UpdateRegs
    126  f281					      sty	NibbleGemini3
    127  f281							; Set opcode target
    128  f281					      ldy	SHARD_LUT_RF1
    129  f281					      cpy	#3
    130  f281					      .byte	$D0, #3
    131  f281					      ldy	#RESP1
    132  f281					      .byte	$2C
    133  f281					      ldy	#GRP1
    134  f281					      sty	NibbleGemini3Reg
    135  f281							; [BIT DEPTH] #4 *If-End @ 4
    136  f281							; [BIT DEPTH] #4 Else-End @ 4
    137  f281				   .endif_4
    138  f281							; [BIT DEPTH] Final: 4 (out of 8 bits)
    139  f281					      rol
    140  f281					      rol
    141  f281					      rol
    142  f281					      rol
    143  f281					      ENDM
    144  f281
    145  f281
    146  f281
    147  f281
    148  f281					      MAC	nibble_gem_kernel_a_2_build
    149  f281					      lda	#0
    150  f281							; NIBBLE_VAR NibbleGemini1
    151  f281							; NIBBLE_VAR NibbleGemini1Reg
    152  f281							; NIBBLE_VAR NibbleGemini2
    153  f281							; NIBBLE_VAR NibbleGemini2Reg
    154  f281							; NIBBLE_VAR NibbleGemini3
    155  f281							; NIBBLE_VAR NibbleGemini3Reg
    156  f281							; VD1 default
    157  f281					      ldy	[DO_GEMS_A + 1]
    158  f281					      sty	NibbleVdel1
    159  f281							; Gemini 4A
    160  f281					      ldx	SHARD_LUT_VD1
    161  f281					      cpx	#4
    162  f281				   .if_1
    163  f281					      beq	.else_1
    164  f281					      sec
    165  f281					      rol
    166  f281							; Set PHP
    167  f281					      ldy	#VDELP1
    168  f281					      sty	NibblePhp
    169  f281							; Update VDEL1
    170  f281					      ldy	[DO_GEMS_A + 4]
    171  f281					      sty	NibbleVdel1
    172  f281					      jmp	.endif_1
    173  f281							; [BIT DEPTH] #1 If-End @ 1
    174  f281				   .else_1
    175  f281					      clc
    176  f281					      rol
    177  f281					      ldy	[DO_GEMS_A + 4]
    178  f281					      jsr	KernelA_UpdateRegs
    179  f281					      sty	NibbleGemini4
    180  f281							; Set PHP
    181  f281					      ldy	#RESP1
    182  f281					      sty	NibblePhp
    183  f281							; [BIT DEPTH] #1 *If-End @ 1
    184  f281							; [BIT DEPTH] #1 Else-End @ 1
    185  f281				   .endif_1
    186  f281							; Gemini 5A
    187  f281							; TODO eventually...?
    188  f281							; Missile
    189  f281					      ldy	DO_MISS_A
    190  f281							; FIXME Why doesn't this branch compile?
    191  f281							; bne .+4
    192  f281							; ldx #BC_NOP
    193  f281							; stx NibbleMissile
    194  f281							; VD1
    195  f281							; GRP0
    196  f281							; [BIT DEPTH] Final: 1 (out of 8 bits)
    197  f281					      rol
    198  f281					      rol
    199  f281					      rol
    200  f281					      rol
    201  f281					      rol
    202  f281					      rol
    203  f281					      rol
    204  f281					      ENDM
    205  f281
    206  f281
    207  f281
    208  f281
    209  f281					      MAC	nibble_gem_kernel_b_1_build
    210  f281					      lda	#0
    211  f281							; NIBBLE_VAR NibbleGemini1
    212  f281							; NIBBLE_VAR NibbleGemini1Reg
    213  f281							; NIBBLE_VAR NibbleGemini2Reg
    214  f281							; NIBBLE_VAR NibbleGemini3Reg
    215  f281							; NIBBLE_VAR NibbleGemini4
    216  f281							; NIBBLE_VAR NibbleMissile
    217  f281							; NIBBLE_VAR NibbleVdel1
    218  f281					      ldx	#SENTINEL
    219  f281					      stx	NibbleX
    220  f281					      stx	NibbleY
    221  f281					      stx	BuildKernelRST
    222  f281							; Php target default
    223  f281					      ldy	#RESP1
    224  f281					      sty	NibblePhp
    225  f281							; Gemini 0B
    226  f281					      ldy	[DO_GEMS_B + 0]
    227  f281					      sty	NibbleGrp0
    228  f281					      sty	RamKernelGrp0
    229  f281							; NIBBLE_WRITE_IMM KernelB_D_W, RamKernelGemini0
    230  f281							; Gemini 1B
    231  f281					      ldy	[DO_GEMS_B + 1]
    232  f281					      jsr	KernelA_UpdateRegs
    233  f281					      sty	NibbleGemini1
    234  f281							; Gemini 2B
    235  f281					      ldy	[DO_GEMS_B + 2]
    236  f281					      jsr	KernelB_GenPhp
    237  f281				   .if_1
    238  f281					      bne	.else_1
    239  f281					      sec
    240  f281					      rol
    241  f281					      CALC_REGS_AND_STORE	3, NibbleGemini3
    242  f281							; Write to PHP in 2B
    243  f281					      ldx	#EMERALD_SP
    244  f281					      stx	NibblePhp
    245  f281							; Update Grp0
    246  f281					      ldy	BuildKernelRST
    247  f281					      sty	RamKernelGrp0
    248  f281					      rol
    249  f281					      jmp	.endif_1
    250  f281							; [BIT DEPTH] #1 If-End @ 1
    251  f281				   .else_1
    252  f281					      clc
    253  f281					      rol
    254  f281							; Gemini 3B
    255  f281					      ldy	[DO_GEMS_B + 3]
    256  f281					      jsr	KernelB_GenPhp
    257  f281				   .if_2
    258  f281					      bne	.else_2
    259  f281					      sec
    260  f281					      rol
    261  f281							; Write to PHP in 3B
    262  f281					      CALC_REGS_AND_STORE	2, NibbleGemini2
    263  f281					      ldx	#EMERALD_SP
    264  f281					      stx	NibblePhp
    265  f281
    266  f281							; Update Grp0
    267  f281					      ldy	BuildKernelRST
    268  f281					      sty	RamKernelGrp0
    269  f281					      jmp	.endif_2
    270  f281							; [BIT DEPTH] #2 If-End @ 2
    271  f281				   .else_2
    272  f281					      clc
    273  f281					      rol
    274  f281							; Update 2B
    275  f281					      CALC_REGS_AND_STORE	2, NibbleGemini2
    276  f281							; Update 3B
    277  f281					      CALC_REGS_AND_STORE	3, NibbleGemini3
    278  f281							; [BIT DEPTH] #2 *If-End @ 2
    279  f281							; [BIT DEPTH] #2 Else-End @ 2
    280  f281				   .endif_2
    281  f281							; [BIT DEPTH] #1 *If-End @ 1
    282  f281							; [BIT DEPTH] #2 Else-End @ 2
    283  f281				   .endif_1
    284  f281							; [BIT DEPTH] Final: 2 (out of 8 bits)
    285  f281					      rol
    286  f281					      rol
    287  f281					      rol
    288  f281					      rol
    289  f281					      rol
    290  f281					      rol
    291  f281					      ENDM
    292  f281
    293  f281
    294  f281
    295  f281
    296  f281					      MAC	nibble_gem_kernel_b_2_build
    297  f281					      lda	#0
    298  f281							; NIBBLE_VAR NibbleGemini1
    299  f281							; NIBBLE_VAR NibbleGemini1Reg
    300  f281							; NIBBLE_VAR NibbleGemini2
    301  f281							; NIBBLE_VAR NibbleGemini2Reg
    302  f281							; NIBBLE_VAR NibbleGemini3
    303  f281							; NIBBLE_VAR NibbleGemini3Reg
    304  f281							; NIBBLE_VAR NibbleMissile
    305  f281							; NIBBLE_VAR NibbleVdel1
    306  f281							; Gemini 1B
    307  f281							; Write out PHP flag comparison
    308  f281					      ldy	BuildKernelRST
    309  f281					      cpy	#G01
    310  f281				   .if_1
    311  f281					      bne	.else_1
    312  f281					      sec
    313  f281					      rol
    314  f281					      jmp	.endif_1
    315  f281							; [BIT DEPTH] #1 If-End @ 1
    316  f281				   .else_1
    317  f281					      clc
    318  f281					      rol
    319  f281							; [BIT DEPTH] #1 *If-End @ 1
    320  f281							; [BIT DEPTH] #1 Else-End @ 1
    321  f281				   .endif_1
    322  f281							; Missile
    323  f281							; ldy DO_MISS_B
    324  f281							; NIBBLE_IF eq
    325  f281							; NIBBLE_WRITE_IMM [KernelB_K - $100], #BC_STA
    326  f281							; NIBBLE_ELSE
    327  f281							;     NIBBLE_WRITE_IMM [KernelB_K - $100], NibbleMissile
    328  f281							; NIBBLE_END_IF
    329  f281							; Gemini 4B
    330  f281					      ldy	[DO_GEMS_B + 4]
    331  f281					      jsr	KernelA_UpdateRegs
    332  f281					      sty	NibbleGemini4
    333  f281							; TODO if no PHP, rewrite previous section:
    334  f281							; NIBBLE_IF cs
    335  f281							;
    336  f281							;     NIBBLE_WRITE_IMM [KernelB_E_W + 0], #BC_PHP
    337  f281							;     NIBBLE_WRITE_IMM [KernelB_F_W + 0], #BC_STY, #EMERALD_SP
    338  f281							;     NIBBLE_WRITE_IMM [KernelB_G_W + 0], #BC_STA, #PF1
    339  f281							;     NIBBLE_WRITE_IMM [KernelB_H_W + 0], #BC_STY, #EMERALD_SP
    340  f281							; NIBBLE_END_IF
    341  f281							; Make adjustments for sprites.
    342  f281					      ror	NibbleGrp0
    343  f281					      ror	NibbleX
    344  f281					      ror	NibbleY
    345  f281							;
    346  f281							; NIBBLE_WRITE_IMM [KernelB_VDEL1 - $100], NibbleVdel1
    347  f281							; GRP0
    348  f281							; [BIT DEPTH] Final: 1 (out of 8 bits)
    349  f281					      rol
    350  f281					      rol
    351  f281					      rol
    352  f281					      rol
    353  f281					      rol
    354  f281					      rol
    355  f281					      rol
    356  f281					      ENDM
    357  f281
    358  f281
    359  f281
    360  f281
------- FILE main.s
------- FILE nibble_eval.s LEVEL 2 PASS 2
      0  f281					      include	"nibble_eval.s"
      1  f281					      MAC	nibble_gem_kernel_a_1
      2  f281					      asl
      3  f281					      bcc	.else_1
      4  f281							; parent: BuildState { index: 0, checkdepth: 0, cycles: 4 }
      5  f281				   .if_1
      6  f281					      rol
      7  f281					      sleep	18
      8  f281							; then: BuildState { index: 1, checkdepth: 1, cycles: 26 }
      9  f281
     10  f281					      jmp	.endif_1
     11  f281				   .else_1
     12  f281					      asl
     13  f281					      bcc	.else_2
     14  f281							; parent: BuildState { index: 1, checkdepth: 1, cycles: 9 }
     15  f281				   .if_2
     16  f281					      ldx	#[ #BC_STX ]
     17  f281					      stx	[[KernelA_D_W + 0] + 0]
     18  f281					      ldx	#[ #RESP1 ]
     19  f281					      stx	[[KernelA_D_W + 1] + 0]
     20  f281					      sleep	3
     21  f281							; then: BuildState { index: 2, checkdepth: 2, cycles: 26 }
     22  f281
     23  f281					      jmp	.endif_2
     24  f281				   .else_2
     25  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini1 - NIBBLE_VAR_START],y
     26  f281					      stx	[[KernelA_D_W + 0] + 0]
     27  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini1Reg - NIBBLE_VAR_START],y
     28  f281					      stx	[[KernelA_D_W + 1] + 0]
     29  f281							; else: BuildState { index: 2, checkdepth: 2, cycles: 26 }
     30  f281				   .endif_2
     31  f281							; else: BuildState { index: 2, checkdepth: 2, cycles: 26 }
     32  f281				   .endif_1
     33  f281					      asl
     34  f281					      bcc	.else_3
     35  f281							; parent: BuildState { index: 2, checkdepth: 2, cycles: 30 }
     36  f281				   .if_3
     37  f281					      ldx	#[ #NOP_REG ]
     38  f281					      stx	[[KernelA_E_W + 1] + 0]
     39  f281					      ldx	#[ #RESP1 ]
     40  f281					      stx	[[KernelA_G_W + 1] + 0]
     41  f281					      sleep	9
     42  f281							; then: BuildState { index: 3, checkdepth: 3, cycles: 53 }
     43  f281
     44  f281					      jmp	.endif_3
     45  f281				   .else_3
     46  f281					      ldx	#[ #RESP1 ]
     47  f281					      stx	[[KernelA_E_W + 1] + 0]
     48  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
     49  f281					      stx	[[KernelA_G_W + 0] + 0]
     50  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2Reg - NIBBLE_VAR_START],y
     51  f281					      stx	[[KernelA_G_W + 1] + 0]
     52  f281							; else: BuildState { index: 3, checkdepth: 3, cycles: 53 }
     53  f281				   .endif_3
     54  f281					      asl
     55  f281					      bcc	.else_4
     56  f281							; parent: BuildState { index: 3, checkdepth: 3, cycles: 57 }
     57  f281				   .if_4
     58  f281					      ldx	#[ #RESP1 ]
     59  f281					      stx	[[KernelA_H_W + 1] + 0]
     60  f281					      sleep	9
     61  f281							; then: BuildState { index: 4, checkdepth: 4, cycles: 74 }
     62  f281
     63  f281					      jmp	.endif_4
     64  f281				   .else_4
     65  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
     66  f281					      stx	[[KernelA_H_W + 0] + 0]
     67  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3Reg - NIBBLE_VAR_START],y
     68  f281					      stx	[[KernelA_H_W + 1] + 0]
     69  f281							; else: BuildState { index: 4, checkdepth: 4, cycles: 74 }
     70  f281				   .endif_4
     71  f281					      ENDM
     72  f281
     73  f281
     74  f281
     75  f281
     76  f281					      MAC	nibble_gem_kernel_a_2
     77  f281					      asl
     78  f281					      bcc	.else_1
     79  f281							; parent: BuildState { index: 0, checkdepth: 0, cycles: 4 }
     80  f281				   .if_1
     81  f281					      ldx	#[ #BC_STA ]
     82  f281					      stx	[[KernelA_I_W + 0] + 0]
     83  f281					      ldx	#[ #EMERALD_SP_RESET ]
     84  f281					      stx	[[KernelA_I_W + 0] + 1]
     85  f281					      ldx	#[ #BC_STA ]
     86  f281					      stx	[[KernelA_J_W + 1] + 0]
     87  f281					      ldx	#[ #PF1 ]
     88  f281					      stx	[[KernelA_J_W + 1] + 1]
     89  f281					      ldx	#[ #BC_PHP ]
     90  f281					      stx	[[KernelA_K_W + 1] + 0]
     91  f281					      sleep	3
     92  f281							; then: BuildState { index: 1, checkdepth: 1, cycles: 39 }
     93  f281
     94  f281					      jmp	.endif_1
     95  f281				   .else_1
     96  f281					      ldx	#[ #BC_PHP ]
     97  f281					      stx	[[KernelA_I_W + 0] + 0]
     98  f281					      ldx	#[ #BC_STA ]
     99  f281					      stx	[[KernelA_J_W + 0] + 0]
    100  f281					      ldx	#[ #PF1 ]
    101  f281					      stx	[[KernelA_J_W + 0] + 1]
    102  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini4 - NIBBLE_VAR_START],y
    103  f281					      stx	[[KernelA_K_W + 0] + 0]
    104  f281					      ldx	#[ #EMERALD_SP ]
    105  f281					      stx	[[KernelA_K_W + 1] + 0]
    106  f281					      sleep	2
    107  f281							; else: BuildState { index: 1, checkdepth: 1, cycles: 39 }
    108  f281				   .endif_1
    109  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleMissile - NIBBLE_VAR_START],y
    110  f281					      stx	[[KernelA_F - $100] + 0]
    111  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleVdel1 - NIBBLE_VAR_START],y
    112  f281					      stx	[[KernelA_VDEL1 - $100] + 0]
    113  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGrp0 - NIBBLE_VAR_START],y
    114  f281					      stx	[[KernelA_VDEL0 - $100] + 0]
    115  f281					      ldx	#[ #$ff ]
    116  f281					      stx	[NibblePs + 0]
    117  f281					      ENDM
    118  f281
    119  f281
    120  f281
    121  f281
    122  f281					      MAC	nibble_gem_kernel_b_1
    123  f281					      asl
    124  f281					      bcc	.else_1
    125  f281							; parent: BuildState { index: 0, checkdepth: 0, cycles: 4 }
    126  f281				   .if_1
    127  f281					      ldx	#[ #BC_STY ]
    128  f281					      stx	[[KernelB_E_W + 0] + 0]
    129  f281					      ldx	#[ #EMERALD_SP_RESET ]
    130  f281					      stx	[[KernelB_E_W + 1] + 0]
    131  f281					      ldx	#[ #BC_PHP ]
    132  f281					      stx	[[KernelB_F_W + 1] + 0]
    133  f281					      ldx	#[ #BC_STA ]
    134  f281					      stx	[[KernelB_G_W + 0] + 0]
    135  f281					      ldx	#[ #PF1 ]
    136  f281					      stx	[[KernelB_G_W + 1] + 0]
    137  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
    138  f281					      stx	[[KernelB_H_W + 0] + 0]
    139  f281					      ldx	#[ #EMERALD_SP ]
    140  f281					      stx	[[KernelB_H_W + 1] + 0]
    141  f281					      rol
    142  f281					      sleep	3
    143  f281							; then: BuildState { index: 1, checkdepth: 1, cycles: 55 }
    144  f281
    145  f281					      jmp	.endif_1
    146  f281				   .else_1
    147  f281					      asl
    148  f281					      bcc	.else_2
    149  f281							; parent: BuildState { index: 1, checkdepth: 1, cycles: 9 }
    150  f281				   .if_2
    151  f281					      ldx	#[ #BC_STY ]
    152  f281					      stx	[[KernelB_E_W + 0] + 0]
    153  f281					      ldx	#[ #EMERALD_SP_RESET ]
    154  f281					      stx	[[KernelB_E_W + 1] + 0]
    155  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
    156  f281					      stx	[[KernelB_F_W + 1] + 0]
    157  f281					      ldx	#[ #EMERALD_SP ]
    158  f281					      stx	[[KernelB_F_W + 2] + 0]
    159  f281					      ldx	#[ #BC_STA ]
    160  f281					      stx	[[KernelB_G_W + 1] + 0]
    161  f281					      ldx	#[ #PF1 ]
    162  f281					      stx	[[KernelB_G_W + 2] + 0]
    163  f281					      ldx	#[ #BC_PHP ]
    164  f281					      stx	[[KernelB_H_W + 1] + 0]
    165  f281							; then: BuildState { index: 2, checkdepth: 2, cycles: 55 }
    166  f281
    167  f281					      jmp	.endif_2
    168  f281				   .else_2
    169  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
    170  f281					      stx	[[KernelB_F_W + 0] + 0]
    171  f281					      ldx	#[ #EMERALD_SP ]
    172  f281					      stx	[[KernelB_F_W + 1] + 0]
    173  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
    174  f281					      stx	[[KernelB_H_W + 0] + 0]
    175  f281					      ldx	#[ #EMERALD_SP ]
    176  f281					      stx	[[KernelB_H_W + 1] + 0]
    177  f281					      sleep	17
    178  f281							; else: BuildState { index: 2, checkdepth: 2, cycles: 55 }
    179  f281				   .endif_2
    180  f281							; else: BuildState { index: 2, checkdepth: 2, cycles: 55 }
    181  f281				   .endif_1
    182  f281					      ENDM
    183  f281
    184  f281
    185  f281
    186  f281
    187  f281					      MAC	nibble_gem_kernel_b_2
    188  f281					      ldx	#[ NibbleGemini1 ]
    189  f281					      stx	[KernelB_D_W + 0]
    190  f281					      asl
    191  f281					      bcc	.else_1
    192  f281							; parent: BuildState { index: 0, checkdepth: 0, cycles: 10 }
    193  f281				   .if_1
    194  f281					      ldx	#[ #RamFFByte ]
    195  f281					      stx	[[KernelB_C - $100 + 1] + 0]
    196  f281					      sleep	2
    197  f281							; then: BuildState { index: 1, checkdepth: 1, cycles: 20 }
    198  f281
    199  f281					      jmp	.endif_1
    200  f281				   .else_1
    201  f281					      ldx	#[ #RamPF1Value ]
    202  f281					      stx	[[KernelB_C - $100 + 1] + 0]
    203  f281					      sleep	3
    204  f281							; else: BuildState { index: 1, checkdepth: 1, cycles: 20 }
    205  f281				   .endif_1
    206  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini4 - NIBBLE_VAR_START],y
    207  f281					      stx	[KernelB_J_W + 0]
    208  f281					      ldx	[CBSRAM_NIBBLE_READ + NibbleGrp0 - NIBBLE_VAR_START],y
    209  f281					      stx	[[KernelB_VDEL0 - $100] + 0]
    210  f281					      ldx	#[ #$00 ]
    211  f281					      stx	[NibblePs + 0]
    212  f281					      ENDM
    213  f281
    214  f281
    215  f281
    216  f281
------- FILE main.s
------- FILE nibble_shard.s LEVEL 2 PASS 2
      0  f281					      include	"nibble_shard.s"
      1  f281							; conflict: 11011000 #%0011 #%1000
      2  f281							; conflict: 11011001 #%0011 #%1000
      3  f281							; conflict: 11011010 #%0011 #%1000
      4  f281							; conflict: 11011011 #%0011 #%1000
      5  f281							; conflict: 11100100 #%1000 #%0011
      6  f281							; conflict: 11100101 #%1000 #%0011
      7  f281							; conflict: 11100110 #%1000 #%0011
      8  f281							; conflict: 11100111 #%1000 #%0011
      9  f281							; conflict: 01111000 #%1000 #%0001
     10  f281							; conflict: 01111001 #%1000 #%0001
     11  f281							; conflict: 01111010 #%1000 #%0001
     12  f281							; conflict: 01111011 #%1000 #%0001
     13  f281							; conflict: 10110100 #%1000 #%0001
     14  f281							; conflict: 10110101 #%1000 #%0001
     15  f281							; conflict: 10110110 #%1000 #%0001
     16  f281							; conflict: 10110111 #%1000 #%0001
     17  f300		       00 00 00 00*	      align	256
     18  f300		       00	   .shard_0   .byte.b	#0
     19  f301		       00	   .shard_1   .byte.b	#0
     20  f302		       00	   .shard_2   .byte.b	#0
     21  f303		       00	   .shard_3   .byte.b	#0
     22  f304		       00	   .shard_4   .byte.b	#0
     23  f305		       00	   .shard_5   .byte.b	#0
     24  f306		       00	   .shard_6   .byte.b	#0
     25  f307		       00	   .shard_7   .byte.b	#0
     26  f308		       00	   .shard_8   .byte.b	#0
     27  f309		       00	   .shard_9   .byte.b	#0
     28  f30a		       00	   .shard_10  .byte.b	#0
     29  f30b		       00	   .shard_11  .byte.b	#0
     30  f30c		       00	   .shard_12  .byte.b	#0
     31  f30d		       00	   .shard_13  .byte.b	#0
     32  f30e		       00	   .shard_14  .byte.b	#0
     33  f30f		       00	   .shard_15  .byte.b	#0
     34  f310		       00	   .shard_16  .byte.b	#0
     35  f311		       00	   .shard_17  .byte.b	#0
     36  f312		       00	   .shard_18  .byte.b	#0
     37  f313		       00	   .shard_19  .byte.b	#0
     38  f314		       00	   .shard_20  .byte.b	#0
     39  f315		       00	   .shard_21  .byte.b	#0
     40  f316		       00	   .shard_22  .byte.b	#0
     41  f317		       00	   .shard_23  .byte.b	#0
     42  f318		       00	   .shard_24  .byte.b	#0
     43  f319		       00	   .shard_25  .byte.b	#0
     44  f31a		       00	   .shard_26  .byte.b	#0
     45  f31b		       00	   .shard_27  .byte.b	#0
     46  f31c		       00	   .shard_28  .byte.b	#0
     47  f31d		       00	   .shard_29  .byte.b	#0
     48  f31e		       00	   .shard_30  .byte.b	#0
     49  f31f		       00	   .shard_31  .byte.b	#0
     50  f320		       00	   .shard_32  .byte.b	#0
     51  f321		       00	   .shard_33  .byte.b	#0
     52  f322		       00	   .shard_34  .byte.b	#0
     53  f323		       00	   .shard_35  .byte.b	#0
     54  f324		       00	   .shard_36  .byte.b	#0
     55  f325		       00	   .shard_37  .byte.b	#0
     56  f326		       00	   .shard_38  .byte.b	#0
     57  f327		       00	   .shard_39  .byte.b	#0
     58  f328		       00	   .shard_40  .byte.b	#0
     59  f329		       00	   .shard_41  .byte.b	#0
     60  f32a		       00	   .shard_42  .byte.b	#0
     61  f32b		       00	   .shard_43  .byte.b	#0
     62  f32c		       00	   .shard_44  .byte.b	#0
     63  f32d		       00	   .shard_45  .byte.b	#0
     64  f32e		       00	   .shard_46  .byte.b	#0
     65  f32f		       00	   .shard_47  .byte.b	#0
     66  f330		       00	   .shard_48  .byte.b	#0
     67  f331		       00	   .shard_49  .byte.b	#0
     68  f332		       00	   .shard_50  .byte.b	#0
     69  f333		       00	   .shard_51  .byte.b	#0
     70  f334		       00	   .shard_52  .byte.b	#0
     71  f335		       00	   .shard_53  .byte.b	#0
     72  f336		       00	   .shard_54  .byte.b	#0
     73  f337		       00	   .shard_55  .byte.b	#0
     74  f338		       00	   .shard_56  .byte.b	#0
     75  f339		       00	   .shard_57  .byte.b	#0
     76  f33a		       00	   .shard_58  .byte.b	#0
     77  f33b		       00	   .shard_59  .byte.b	#0
     78  f33c		       00	   .shard_60  .byte.b	#0
     79  f33d		       00	   .shard_61  .byte.b	#0
     80  f33e		       00	   .shard_62  .byte.b	#0
     81  f33f		       00	   .shard_63  .byte.b	#0
     82  f340		       00	   .shard_64  .byte.b	#0
     83  f341		       00	   .shard_65  .byte.b	#0
     84  f342		       00	   .shard_66  .byte.b	#0
     85  f343		       00	   .shard_67  .byte.b	#0
     86  f344		       00	   .shard_68  .byte.b	#0
     87  f345		       00	   .shard_69  .byte.b	#0
     88  f346		       00	   .shard_70  .byte.b	#0
     89  f347		       00	   .shard_71  .byte.b	#0
     90  f348		       00	   .shard_72  .byte.b	#0
     91  f349		       00	   .shard_73  .byte.b	#0
     92  f34a		       00	   .shard_74  .byte.b	#0
     93  f34b		       00	   .shard_75  .byte.b	#0
     94  f34c		       00	   .shard_76  .byte.b	#0
     95  f34d		       00	   .shard_77  .byte.b	#0
     96  f34e		       00	   .shard_78  .byte.b	#0
     97  f34f		       00	   .shard_79  .byte.b	#0
     98  f350		       00	   .shard_80  .byte.b	#0
     99  f351		       00	   .shard_81  .byte.b	#0
    100  f352		       00	   .shard_82  .byte.b	#0
    101  f353		       00	   .shard_83  .byte.b	#0
    102  f354		       00	   .shard_84  .byte.b	#0
    103  f355		       00	   .shard_85  .byte.b	#0
    104  f356		       00	   .shard_86  .byte.b	#0
    105  f357		       00	   .shard_87  .byte.b	#0
    106  f358		       00	   .shard_88  .byte.b	#0
    107  f359		       00	   .shard_89  .byte.b	#0
    108  f35a		       00	   .shard_90  .byte.b	#0
    109  f35b		       00	   .shard_91  .byte.b	#0
    110  f35c		       00	   .shard_92  .byte.b	#0
    111  f35d		       00	   .shard_93  .byte.b	#0
    112  f35e		       00	   .shard_94  .byte.b	#0
    113  f35f		       00	   .shard_95  .byte.b	#0
    114  f360		       00	   .shard_96  .byte.b	#0
    115  f361		       00	   .shard_97  .byte.b	#0
    116  f362		       00	   .shard_98  .byte.b	#0
    117  f363		       00	   .shard_99  .byte.b	#0
    118  f364		       00	   .shard_100 .byte.b	#0
    119  f365		       00	   .shard_101 .byte.b	#0
    120  f366		       00	   .shard_102 .byte.b	#0
    121  f367		       00	   .shard_103 .byte.b	#0
    122  f368		       00	   .shard_104 .byte.b	#0
    123  f369		       00	   .shard_105 .byte.b	#0
    124  f36a		       00	   .shard_106 .byte.b	#0
    125  f36b		       00	   .shard_107 .byte.b	#0
    126  f36c		       02	   .shard_108 .byte.b	#%0010
    127  f36d		       02	   .shard_109 .byte.b	#%0010
    128  f36e		       02	   .shard_110 .byte.b	#%0010
    129  f36f		       02	   .shard_111 .byte.b	#%0010
    130  f370		       00	   .shard_112 .byte.b	#0
    131  f371		       00	   .shard_113 .byte.b	#0
    132  f372		       00	   .shard_114 .byte.b	#0
    133  f373		       00	   .shard_115 .byte.b	#0
    134  f374		       00	   .shard_116 .byte.b	#0
    135  f375		       00	   .shard_117 .byte.b	#0
    136  f376		       00	   .shard_118 .byte.b	#0
    137  f377		       00	   .shard_119 .byte.b	#0
    138  f378		       08	   .shard_120 .byte.b	#%1000
    139  f379		       08	   .shard_121 .byte.b	#%1000
    140  f37a		       08	   .shard_122 .byte.b	#%1000
    141  f37b		       08	   .shard_123 .byte.b	#%1000
    142  f37c		       00	   .shard_124 .byte.b	#0
    143  f37d		       00	   .shard_125 .byte.b	#0
    144  f37e		       00	   .shard_126 .byte.b	#0
    145  f37f		       00	   .shard_127 .byte.b	#0
    146  f380		       00	   .shard_128 .byte.b	#0
    147  f381		       00	   .shard_129 .byte.b	#0
    148  f382		       00	   .shard_130 .byte.b	#0
    149  f383		       00	   .shard_131 .byte.b	#0
    150  f384		       00	   .shard_132 .byte.b	#0
    151  f385		       00	   .shard_133 .byte.b	#0
    152  f386		       00	   .shard_134 .byte.b	#0
    153  f387		       00	   .shard_135 .byte.b	#0
    154  f388		       00	   .shard_136 .byte.b	#0
    155  f389		       00	   .shard_137 .byte.b	#0
    156  f38a		       00	   .shard_138 .byte.b	#0
    157  f38b		       00	   .shard_139 .byte.b	#0
    158  f38c		       00	   .shard_140 .byte.b	#0
    159  f38d		       00	   .shard_141 .byte.b	#0
    160  f38e		       00	   .shard_142 .byte.b	#0
    161  f38f		       00	   .shard_143 .byte.b	#0
    162  f390		       00	   .shard_144 .byte.b	#0
    163  f391		       00	   .shard_145 .byte.b	#0
    164  f392		       00	   .shard_146 .byte.b	#0
    165  f393		       00	   .shard_147 .byte.b	#0
    166  f394		       00	   .shard_148 .byte.b	#0
    167  f395		       00	   .shard_149 .byte.b	#0
    168  f396		       00	   .shard_150 .byte.b	#0
    169  f397		       00	   .shard_151 .byte.b	#0
    170  f398		       00	   .shard_152 .byte.b	#0
    171  f399		       00	   .shard_153 .byte.b	#0
    172  f39a		       00	   .shard_154 .byte.b	#0
    173  f39b		       00	   .shard_155 .byte.b	#0
    174  f39c		       02	   .shard_156 .byte.b	#%0010
    175  f39d		       02	   .shard_157 .byte.b	#%0010
    176  f39e		       02	   .shard_158 .byte.b	#%0010
    177  f39f		       02	   .shard_159 .byte.b	#%0010
    178  f3a0		       00	   .shard_160 .byte.b	#0
    179  f3a1		       00	   .shard_161 .byte.b	#0
    180  f3a2		       00	   .shard_162 .byte.b	#0
    181  f3a3		       00	   .shard_163 .byte.b	#0
    182  f3a4		       00	   .shard_164 .byte.b	#0
    183  f3a5		       00	   .shard_165 .byte.b	#0
    184  f3a6		       00	   .shard_166 .byte.b	#0
    185  f3a7		       00	   .shard_167 .byte.b	#0
    186  f3a8		       00	   .shard_168 .byte.b	#0
    187  f3a9		       00	   .shard_169 .byte.b	#0
    188  f3aa		       00	   .shard_170 .byte.b	#0
    189  f3ab		       00	   .shard_171 .byte.b	#0
    190  f3ac		       00	   .shard_172 .byte.b	#0
    191  f3ad		       00	   .shard_173 .byte.b	#0
    192  f3ae		       00	   .shard_174 .byte.b	#0
    193  f3af		       00	   .shard_175 .byte.b	#0
    194  f3b0		       00	   .shard_176 .byte.b	#0
    195  f3b1		       00	   .shard_177 .byte.b	#0
    196  f3b2		       00	   .shard_178 .byte.b	#0
    197  f3b3		       00	   .shard_179 .byte.b	#0
    198  f3b4		       08	   .shard_180 .byte.b	#%1000
    199  f3b5		       08	   .shard_181 .byte.b	#%1000
    200  f3b6		       08	   .shard_182 .byte.b	#%1000
    201  f3b7		       08	   .shard_183 .byte.b	#%1000
    202  f3b8		       00	   .shard_184 .byte.b	#0
    203  f3b9		       00	   .shard_185 .byte.b	#0
    204  f3ba		       00	   .shard_186 .byte.b	#0
    205  f3bb		       00	   .shard_187 .byte.b	#0
    206  f3bc		       00	   .shard_188 .byte.b	#0
    207  f3bd		       00	   .shard_189 .byte.b	#0
    208  f3be		       00	   .shard_190 .byte.b	#0
    209  f3bf		       00	   .shard_191 .byte.b	#0
    210  f3c0		       00	   .shard_192 .byte.b	#0
    211  f3c1		       00	   .shard_193 .byte.b	#0
    212  f3c2		       00	   .shard_194 .byte.b	#0
    213  f3c3		       00	   .shard_195 .byte.b	#0
    214  f3c4		       00	   .shard_196 .byte.b	#0
    215  f3c5		       00	   .shard_197 .byte.b	#0
    216  f3c6		       00	   .shard_198 .byte.b	#0
    217  f3c7		       00	   .shard_199 .byte.b	#0
    218  f3c8		       00	   .shard_200 .byte.b	#0
    219  f3c9		       00	   .shard_201 .byte.b	#0
    220  f3ca		       00	   .shard_202 .byte.b	#0
    221  f3cb		       00	   .shard_203 .byte.b	#0
    222  f3cc		       00	   .shard_204 .byte.b	#0
    223  f3cd		       00	   .shard_205 .byte.b	#0
    224  f3ce		       00	   .shard_206 .byte.b	#0
    225  f3cf		       00	   .shard_207 .byte.b	#0
    226  f3d0		       00	   .shard_208 .byte.b	#0
    227  f3d1		       00	   .shard_209 .byte.b	#0
    228  f3d2		       00	   .shard_210 .byte.b	#0
    229  f3d3		       00	   .shard_211 .byte.b	#0
    230  f3d4		       00	   .shard_212 .byte.b	#0
    231  f3d5		       00	   .shard_213 .byte.b	#0
    232  f3d6		       00	   .shard_214 .byte.b	#0
    233  f3d7		       00	   .shard_215 .byte.b	#0
    234  f3d8		       03	   .shard_216 .byte.b	#%0011
    235  f3d9		       03	   .shard_217 .byte.b	#%0011
    236  f3da		       03	   .shard_218 .byte.b	#%0011
    237  f3db		       03	   .shard_219 .byte.b	#%0011
    238  f3dc		       00	   .shard_220 .byte.b	#0
    239  f3dd		       00	   .shard_221 .byte.b	#0
    240  f3de		       00	   .shard_222 .byte.b	#0
    241  f3df		       00	   .shard_223 .byte.b	#0
    242  f3e0		       00	   .shard_224 .byte.b	#0
    243  f3e1		       00	   .shard_225 .byte.b	#0
    244  f3e2		       00	   .shard_226 .byte.b	#0
    245  f3e3		       00	   .shard_227 .byte.b	#0
    246  f3e4		       08	   .shard_228 .byte.b	#%1000
    247  f3e5		       08	   .shard_229 .byte.b	#%1000
    248  f3e6		       08	   .shard_230 .byte.b	#%1000
    249  f3e7		       08	   .shard_231 .byte.b	#%1000
    250  f3e8		       00	   .shard_232 .byte.b	#0
    251  f3e9		       00	   .shard_233 .byte.b	#0
    252  f3ea		       00	   .shard_234 .byte.b	#0
    253  f3eb		       00	   .shard_235 .byte.b	#0
    254  f3ec		       00	   .shard_236 .byte.b	#0
    255  f3ed		       00	   .shard_237 .byte.b	#0
    256  f3ee		       00	   .shard_238 .byte.b	#0
    257  f3ef		       00	   .shard_239 .byte.b	#0
    258  f3f0		       00	   .shard_240 .byte.b	#0
    259  f3f1		       00	   .shard_241 .byte.b	#0
    260  f3f2		       00	   .shard_242 .byte.b	#0
    261  f3f3		       00	   .shard_243 .byte.b	#0
    262  f3f4		       00	   .shard_244 .byte.b	#0
    263  f3f5		       00	   .shard_245 .byte.b	#0
    264  f3f6		       00	   .shard_246 .byte.b	#0
    265  f3f7		       00	   .shard_247 .byte.b	#0
    266  f3f8		       00	   .shard_248 .byte.b	#0
    267  f3f9		       00	   .shard_249 .byte.b	#0
    268  f3fa		       00	   .shard_250 .byte.b	#0
    269  f3fb		       00	   .shard_251 .byte.b	#0
    270  f3fc		       00	   .shard_252 .byte.b	#0
    271  f3fd		       00	   .shard_253 .byte.b	#0
    272  f3fe		       00	   .shard_254 .byte.b	#0
    273  f3ff		       00	   .shard_255 .byte.b	#0
------- FILE main.s
------- FILE game_frame.s LEVEL 2 PASS 2
      0  f400					      include	"game_frame.s"
      1  f400							; "Start" with overscan.
      2  f400				   Overscan   subroutine
      3  f400		       85 01		      sta	VBLANK
      0  f402					      TIMER_SETUP	29
      1  f402				   .lines     SET	29
      2  f402		       a9 22		      lda	#(((.lines)*76-14)/64)
      3  f404		       85 02		      sta	WSYNC
      4  f406		       8d 96 02 	      sta	TIM64T
      5  f409
      6  f409							; Read inputs.
      7  f409		       20 13 f5 	      jsr	MoveJoystick
      8  f40c							; Player physics.
      9  f40c		       20 53 f5 	      jsr	SpeedCalculation
     10  f40f							; Animation.
     11  f40f		       20 58 fb 	      jsr	game_state_tick
     12  f412							; Load the ROM kernel into CBSRAM.
     13  f412		       20 83 f4 	      jsr	GameFrameKernelLoader
     14  f415
     15  f415							; Extract 26-bit string to full Gemini profile
     16  f415		       20 00 fa 	      jsr	GeminiPopulate
     17  f418
     18  f418							; Wait out overscan.
      0  f418					      TIMER_WAIT
      1  f418				   .waittimer
      2  f418		       ad 84 02 	      lda	INTIM
      3  f41b		       d0 fb		      bne	.waittimer
      4  f41d		       85 02		      sta	WSYNC
     20  f41f
     21  f41f							; Vertical Sync (3 lines)
     22  f41f				   VerticalSync subroutine
      0  f41f					      VERTICAL_SYNC
      1  f41f		       a9 0e		      lda	#%1110
      2  f421		       85 02	   .VSLP1     sta	WSYNC
      3  f423		       85 00		      sta	VSYNC
      4  f425		       4a		      lsr
      5  f426		       d0 f9		      bne	.VSLP1
     24  f428
     25  f428							; Start of NTSC frame.
     26  f428				   FrameStart subroutine
      0  f428					      ASSERT_RUNTIME	"_scan == #0"
      1  f428				   .COND      SET	"_scan == #0"
 ASSERT: breakif { pc== $f428  && !(  _scan == #0  ) }
      2  f428					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     28  f428
     29  f428				   VerticalBlank subroutine
     30  f428							; Setup frame timer and increment frame counter.
      0  f428					      TIMER_SETUP	37
      1  f428				   .lines     SET	37
      2  f428		       a9 2b		      lda	#(((.lines)*76-14)/64)
      3  f42a		       85 02		      sta	WSYNC
      4  f42c		       8d 96 02 	      sta	TIM64T
     32  f42f		       e6 d5		      inc	FrameCount
     33  f431
     34  f431							; Populate the Nibble kernel values for the current row.
     35  f431		       20 fe f5 	      jsr	GameNibblePopulate
     36  f434							; Update the current kernel with precomputed Nibble data.
     37  f434							; jsr GameNibbleRun
     38  f434		       20 92 f7 	      jsr	NibbleCopyToRam
     39  f437							; jsr NibbleCopyFromRam
     40  f437
     41  f437							; TODO Rerun nibble populate for the "next row"
     42  f437		       20 94 fa 	      jsr	GeminiPopulateFull
     43  f43a		       20 fe f5 	      jsr	GameNibblePopulate
     44  f43d		       20 f5 f7 	      jsr	GameNibbleRun
     45  f440
     46  f440							; Setup frame. Jump and return
     47  f440		       4c 8b f4 	      jmp	GameFrameSetup
     48  f443
     49  f443				   VerticalBlankEnd
     50  f443							; Wait until the end of Vertical blank.
      0  f443					      TIMER_WAIT
      1  f443				   .waittimer
      2  f443		       ad 84 02 	      lda	INTIM
      3  f446		       d0 fb		      bne	.waittimer
      4  f448		       85 02		      sta	WSYNC
      0  f44a					      ASSERT_RUNTIME	"_scan == #37"
      1  f44a				   .COND      SET	"_scan == #37"
 ASSERT: breakif { pc== $f44a  && !(  _scan == #37  ) }
      2  f44a					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     53  f44a
     54  f44a
     55  f44a							;;;;;;;;;;;;;;;;;;;;;;;;;;
     56  f44a							; Visible frame
     57  f44a							;;;;;;;;;;;;;;;;;;;;;;;;;;
     58  f44a
     59  f44a				   GameFrameRender
     60  f44a							; Start rendering the kernel.
     61  f44a		       4c 96 fb 	      jmp	KernelBorder
     62  f44d
     63  f44d				   FrameEnd   subroutine
     64  f44d		       85 02		      sta	WSYNC
     65  f44f
     66  f44f							; Blank all background colors.
     67  f44f		       a9 00		      lda	#0
     68  f451		       85 08		      sta	COLUPF
     69  f453		       85 0f		      sta	PF2
     70  f455		       85 0e		      sta	PF1
     71  f457		       85 1c		      sta	EMERALD_SP
     72  f459
     73  f459							; Guide lines (2x)
     74  f459		       a9 02		      lda	#SIGNAL_LINE
     75  f45b		       85 09		      sta	COLUBK
     76  f45d					      REPEAT	6
     77  f45d		       85 02		      sta	WSYNC
     76  f45d					      REPEND
     77  f45f		       85 02		      sta	WSYNC
     76  f45f					      REPEND
     77  f461		       85 02		      sta	WSYNC
     76  f461					      REPEND
     77  f463		       85 02		      sta	WSYNC
     76  f463					      REPEND
     77  f465		       85 02		      sta	WSYNC
     76  f465					      REPEND
     77  f467		       85 02		      sta	WSYNC
     78  f469					      REPEND
     79  f469		       a9 00		      lda	#$00
     80  f46b		       85 09		      sta	COLUBK
     81  f46d
     82  f46d							; Restore stack pointer
     83  f46d		       a6 e1		      ldx	RamStackBkp
     84  f46f		       9a		      txs
     85  f470
     86  f470							; Display the rest of the blank screen.
      0  f470					      TIMER_SETUP	25
      1  f470				   .lines     SET	25
      2  f470		       a9 1d		      lda	#(((.lines)*76-14)/64)
      3  f472		       85 02		      sta	WSYNC
      4  f474		       8d 96 02 	      sta	TIM64T
     88  f477		       85 02		      sta	WSYNC
      0  f479					      TIMER_WAIT
      1  f479				   .waittimer
      2  f479		       ad 84 02 	      lda	INTIM
      3  f47c		       d0 fb		      bne	.waittimer
      4  f47e		       85 02		      sta	WSYNC
      0  f480					      ASSERT_RUNTIME	"_scan == (#37 + #184)"
      1  f480				   .COND      SET	"_scan == (#37 + #184)"
 ASSERT: breakif { pc== $f480  && !(  _scan == (#37 + #184)  ) }
      2  f480					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     91  f480
     92  f480							; Finish with overscan
     93  f480		       4c 00 f4 	      jmp	Overscan
     94  f483
     95  f483
     96  f483							;;;;;;;;;;;;;;;;;;;;;;;;;;
     97  f483							; Other stuff
     98  f483							;;;;;;;;;;;;;;;;;;;;;;;;;;
     99  f483
    100  f483							; Load the ROM kernel into CBSRAM.
    101  f483				   GameFrameKernelLoader subroutine
    102  f483							; Kernel A or B
    103  f483		       a9 01		      lda	#01
    104  f485					      IFNCONST	ONLY_KERNEL_B
    105  f485				  -	      IFNCONST	ONLY_KERNEL_A
    106  f485				  -			; FIXME Kernel B disabled for test
    107  f485				  -	      and	FrameCount
    108  f485				  -	      bne	.kernel_b
    109  f485					      ENDIF
    110  f485				   .kernel_a
    111  f485							; Load kernel A into CBSRAM
    112  f485		       4c 5d f2 	      jmp	LoadKernelA
    113  f488					      ENDIF
    114  f488				   .kernel_b
    115  f488							; Load kernel B into CBSRAM
    116  f488		       4c 6f f2 	      jmp	LoadKernelB
    117  f48b
    118  f48b							; Kernel-specific frame setup.
    119  f48b				   GameFrameSetup subroutine
    120  f48b							; Kernel A or B reading directly from the kernel ID
    121  f48b		       ad 00 f1 	      lda	CBSRAM_KERNEL_READ
    122  f48e		       c9 0a		      cmp	#$0a
    123  f490		       d0 1d		      bne	.kernel_b
    124  f492
    125  f492				   .kernel_a
    126  f492							; Move missile
    127  f492		       85 02		      sta	WSYNC
      0  f494					      sleep	KERNEL_A_MISSILE_SLEEP
      1  f494				   .CYCLES    SET	KERNEL_A_MISSILE_SLEEP
      2  f494
      3  f494				  -	      IF	.CYCLES < 2
      4  f494				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f494				  -	      ERR
      6  f494					      ENDIF
      7  f494
      8  f494				  -	      IF	.CYCLES & 1
      9  f494				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f494				  -	      nop	0
     11  f494				  -	      ELSE
     12  f494				  -	      bit	VSYNC
     13  f494				  -	      ENDIF
     14  f494				  -.CYCLES    SET	.CYCLES - 3
     15  f494					      ENDIF
     16  f494
     17  f494					      REPEAT	.CYCLES / 2
     18  f494		       ea		      nop
     17  f494					      REPEND
     18  f495		       ea		      nop
     17  f495					      REPEND
     18  f496		       ea		      nop
     17  f496					      REPEND
     18  f497		       ea		      nop
     17  f497					      REPEND
     18  f498		       ea		      nop
     17  f498					      REPEND
     18  f499		       ea		      nop
     17  f499					      REPEND
     18  f49a		       ea		      nop
     17  f49a					      REPEND
     18  f49b		       ea		      nop
     17  f49b					      REPEND
     18  f49c		       ea		      nop
     17  f49c					      REPEND
     18  f49d		       ea		      nop
     17  f49d					      REPEND
     18  f49e		       ea		      nop
     17  f49e					      REPEND
     18  f49f		       ea		      nop
     17  f49f					      REPEND
     18  f4a0		       ea		      nop
     17  f4a0					      REPEND
     18  f4a1		       ea		      nop
     19  f4a2					      REPEND
    129  f4a2		       85 13		      sta	EMERALD_MI_RESET
    130  f4a4		       a9 00		      lda	#KERNEL_A_MISSILE_HMOVE
    131  f4a6		       85 23		      sta	EMERALD_MI_HMOVE
    132  f4a8
    133  f4a8							; DEBUG: Set per-kernel color
    134  f4a8		       a2 cc		      ldx	#COL_EMERALD
    135  f4aa		       86 07		      stx	EMERALD_SP_COLOR
    136  f4ac
    137  f4ac		       4c fb f4 	      jmp	.complete
    138  f4af
    139  f4af				   .kernel_b
    140  f4af							; Move missile
    141  f4af		       85 02		      sta	WSYNC
      0  f4b1					      sleep	KERNEL_B_MISSILE_SLEEP
      1  f4b1				   .CYCLES    SET	KERNEL_B_MISSILE_SLEEP
      2  f4b1
      3  f4b1				  -	      IF	.CYCLES < 2
      4  f4b1				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f4b1				  -	      ERR
      6  f4b1					      ENDIF
      7  f4b1
      8  f4b1					      IF	.CYCLES & 1
      9  f4b1					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f4b1		       04 00		      nop	0
     11  f4b3				  -	      ELSE
     12  f4b3				  -	      bit	VSYNC
     13  f4b3					      ENDIF
     14  f4b3				   .CYCLES    SET	.CYCLES - 3
     15  f4b3					      ENDIF
     16  f4b3
     17  f4b3					      REPEAT	.CYCLES / 2
     18  f4b3		       ea		      nop
     17  f4b3					      REPEND
     18  f4b4		       ea		      nop
     17  f4b4					      REPEND
     18  f4b5		       ea		      nop
     17  f4b5					      REPEND
     18  f4b6		       ea		      nop
     17  f4b6					      REPEND
     18  f4b7		       ea		      nop
     17  f4b7					      REPEND
     18  f4b8		       ea		      nop
     17  f4b8					      REPEND
     18  f4b9		       ea		      nop
     17  f4b9					      REPEND
     18  f4ba		       ea		      nop
     17  f4ba					      REPEND
     18  f4bb		       ea		      nop
     17  f4bb					      REPEND
     18  f4bc		       ea		      nop
     17  f4bc					      REPEND
     18  f4bd		       ea		      nop
     17  f4bd					      REPEND
     18  f4be		       ea		      nop
     17  f4be					      REPEND
     18  f4bf		       ea		      nop
     17  f4bf					      REPEND
     18  f4c0		       ea		      nop
     17  f4c0					      REPEND
     18  f4c1		       ea		      nop
     17  f4c1					      REPEND
     18  f4c2		       ea		      nop
     17  f4c2					      REPEND
     18  f4c3		       ea		      nop
     17  f4c3					      REPEND
     18  f4c4		       ea		      nop
     17  f4c4					      REPEND
     18  f4c5		       ea		      nop
     17  f4c5					      REPEND
     18  f4c6		       ea		      nop
     17  f4c6					      REPEND
     18  f4c7		       ea		      nop
     17  f4c7					      REPEND
     18  f4c8		       ea		      nop
     17  f4c8					      REPEND
     18  f4c9		       ea		      nop
     17  f4c9					      REPEND
     18  f4ca		       ea		      nop
     19  f4cb					      REPEND
    143  f4cb		       85 13		      sta	EMERALD_MI_RESET
    144  f4cd		       a9 10		      lda	#KERNEL_B_MISSILE_HMOVE
    145  f4cf		       85 23		      sta	EMERALD_MI_HMOVE
    146  f4d1
    147  f4d1							; Possibly override Missile position.
    148  f4d1							; TODO Document use of DO_MISS_B here, to check if M1 should be reset to a
    149  f4d1							; hidden position on Kernel B as a mechanism for offing the missile bit.
    150  f4d1		       a5 e9		      lda	DO_MISS_B
    151  f4d3		       d0 22		      bne	.kernel_b_continue
    152  f4d5		       85 02		      sta	WSYNC
      0  f4d7					      sleep	KERNEL_B_MISSILE_SLEEP + 8
      1  f4d7				   .CYCLES    SET	KERNEL_B_MISSILE_SLEEP + 8
      2  f4d7
      3  f4d7				  -	      IF	.CYCLES < 2
      4  f4d7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f4d7				  -	      ERR
      6  f4d7					      ENDIF
      7  f4d7
      8  f4d7					      IF	.CYCLES & 1
      9  f4d7					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f4d7		       04 00		      nop	0
     11  f4d9				  -	      ELSE
     12  f4d9				  -	      bit	VSYNC
     13  f4d9					      ENDIF
     14  f4d9				   .CYCLES    SET	.CYCLES - 3
     15  f4d9					      ENDIF
     16  f4d9
     17  f4d9					      REPEAT	.CYCLES / 2
     18  f4d9		       ea		      nop
     17  f4d9					      REPEND
     18  f4da		       ea		      nop
     17  f4da					      REPEND
     18  f4db		       ea		      nop
     17  f4db					      REPEND
     18  f4dc		       ea		      nop
     17  f4dc					      REPEND
     18  f4dd		       ea		      nop
     17  f4dd					      REPEND
     18  f4de		       ea		      nop
     17  f4de					      REPEND
     18  f4df		       ea		      nop
     17  f4df					      REPEND
     18  f4e0		       ea		      nop
     17  f4e0					      REPEND
     18  f4e1		       ea		      nop
     17  f4e1					      REPEND
     18  f4e2		       ea		      nop
     17  f4e2					      REPEND
     18  f4e3		       ea		      nop
     17  f4e3					      REPEND
     18  f4e4		       ea		      nop
     17  f4e4					      REPEND
     18  f4e5		       ea		      nop
     17  f4e5					      REPEND
     18  f4e6		       ea		      nop
     17  f4e6					      REPEND
     18  f4e7		       ea		      nop
     17  f4e7					      REPEND
     18  f4e8		       ea		      nop
     17  f4e8					      REPEND
     18  f4e9		       ea		      nop
     17  f4e9					      REPEND
     18  f4ea		       ea		      nop
     17  f4ea					      REPEND
     18  f4eb		       ea		      nop
     17  f4eb					      REPEND
     18  f4ec		       ea		      nop
     17  f4ec					      REPEND
     18  f4ed		       ea		      nop
     17  f4ed					      REPEND
     18  f4ee		       ea		      nop
     17  f4ee					      REPEND
     18  f4ef		       ea		      nop
     17  f4ef					      REPEND
     18  f4f0		       ea		      nop
     17  f4f0					      REPEND
     18  f4f1		       ea		      nop
     17  f4f1					      REPEND
     18  f4f2		       ea		      nop
     17  f4f2					      REPEND
     18  f4f3		       ea		      nop
     17  f4f3					      REPEND
     18  f4f4		       ea		      nop
     19  f4f5					      REPEND
    154  f4f5		       85 13		      sta	EMERALD_MI_RESET
    155  f4f7
    156  f4f7				   .kernel_b_continue
    157  f4f7							; DEBUG: Set per-kernel color
    158  f4f7		       a2 e4		      ldx	#$e4
    159  f4f9							; ldx #COL_EMERALD
    160  f4f9		       86 07		      stx	EMERALD_SP_COLOR
    161  f4fb
    162  f4fb				   .complete
    163  f4fb
    164  f4fb							; General frame setup.
    165  f4fb				   FrameSetup subroutine
    166  f4fb							; Save stack pointer
    167  f4fb		       ba		      tsx
    168  f4fc		       86 e1		      stx	RamStackBkp
    169  f4fe
    170  f4fe							; Row counter
    171  f4fe		       a9 10		      lda	#ROW_COUNT
    172  f500		       85 d4		      sta	LoopCount
    173  f502
    174  f502							; let SpriteEnd = Frame Height - Y Position
    175  f502		       18		      clc
    176  f503		       a9 c8		      lda	#HEIGHT_OFFSET
    177  f505		       e5 da		      sbc	YPos
    178  f507		       85 d6		      sta	SpriteEnd
    179  f509
    180  f509							; Position Player 1
    181  f509		       a5 d7		      lda	XPos
    182  f50b		       a2 00		      ldx	#0
    183  f50d		       20 8a f5 	      jsr	SetHorizPos
    184  f510
    185  f510		       4c 43 f4 	      jmp	VerticalBlankEnd
------- FILE main.s
------- FILE game_input.s LEVEL 2 PASS 2
      0  f513					      include	"game_input.s"
      1  f513							; Handles input checking. Called from overscan.
      2  f513
      3  f513							; Read joystick movement and apply to object 0
      4  f513				   MoveJoystick subroutine
      5  f513
      6  f513							; HACK to add in resetting ability for the gems
      7  f513		       a5 0c		      lda	INPT4	; read left port action button
      8  f515		       29 80		      and	#%10000000	; safe to avoid any reads from D6 - D0
      9  f517		       30 03		      bmi	.actionButtonNotPressed	; branch if action button not pressed
     10  f519		       20 3a fb 	      jsr	game_state_setup
     11  f51c				   .actionButtonNotPressed
     12  f51c
     13  f51c							; Move vertically
     14  f51c							; (up and down are actually reversed since ypos starts at bottom)
     15  f51c							;     ldx YPos
     16  f51c		       a9 10		      lda	#%00010000	;Up?
     17  f51e		       2c 80 02 	      bit	SWCHA
     18  f521		       d0 0d		      bne	SkipMoveUp
     19  f523
     20  f523		       18		      clc
     21  f524		       a5 d9		      lda	Speed2
     22  f526		       69 0c		      adc	#12
     23  f528		       85 d9		      sta	Speed2
     24  f52a		       a5 d8		      lda	Speed1
     25  f52c		       69 00		      adc	#00
     26  f52e		       85 d8		      sta	Speed1
     27  f530
     28  f530				   SkipMoveUp
     29  f530		       a6 d7		      ldx	XPos
     30  f532
     31  f532							; Only check left/right on odd frames;
     32  f532							; TODO make this just a fractional speed
     33  f532							; rather than dropping frames
     34  f532		       a9 01		      lda	#01
     35  f534		       25 d5		      and	FrameCount
     36  f536		       d0 18		      bne	SkipMoveRight
     37  f538
     38  f538
     39  f538							; Move horizontally
     40  f538		       a9 40		      lda	#%01000000	;Left?
     41  f53a		       2c 80 02 	      bit	SWCHA
     42  f53d		       d0 05		      bne	SkipMoveLeft
     43  f53f		       e0 1d		      cpx	#29
     44  f541		       90 01		      bcc	SkipMoveLeft
     45  f543		       ca		      dex
     46  f544
     47  f544							; Reflect
     48  f544							;     lda #$ff
     49  f544							;     sta REFP0
     50  f544				   SkipMoveLeft
     51  f544		       a9 80		      lda	#%10000000	;Right?
     52  f546		       2c 80 02 	      bit	SWCHA
     53  f549		       d0 05		      bne	SkipMoveRight
     54  f54b		       e0 80		      cpx	#128
     55  f54d		       b0 01		      bcs	SkipMoveRight
     56  f54f		       e8		      inx
     57  f550
     58  f550							; Reflect
     59  f550							;     lda #$0
     60  f550							;     sta REFP0
     61  f550				   SkipMoveRight
     62  f550		       86 d7		      stx	XPos
     63  f552		       60		      rts
     64  f553
     65  f553
     66  f553				   SpeedCalculation
     67  f553		       38		      sec
     68  f554		       a5 d9		      lda	Speed2
     69  f556		       e9 07		      sbc	#7
     70  f558		       85 d9		      sta	Speed2
     71  f55a		       a5 d8		      lda	Speed1
     72  f55c		       e9 00		      sbc	#0
     73  f55e		       85 d8		      sta	Speed1
     74  f560
     75  f560		       18		      clc
     76  f561		       a5 db		      lda	YPos2
     77  f563		       65 d9		      adc	Speed2
     78  f565		       85 db		      sta	YPos2
     79  f567		       a5 da		      lda	YPos
     80  f569		       65 d8		      adc	Speed1
     81  f56b		       85 da		      sta	YPos
     82  f56d
     83  f56d		       c9 48		      cmp	#FLOOR_OFFSET
     84  f56f		       b0 0a		      bcs	NewThing2
     85  f571
     86  f571							; Reset to floor
     87  f571		       a9 48		      lda	#FLOOR_OFFSET
     88  f573		       85 da		      sta	YPos
     89  f575		       a9 00		      lda	#0
     90  f577		       85 d8		      sta	Speed1
     91  f579		       85 d9		      sta	Speed2
     92  f57b				   NewThing2
     93  f57b
     94  f57b		       c9 c0		      cmp	#CEILING_OFFSET
     95  f57d		       90 0a		      bcc	.next
     96  f57f
     97  f57f							; Reset to ceiling
     98  f57f		       a9 c0		      lda	#CEILING_OFFSET
     99  f581		       85 da		      sta	YPos
    100  f583		       a9 00		      lda	#0
    101  f585		       85 d8		      sta	Speed1
    102  f587		       85 d9		      sta	Speed2
    103  f589				   .next
    104  f589		       60		      rts
    105  f58a
    106  f58a
    107  f58a
    108  f58a							; Subroutine
    109  f58a				   SetHorizPos
    110  f58a		       85 02		      sta	WSYNC	; start a new line
    111  f58c		       24 00		      bit	0	; waste 3 cycles
    112  f58e		       38		      sec		; set carry flag
    113  f58f				   DivideLoop
    114  f58f		       e9 0f		      sbc	#15	; subtract 15
    115  f591		       b0 fc		      bcs	DivideLoop	; branch until negative
    116  f593		       49 07		      eor	#7	; calculate fine offset
    117  f595		       0a		      asl
    118  f596		       0a		      asl
    119  f597		       0a		      asl
    120  f598		       0a		      asl
    121  f599		       95 10		      sta	JET_SP_RESET,x	; fix coarse position
    122  f59b		       95 20		      sta	JET_SP_HMOVE,x	; set fine offset
    123  f59d		       60		      rts		; return to caller
------- FILE main.s
------- FILE game_nibble.s LEVEL 2 PASS 2
      0  f59e					      include	"game_nibble.s"
      1  f59e							; Frame loop, including calling out to other kernels.
      2  f59e
      3  f59e		       00 aa	   SENTINEL   =	%010101010
      4  f59e
      5  f59e							; Reflected for Kernel A
      6  f59e		       00 00	   G00	      =	%00000000
      7  f59e		       00 60	   G01	      =	%01100000
      8  f59e		       00 06	   G10	      =	%00000110
      9  f59e		       00 66	   G11	      =	%01100110
     10  f59e
     11  f59e		       00 a9	   BC_LDA_IMM =	$a9
     12  f59e		       00 85	   BC_STA     =	$85
     13  f59e		       00 86	   BC_STX     =	$86
     14  f59e		       00 84	   BC_STY     =	$84
     15  f59e		       00 08	   BC_PHP     =	$08
     16  f59e		       00 04	   BC_NOP     =	$04
     17  f59e
     18  f59e		       00 79	   NOP_REG    =	$79	; TODO is there a better reg to write to with NOP effects
     19  f59e
     20  f59e				   KernelA_D_W EQM	[KernelA_D - $100]
     21  f59e				   KernelA_E_W EQM	[KernelA_E - $100]
     22  f59e				   KernelA_G_W EQM	[KernelA_G - $100]
     23  f59e				   KernelA_H_W EQM	[KernelA_H - $100]
     24  f59e				   KernelA_I_W EQM	[KernelA_I - $100]
     25  f59e				   KernelA_J_W EQM	[KernelA_J - $100]
     26  f59e				   KernelA_K_W EQM	[KernelA_K - $100]
     27  f59e
     28  f59e				   KernelB_D_W EQM	[KernelB_D - $100]
     29  f59e				   KernelB_E_W EQM	[KernelB_E - $100]
     30  f59e				   KernelB_F_W EQM	[KernelB_F - $100]
     31  f59e				   KernelB_G_W EQM	[KernelB_G - $100]
     32  f59e				   KernelB_H_W EQM	[KernelB_H - $100]
     33  f59e				   KernelB_I_W EQM	[KernelB_I - $100]
     34  f59e				   KernelB_J_W EQM	[KernelB_J - $100]
     35  f59e				   KernelB_K_W EQM	[KernelB_K - $100]
     36  f59e
     37  f59e					      mac	calc_regs_and_store
     38  f59e				   .OFFSET    SET	{1}
     39  f59e				   .TARGET    SET	{2}
     40  f59e					      ldy	[DO_GEMS_B + .OFFSET]
     41  f59e					      jsr	KernelB_UpdateRegs
     42  f59e					      sty	.TARGET
     43  f59e					      endm
     44  f59e
     45  f59e							; Y=Gemini Sprite
     46  f59e							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     47  f59e							; processor flag Z is TRUE if this is RST.
     48  f59e				   KernelA_GenReset subroutine
     49  f59e		       c0 00		      cpy	#$00
     50  f5a0		       f0 01		      beq	.start
     51  f5a2		       60		      rts
     52  f5a3							; Current Gemini = $00
     53  f5a3				   .start
     54  f5a3		       a6 d1		      ldx	BuildKernelRST
     55  f5a5		       e0 aa		      cpx	#SENTINEL
     56  f5a7		       d0 04		      bne	.set_else
     57  f5a9							; We have found the first (and only) RST on this line, set the marker var
     58  f5a9		       a2 ff		      ldx	#$ff
     59  f5ab		       86 d1		      stx	BuildKernelRST
     60  f5ad				   .set_else
     61  f5ad		       a2 00		      ldx	#$00
     62  f5af		       60		      rts
     63  f5b0
     64  f5b0							; Y=Gemini Sprite
     65  f5b0							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     66  f5b0							; processor flag Z is TRUE if this is RST.
     67  f5b0				   KernelB_GenPhp subroutine
     68  f5b0		       c0 60		      cpy	#G01
     69  f5b2		       f0 05		      beq	.start
     70  f5b4		       c0 66		      cpy	#G11
     71  f5b6		       f0 01		      beq	.start
     72  f5b8		       60		      rts
     73  f5b9							; Current Gemini = $00
     74  f5b9				   .start
     75  f5b9		       a6 d1		      ldx	BuildKernelRST
     76  f5bb		       e0 aa		      cpx	#SENTINEL
     77  f5bd		       d0 04		      bne	.set_else
     78  f5bf							; We have found the first (and only) RST on this line, set the marker var
     79  f5bf		       84 d1		      sty	BuildKernelRST
     80  f5c1
     81  f5c1							; Set Z flag
     82  f5c1		       a2 00		      ldx	#$00
     83  f5c3				   .set_else
     84  f5c3		       60		      rts
     85  f5c4
     86  f5c4							; Allocates build-time registers for a new Gemini sprite value.
     87  f5c4							; register Y = the storage opcode to write to the result
     88  f5c4							;
     89  f5c4							; NibbleGrp0, NibbleX, NibbleY are compared in that order.
     90  f5c4							; NibbleX, NibbleY are upgraded if not set.
     91  f5c4							; Y=Gemini Sprite
     92  f5c4				   KernelB_UpdateRegs
     93  f5c4				   KernelA_UpdateRegs subroutine
     94  f5c4
     95  f5c4							; If equal to GRP0, return nop
     96  f5c4							; FIXME GRP0 might not always be up to date (should update each entry?)
     97  f5c4							; FIXME GOTTA REVERSE THE GRAPHICS ALSO
     98  f5c4		       c4 d0		      cpy	RamKernelGrp0
     99  f5c6		       d0 03		      bne	.op_start
    100  f5c8							; TODO if this is stx + NOP value, then register doesn't have to change as
    101  f5c8							; often in GEM1ASWITCH
    102  f5c8		       a0 04		      ldy	#BC_NOP
    103  f5ca		       60		      rts
    104  f5cb
    105  f5cb				   .op_start
    106  f5cb		       c4 cc		      cpy	NibbleX
    107  f5cd		       d0 03		      bne	.op_else
    108  f5cf		       a0 86		      ldy	#BC_STX
    109  f5d1		       60		      rts
    110  f5d2				   .op_else
    111  f5d2		       c4 cd		      cpy	NibbleY
    112  f5d4		       d0 03		      bne	.op_end
    113  f5d6		       a0 84		      ldy	#BC_STY
    114  f5d8		       60		      rts
    115  f5d9				   .op_end
    116  f5d9
    117  f5d9				   .set_start
    118  f5d9		       a6 cc		      ldx	NibbleX
    119  f5db		       e0 aa		      cpx	#SENTINEL
    120  f5dd		       d0 13		      bne	.set_else
    121  f5df
    122  f5df							; KA Missile opcode determination
    123  f5df				   DBG_CHECK_MISSILE_OPCODE
    124  f5df		       84 cc		      sty	NibbleX
    125  f5e1		       66 cc		      ror	NibbleX	; D0
    126  f5e3		       66 cc		      ror	NibbleX	; D1
    127  f5e5		       a2 86		      ldx	#BC_STX
    128  f5e7		       b0 02		      bcs	[. + 4]
    129  f5e9		       a2 84		      ldx	#BC_STY
    130  f5eb		       86 c9		      stx	NibbleMissile
    131  f5ed
    132  f5ed							; Set the X operator
    133  f5ed		       84 cc		      sty	NibbleX
    134  f5ef		       a0 86		      ldy	#BC_STX
    135  f5f1		       60		      rts
    136  f5f2				   .set_else
    137  f5f2		       a6 cd		      ldx	NibbleY
    138  f5f4		       e0 aa		      cpx	#SENTINEL
    139  f5f6		       d0 05		      bne	.set_end
    140  f5f8		       84 cd		      sty	NibbleY
    141  f5fa		       a0 84		      ldy	#BC_STY
    142  f5fc		       60		      rts
    143  f5fd				   .set_end
    144  f5fd							; Failed all
      0  f5fd					      ASSERT_RUNTIME	"0"
      1  f5fd				   .COND      SET	"0"
 ASSERT: breakif { pc== $f5fd  && !(  0  ) }
      2  f5fd					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    146  f5fd		       60		      rts
    147  f5fe
    148  f5fe							; Populate the Nibble kernel values for the current row.
    149  f5fe				   GameNibblePopulate subroutine
    150  f5fe		       ad 00 f1 	      lda	$f100
    151  f601		       85 80		      sta	DebugKernelID
    152  f603
    153  f603		       ad 18 ff 	      lda	shard_map
    154  f606		       a0 01		      ldy	#1	; gemini counter, starting at 1
    155  f608				   gemini_builder subroutine
    156  f608		       c0 01		      cpy	#1	; TODO top two bits of shard_map
    157  f60a		       d0 00		      bne	.no_vd0
    158  f60c				   .no_vd0
    159  f60c
    160  f60c							; Nibble Kernel A
      0  f60c					      NIBBLE_START_KERNEL	gem_kernel_a_1, 40
      1 U00e6 ????				      seg.U	ignoreme
      0 U00e6 ????				      NIBBLE_VAR	NibbleGemini1
      0 U00e6 ????				      NIBBLE_VAR	NibbleGemini1Reg
      0 U00e6 ????				      NIBBLE_VAR	NibbleGemini2
      0 U00e6 ????				      NIBBLE_VAR	NibbleGemini2Reg
      0 U00e6 ????				      NIBBLE_VAR	NibbleGemini3
      0 U00e6 ????				      NIBBLE_VAR	NibbleGemini3Reg
    168 U00e6 ????						; NIBBLE_VAR NibbleGemini4
    169 U00e6 ????						; NIBBLE_VAR NibbleMissile
    170 U00e6 ????						; NIBBLE_VAR NibbleVdel1
      0 U00e6 ????				      NIBBLE_VAR	NibbleGrp0
      0 U00e6 ????				      NIBBLE_VAR	NibbleX
      0 U00e6 ????				      NIBBLE_VAR	NibbleY
    174 U00e6 ????
    175 U00e6 ????	       a0 aa		      ldy	#SENTINEL	; sentinel
    176 U00e8 ????	       84 d1		      sty	BuildKernelRST
      0 U00ea ????				      NIBBLE_VAR_STY	NibbleX
      0 U00ea ????				      NIBBLE_VAR_STY	NibbleY
    179 U00ea ????
    180 U00ea ????						; Gemini 1A
    181 U00ea ????			   .K_1A
    182 U00ea ????	       a4 ea		      ldy	[DO_GEMS_A + 0]
    183 U00ec ????	       20 9e f5 	      jsr	KernelA_GenReset
      0 U00ef ????				      NIBBLE_IF	eq
    185 U00ef ????						; Special: Encoding RST0
    186 U00ef ????						; Rewrite lda RamKernelPF1 to be #immediate
    187 U00ef ????	       a0 a9		      ldy	#BC_LDA_IMM
    188 U00f1 ????	       8c 15 f0 	      sty	[KernelA_B - $100]
    189 U00f4 ????	       a0 a0		      ldy	#%10100000
    190 U00f6 ????	       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
    191 U00f9 ????						; Store 1A in GRP0
    192 U00f9 ????	       a4 eb		      ldy	[DO_GEMS_A + 1]
      0 U00fb ????				      NIBBLE_VAR_STY	NibbleGrp0
    194 U00fb ????	       84 d0		      sty	RamKernelGrp0
    195 U00fd ????						; Gemini 1A is RESPx
    196 U00fd ????	       a0 11		      ldy	#EMERALD_SP_RESET
    197 U00ff ????	       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
    198 U0102 ????						; Turn 3-cycle NOP into 4-cycle
    199 U0102 ????	       a0 14		      ldy	#$14	; TODO what is this
    200 U0104 ????	       8c 19 f0 	      sty	[KernelA_D - $100]
      0 U0107 ????				      NIBBLE_ELSE
    202 U0107 ????						; Store 0A in GRP0
    203 U0107 ????	       a4 ea		      ldy	[DO_GEMS_A + 0]
      0 U0109 ????				      NIBBLE_VAR_STY	NibbleGrp0
    205 U0109 ????	       84 d0		      sty	RamKernelGrp0
    206 U010b ????
    207 U010b ????	       a4 eb		      ldy	[DO_GEMS_A + 1]
    208 U010d ????	       20 9e f5 	      jsr	KernelA_GenReset
      0 U0110 ????				      NIBBLE_IF	eq
    210 U0110 ????						; GEM1ASWITCH
      0 U0110 ????				      NIBBLE_WRITE_IMM	[KernelA_D_W + 0], #BC_STX
      0 U0110 ????				      NIBBLE_WRITE_IMM	[KernelA_D_W + 1], #RESP1	; RESET
      0 U0110 ????				      NIBBLE_ELSE
    214 U0110 ????						; Calculate the 1A value
    215 U0110 ????	       ac 34 fb 	      ldy	SHARD_LUT_RF1
    216 U0113 ????	       c0 01		      cpy	#1
    217 U0115 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    218 U0117 ????	       a0 11		      ldy	#RESP1
    219 U0119 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    220 U011a ????	       a0 1c		      ldy	#GRP1
      0 U011c ????				      NIBBLE_VAR_STY	NibbleGemini1Reg
    222 U011c ????
    223 U011c ????						; Set opcode
    224 U011c ????	       ae 34 fb 	      ldx	SHARD_LUT_RF1
    225 U011f ????	       e0 01		      cpx	#1
    226 U0121 ????	       a0 86		      ldy	#BC_STX	; Don't allocate
    227 U0123 ????	       f0 05		      .byte.b	$F0, #5	; beq +4
    228 U0125 ????	       a4 eb		      ldy	[DO_GEMS_A + 1]
    229 U0127 ????	       20 c4 f5 	      jsr	KernelA_UpdateRegs
      0 U012a ????				      NIBBLE_VAR_STY	NibbleGemini1
    231 U012a ????
      0 U012a ????				      NIBBLE_WRITE_VAR	[KernelA_D_W + 0], NibbleGemini1
      0 U012a ????				      NIBBLE_WRITE_VAR	[KernelA_D_W + 1], NibbleGemini1Reg
      0 U012a ????				      NIBBLE_END_IF
      0 U012a ????				      NIBBLE_END_IF
    236 U012a ????
    237 U012a ????						; Stop preserving GRP0
    238 U012a ????	       a0 aa		      ldy	#SENTINEL
    239 U012c ????	       84 d0		      sty	RamKernelGrp0
    240 U012e ????
    241 U012e ????						; NibbleX, NibbleY are upgraded if not set
    242 U012e ????						; Gemini 2A
    243 U012e ????			   .K_2A
    244 U012e ????	       a4 ec		      ldy	[DO_GEMS_A + 2]
    245 U0130 ????	       20 9e f5 	      jsr	KernelA_GenReset
      0 U0133 ????				      NIBBLE_IF	eq
      0 U0133 ????				      NIBBLE_WRITE_IMM	[KernelA_E_W + 1], #NOP_REG	; NOP
      0 U0133 ????				      NIBBLE_WRITE_IMM	[KernelA_G_W + 1], #RESP1	; RESET
      0 U0133 ????				      NIBBLE_ELSE
    250 U0133 ????						; Set opcode
    251 U0133 ????	       a4 ec		      ldy	[DO_GEMS_A + 2]
    252 U0135 ????	       20 c4 f5 	      jsr	KernelA_UpdateRegs
      0 U0138 ????				      NIBBLE_VAR_STY	NibbleGemini2
    254 U0138 ????
    255 U0138 ????						; Set opcode target
    256 U0138 ????	       ac 34 fb 	      ldy	SHARD_LUT_RF1
    257 U013b ????	       c0 02		      cpy	#2
    258 U013d ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    259 U013f ????	       a0 11		      ldy	#RESP1
    260 U0141 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    261 U0142 ????	       a0 1c		      ldy	#GRP1
      0 U0144 ????				      NIBBLE_VAR_STY	NibbleGemini2Reg
    263 U0144 ????
      0 U0144 ????				      NIBBLE_WRITE_IMM	[KernelA_E_W + 1], #RESP1
      0 U0144 ????				      NIBBLE_WRITE_VAR	[KernelA_G_W + 0], NibbleGemini2
      0 U0144 ????				      NIBBLE_WRITE_VAR	[KernelA_G_W + 1], NibbleGemini2Reg	; STX
      0 U0144 ????				      NIBBLE_END_IF
    268 U0144 ????
    269 U0144 ????						; Gemini 3A
    270 U0144 ????			   .K_3A
    271 U0144 ????	       a4 ed		      ldy	[DO_GEMS_A + 3]
    272 U0146 ????	       20 9e f5 	      jsr	KernelA_GenReset
      0 U0149 ????				      NIBBLE_IF	eq
      0 U0149 ????				      NIBBLE_WRITE_IMM	[KernelA_H_W + 1], #RESP1	; RESET
      0 U0149 ????				      NIBBLE_ELSE
    276 U0149 ????						; Set opcode
    277 U0149 ????	       a4 ed		      ldy	[DO_GEMS_A + 3]
    278 U014b ????	       20 c4 f5 	      jsr	KernelA_UpdateRegs
      0 U014e ????				      NIBBLE_VAR_STY	NibbleGemini3
    280 U014e ????
    281 U014e ????						; Set opcode target
    282 U014e ????	       ac 34 fb 	      ldy	SHARD_LUT_RF1
    283 U0151 ????	       c0 03		      cpy	#3
    284 U0153 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    285 U0155 ????	       a0 11		      ldy	#RESP1
    286 U0157 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    287 U0158 ????	       a0 1c		      ldy	#GRP1
      0 U015a ????				      NIBBLE_VAR_STY	NibbleGemini3Reg
    289 U015a ????
      0 U015a ????				      NIBBLE_WRITE_VAR	[KernelA_H_W + 0], NibbleGemini3
      0 U015a ????				      NIBBLE_WRITE_VAR	[KernelA_H_W + 1], NibbleGemini3Reg
      0 U015a ????				      NIBBLE_END_IF
      0 U015a ????				      NIBBLE_END_KERNEL
      1  f60c					      seg	CodeBank3
    294  f60c
      0  f60c					      NIBBLE_START_KERNEL	gem_kernel_a_2, 40
      1 U015a ????				      seg.U	ignoreme
    296 U015a ????						; NIBBLE_VAR NibbleGemini1
    297 U015a ????						; NIBBLE_VAR NibbleGemini1Reg
    298 U015a ????						; NIBBLE_VAR NibbleGemini2
    299 U015a ????						; NIBBLE_VAR NibbleGemini2Reg
    300 U015a ????						; NIBBLE_VAR NibbleGemini3
    301 U015a ????						; NIBBLE_VAR NibbleGemini3Reg
      0 U015a ????				      NIBBLE_VAR	NibbleGemini4
      0 U015a ????				      NIBBLE_VAR	NibbleMissile
      0 U015a ????				      NIBBLE_VAR	NibbleVdel1
      0 U015a ????				      NIBBLE_VAR	NibbleGrp0
      0 U015a ????				      NIBBLE_VAR	NibblePhp
    307 U015a ????
    308 U015a ????						; VD1 default
    309 U015a ????	       a4 eb		      ldy	[DO_GEMS_A + 1]
      0 U015c ????				      NIBBLE_VAR_STY	NibbleVdel1
    311 U015c ????
    312 U015c ????						; Gemini 4A
    313 U015c ????	       ae 35 fb 	      ldx	SHARD_LUT_VD1
    314 U015f ????	       e0 04		      cpx	#4
      0 U0161 ????				      NIBBLE_IF	ne
      0 U0161 ????				      NIBBLE_WRITE_IMM	[KernelA_I_W + 0], #BC_STA, #EMERALD_SP_RESET
      0 U0161 ????				      NIBBLE_WRITE_IMM	[KernelA_J_W + 1], #BC_STA, #PF1
      0 U0161 ????				      NIBBLE_WRITE_IMM	[KernelA_K_W + 1], #BC_PHP
    319 U0161 ????
    320 U0161 ????						; Set PHP
    321 U0161 ????	       a0 26		      ldy	#VDELP1
      0 U0163 ????				      NIBBLE_VAR_STY	NibblePhp
    323 U0163 ????
    324 U0163 ????						; Update VDEL1
    325 U0163 ????	       a4 ee		      ldy	[DO_GEMS_A + 4]
      0 U0165 ????				      NIBBLE_VAR_STY	NibbleVdel1
      0 U0165 ????				      NIBBLE_ELSE
    328 U0165 ????	       a4 ee		      ldy	[DO_GEMS_A + 4]
    329 U0167 ????	       20 c4 f5 	      jsr	KernelA_UpdateRegs
      0 U016a ????				      NIBBLE_VAR_STY	NibbleGemini4
    331 U016a ????
      0 U016a ????				      NIBBLE_WRITE_IMM	[KernelA_I_W + 0], #BC_PHP
      0 U016a ????				      NIBBLE_WRITE_IMM	[KernelA_J_W + 0], #BC_STA, #PF1
      0 U016a ????				      NIBBLE_WRITE_VAR	[KernelA_K_W + 0], NibbleGemini4
      0 U016a ????				      NIBBLE_WRITE_IMM	[KernelA_K_W + 1], #EMERALD_SP
    336 U016a ????
    337 U016a ????						; Set PHP
    338 U016a ????	       a0 11		      ldy	#RESP1
      0 U016c ????				      NIBBLE_VAR_STY	NibblePhp
      0 U016c ????				      NIBBLE_END_IF
    341 U016c ????
    342 U016c ????						; Gemini 5A
    343 U016c ????						; TODO eventually...?
    344 U016c ????
    345 U016c ????						; Missile
    346 U016c ????	       a4 e8		      ldy	DO_MISS_A
    347 U016e ????						; FIXME Why doesn't this branch compile?
    348 U016e ????						; bne .+4
    349 U016e ????						; ldx #BC_NOP
    350 U016e ????						; stx NibbleMissile
      0 U016e ????				      NIBBLE_WRITE_VAR	[KernelA_F - $100], NibbleMissile
    352 U016e ????
    353 U016e ????						; VD1
      0 U016e ????				      NIBBLE_WRITE_VAR	[KernelA_VDEL1 - $100], NibbleVdel1
    355 U016e ????						; GRP0
      0 U016e ????				      NIBBLE_WRITE_VAR	[KernelA_VDEL0 - $100], NibbleGrp0
    357 U016e ????
      0 U016e ????				      NIBBLE_WRITE_IMM	NibblePs, #$ff
      0 U016e ????				      NIBBLE_END_KERNEL
      1  f60c					      seg	CodeBank3
    360  f60c
    361  f60c							; Nibble Kernel B
      0  f60c					      NIBBLE_START_KERNEL	gem_kernel_b_1, 40
      1 U016e ????				      seg.U	ignoreme
    363 U016e ????						; NIBBLE_VAR NibbleGemini1
    364 U016e ????						; NIBBLE_VAR NibbleGemini1Reg
      0 U016e ????				      NIBBLE_VAR	NibbleGemini2
    366 U016e ????						; NIBBLE_VAR NibbleGemini2Reg
      0 U016e ????				      NIBBLE_VAR	NibbleGemini3
    368 U016e ????						; NIBBLE_VAR NibbleGemini3Reg
    369 U016e ????						; NIBBLE_VAR NibbleGemini4
    370 U016e ????						; NIBBLE_VAR NibbleMissile
    371 U016e ????						; NIBBLE_VAR NibbleVdel1
      0 U016e ????				      NIBBLE_VAR	NibbleGrp0
    373 U016e ????
    374 U016e ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    375 U0170 ????	       86 cc		      stx	NibbleX
    376 U0172 ????	       86 cd		      stx	NibbleY
    377 U0174 ????	       86 d1		      stx	BuildKernelRST
    378 U0176 ????
    379 U0176 ????						; Php target default
    380 U0176 ????	       a0 11		      ldy	#RESP1
    381 U0178 ????	       84 ce		      sty	NibblePhp
    382 U017a ????
    383 U017a ????						; Gemini 0B
    384 U017a ????	       a4 f0		      ldy	[DO_GEMS_B + 0]
      0 U017c ????				      NIBBLE_VAR_STY	NibbleGrp0
    386 U017c ????	       84 d0		      sty	RamKernelGrp0
    387 U017e ????						; NIBBLE_WRITE_IMM KernelB_D_W, RamKernelGemini0
    388 U017e ????
    389 U017e ????						; Gemini 1B
    390 U017e ????	       a4 f1		      ldy	[DO_GEMS_B + 1]
    391 U0180 ????	       20 c4 f5 	      jsr	KernelA_UpdateRegs
    392 U0183 ????	       84 c2		      sty	NibbleGemini1
    393 U0185 ????
    394 U0185 ????						; Gemini 2B
    395 U0185 ????	       a4 f2		      ldy	[DO_GEMS_B + 2]
    396 U0187 ????	       20 b0 f5 	      jsr	KernelB_GenPhp
      0 U018a ????				      NIBBLE_IF	eq
      0 U018a ????				      CALC_REGS_AND_STORE	3, NibbleGemini3
      1 U018a ????			   .OFFSET    SET	3
      2 U018a ????			   .TARGET    SET	NibbleGemini3
      3 U018a ????	       a4 f3		      ldy	[DO_GEMS_B + .OFFSET]
      4 U018c ????	       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5 U018f ????	       84 c6		      sty	.TARGET
    399 U0191 ????
    400 U0191 ????						; Write to PHP in 2B
    401 U0191 ????	       a2 1c		      ldx	#EMERALD_SP
    402 U0193 ????	       86 ce		      stx	NibblePhp
      0 U0195 ????				      NIBBLE_WRITE_IMM	[KernelB_E_W + 0], #BC_STY
      0 U0195 ????				      NIBBLE_WRITE_IMM	[KernelB_E_W + 1], #EMERALD_SP_RESET	; 2B
      0 U0195 ????				      NIBBLE_WRITE_IMM	[KernelB_F_W + 1], #BC_PHP
      0 U0195 ????				      NIBBLE_WRITE_IMM	[KernelB_G_W + 0], #BC_STA
      0 U0195 ????				      NIBBLE_WRITE_IMM	[KernelB_G_W + 1], #PF1
      0 U0195 ????				      NIBBLE_WRITE_VAR	[KernelB_H_W + 0], NibbleGemini3
      0 U0195 ????				      NIBBLE_WRITE_IMM	[KernelB_H_W + 1], #EMERALD_SP	; 3B
    410 U0195 ????
    411 U0195 ????						; Update Grp0
    412 U0195 ????	       a4 d1		      ldy	BuildKernelRST
    413 U0197 ????	       84 d0		      sty	RamKernelGrp0
      0 U0199 ????				      NIBBLE_ELSE
    415 U0199 ????						; Gemini 3B
    416 U0199 ????	       a4 f3		      ldy	[DO_GEMS_B + 3]
    417 U019b ????	       20 b0 f5 	      jsr	KernelB_GenPhp
      0 U019e ????				      NIBBLE_IF	eq
    419 U019e ????						; Write to PHP in 3B
      0 U019e ????				      CALC_REGS_AND_STORE	2, NibbleGemini2
      1 U019e ????			   .OFFSET    SET	2
      2 U019e ????			   .TARGET    SET	NibbleGemini2
      3 U019e ????	       a4 f2		      ldy	[DO_GEMS_B + .OFFSET]
      4 U01a0 ????	       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5 U01a3 ????	       84 c4		      sty	.TARGET
    421 U01a5 ????	       a2 1c		      ldx	#EMERALD_SP
    422 U01a7 ????	       86 ce		      stx	NibblePhp
      0 U01a9 ????				      NIBBLE_WRITE_IMM	[KernelB_E_W + 0], #BC_STY
      0 U01a9 ????				      NIBBLE_WRITE_IMM	[KernelB_E_W + 1], #EMERALD_SP_RESET
      0 U01a9 ????				      NIBBLE_WRITE_VAR	[KernelB_F_W + 1], NibbleGemini2
      0 U01a9 ????				      NIBBLE_WRITE_IMM	[KernelB_F_W + 2], #EMERALD_SP	; 2B
      0 U01a9 ????				      NIBBLE_WRITE_IMM	[KernelB_G_W + 1], #BC_STA
      0 U01a9 ????				      NIBBLE_WRITE_IMM	[KernelB_G_W + 2], #PF1
      0 U01a9 ????				      NIBBLE_WRITE_IMM	[KernelB_H_W + 1], #BC_PHP	; 3B
    430 U01a9 ????
    431 U01a9 ????						; Update Grp0
    432 U01a9 ????	       a4 d1		      ldy	BuildKernelRST
    433 U01ab ????	       84 d0		      sty	RamKernelGrp0
      0 U01ad ????				      NIBBLE_ELSE
    435 U01ad ????						; Update 2B
      0 U01ad ????				      CALC_REGS_AND_STORE	2, NibbleGemini2
      1 U01ad ????			   .OFFSET    SET	2
      2 U01ad ????			   .TARGET    SET	NibbleGemini2
      3 U01ad ????	       a4 f2		      ldy	[DO_GEMS_B + .OFFSET]
      4 U01af ????	       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5 U01b2 ????	       84 c4		      sty	.TARGET
      0 U01b4 ????				      NIBBLE_WRITE_VAR	[KernelB_F_W + 0], NibbleGemini2
      0 U01b4 ????				      NIBBLE_WRITE_IMM	[KernelB_F_W + 1], #EMERALD_SP
    439 U01b4 ????
    440 U01b4 ????						; Update 3B
      0 U01b4 ????				      CALC_REGS_AND_STORE	3, NibbleGemini3
      1 U01b4 ????			   .OFFSET    SET	3
      2 U01b4 ????			   .TARGET    SET	NibbleGemini3
      3 U01b4 ????	       a4 f3		      ldy	[DO_GEMS_B + .OFFSET]
      4 U01b6 ????	       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5 U01b9 ????	       84 c6		      sty	.TARGET
      0 U01bb ????				      NIBBLE_WRITE_VAR	[KernelB_H_W + 0], NibbleGemini3
      0 U01bb ????				      NIBBLE_WRITE_IMM	[KernelB_H_W + 1], #EMERALD_SP
      0 U01bb ????				      NIBBLE_END_IF
      0 U01bb ????				      NIBBLE_END_IF
    446 U01bb ????
      0 U01bb ????				      NIBBLE_END_KERNEL
      1  f60c					      seg	CodeBank3
    448  f60c
    449  f60c							; Nibble Kernel B
      0  f60c					      NIBBLE_START_KERNEL	gem_kernel_b_2, 40
      1 U01bb ????				      seg.U	ignoreme
    451 U01bb ????						; NIBBLE_VAR NibbleGemini1
    452 U01bb ????						; NIBBLE_VAR NibbleGemini1Reg
    453 U01bb ????						; NIBBLE_VAR NibbleGemini2
    454 U01bb ????						; NIBBLE_VAR NibbleGemini2Reg
    455 U01bb ????						; NIBBLE_VAR NibbleGemini3
    456 U01bb ????						; NIBBLE_VAR NibbleGemini3Reg
      0 U01bb ????				      NIBBLE_VAR	NibbleGemini4
    458 U01bb ????						; NIBBLE_VAR NibbleMissile
    459 U01bb ????						; NIBBLE_VAR NibbleVdel1
      0 U01bb ????				      NIBBLE_VAR	NibbleGrp0
    461 U01bb ????
    462 U01bb ????						; Gemini 1B
      0 U01bb ????				      NIBBLE_WRITE_IMM	KernelB_D_W, NibbleGemini1
    464 U01bb ????
    465 U01bb ????						; Write out PHP flag comparison
    466 U01bb ????	       a4 d1		      ldy	BuildKernelRST
    467 U01bd ????	       c0 60		      cpy	#G01
      0 U01bf ????				      NIBBLE_IF	eq
      0 U01bf ????				      NIBBLE_WRITE_IMM	[KernelB_C - $100 + 1], #RamFFByte
      0 U01bf ????				      NIBBLE_ELSE
      0 U01bf ????				      NIBBLE_WRITE_IMM	[KernelB_C - $100 + 1], #RamPF1Value
      0 U01bf ????				      NIBBLE_END_IF
    473 U01bf ????
    474 U01bf ????						; Missile
    475 U01bf ????						; ldy DO_MISS_B
    476 U01bf ????						; NIBBLE_IF eq ; Disabled
    477 U01bf ????						; NIBBLE_WRITE_IMM [KernelB_K - $100], #BC_STA
    478 U01bf ????						; NIBBLE_ELSE
    479 U01bf ????						;     NIBBLE_WRITE_IMM [KernelB_K - $100], NibbleMissile
    480 U01bf ????						; NIBBLE_END_IF
    481 U01bf ????
    482 U01bf ????						; Gemini 4B
    483 U01bf ????	       a4 f4		      ldy	[DO_GEMS_B + 4]
    484 U01c1 ????	       20 c4 f5 	      jsr	KernelA_UpdateRegs
    485 U01c4 ????	       84 c8		      sty	NibbleGemini4
      0 U01c6 ????				      NIBBLE_WRITE_VAR	KernelB_J_W, NibbleGemini4
    487 U01c6 ????
    488 U01c6 ????						; TODO if no PHP, rewrite previous section:
    489 U01c6 ????						; NIBBLE_IF cs
    490 U01c6 ????						;     ; Write to PHP in reset command
    491 U01c6 ????						;     NIBBLE_WRITE_IMM [KernelB_E_W + 0], #BC_PHP
    492 U01c6 ????						;     NIBBLE_WRITE_IMM [KernelB_F_W + 0], #BC_STY, #EMERALD_SP ; 2B
    493 U01c6 ????						;     NIBBLE_WRITE_IMM [KernelB_G_W + 0], #BC_STA, #PF1
    494 U01c6 ????						;     NIBBLE_WRITE_IMM [KernelB_H_W + 0], #BC_STY, #EMERALD_SP ; 3B
    495 U01c6 ????						; NIBBLE_END_IF
    496 U01c6 ????
    497 U01c6 ????						; Make adjustments for sprites.
    498 U01c6 ????	       66 cb		      ror	NibbleGrp0
    499 U01c8 ????	       66 cc		      ror	NibbleX
    500 U01ca ????	       66 cd		      ror	NibbleY
    501 U01cc ????
    502 U01cc ????						; ; VD1
    503 U01cc ????						; NIBBLE_WRITE_IMM [KernelB_VDEL1 - $100], NibbleVdel1
    504 U01cc ????						; GRP0
      0 U01cc ????				      NIBBLE_WRITE_VAR	[KernelB_VDEL0 - $100], NibbleGrp0
    506 U01cc ????
      0 U01cc ????				      NIBBLE_WRITE_IMM	NibblePs, #$00
    508 U01cc ????
      0 U01cc ????				      NIBBLE_END_KERNEL
      1  f60c					      seg	CodeBank3
    510  f60c
    511  f60c							; TODO do this for all rows
    512  f60c				   DBG_NIBBLE_BUILD subroutine
    513  f60c		       ae 00 f1 	      ldx	$f100
    514  f60f		       e0 0a		      cpx	#$a
    515  f611		       f0 03		      beq	[. + 5]
    516  f613		       4c 00 f7 	      jmp	.kernel_b
    517  f616				   .kernel_a
      0  f616					      NIBBLE_gem_kernel_a_1_BUILD		; TODO can this be implied
      1  f616		       a9 00		      lda	#0
      2  f618
      3  f618
      4  f618
      5  f618		       a0 aa		      ldy	#SENTINEL
      6  f61a		       84 d1		      sty	BuildKernelRST
      7  f61c		       84 cc		      sty	NibbleX
      8  f61e		       84 cd		      sty	NibbleY
      9  f620
     10  f620				   .K_1A
     11  f620		       a4 ea		      ldy	[DO_GEMS_A + 0]
     12  f622		       20 9e f5 	      jsr	KernelA_GenReset
     13  f625				   .if_1
     14  f625		       d0 20		      bne	.else_1
     15  f627		       38		      sec
     16  f628		       2a		      rol
     17  f629
     18  f629
     19  f629		       a0 a9		      ldy	#BC_LDA_IMM
     20  f62b		       8c 15 f0 	      sty	[KernelA_B - $100]
     21  f62e		       a0 a0		      ldy	#%10100000
     22  f630		       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
     23  f633
     24  f633		       a4 eb		      ldy	[DO_GEMS_A + 1]
     25  f635		       84 cb		      sty	NibbleGrp0
     26  f637		       84 d0		      sty	RamKernelGrp0
     27  f639
     28  f639		       a0 11		      ldy	#EMERALD_SP_RESET
     29  f63b		       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
     30  f63e
     31  f63e		       a0 14		      ldy	#$14
     32  f640		       8c 19 f0 	      sty	[KernelA_D - $100]
     33  f643		       2a		      rol
     34  f644		       4c 7b f6 	      jmp	.endif_1
     35  f647
     36  f647				   .else_1
     37  f647		       18		      clc
     38  f648		       2a		      rol
     39  f649
     40  f649		       a4 ea		      ldy	[DO_GEMS_A + 0]
     41  f64b		       84 cb		      sty	NibbleGrp0
     42  f64d		       84 d0		      sty	RamKernelGrp0
     43  f64f		       a4 eb		      ldy	[DO_GEMS_A + 1]
     44  f651		       20 9e f5 	      jsr	KernelA_GenReset
     45  f654				   .if_2
     46  f654		       d0 05		      bne	.else_2
     47  f656		       38		      sec
     48  f657		       2a		      rol
     49  f658
     50  f658		       4c 7b f6 	      jmp	.endif_2
     51  f65b
     52  f65b				   .else_2
     53  f65b		       18		      clc
     54  f65c		       2a		      rol
     55  f65d
     56  f65d		       ac 34 fb 	      ldy	SHARD_LUT_RF1
     57  f660		       c0 01		      cpy	#1
     58  f662		       d0 03		      .byte.b	$D0, #3
     59  f664		       a0 11		      ldy	#RESP1
     60  f666		       2c		      .byte.b	$2C
     61  f667		       a0 1c		      ldy	#GRP1
     62  f669		       84 c3		      sty	NibbleGemini1Reg
     63  f66b
     64  f66b		       ae 34 fb 	      ldx	SHARD_LUT_RF1
     65  f66e		       e0 01		      cpx	#1
     66  f670		       a0 86		      ldy	#BC_STX
     67  f672		       f0 05		      .byte.b	$F0, #5
     68  f674		       a4 eb		      ldy	[DO_GEMS_A + 1]
     69  f676		       20 c4 f5 	      jsr	KernelA_UpdateRegs
     70  f679		       84 c2		      sty	NibbleGemini1
     71  f67b
     72  f67b
     73  f67b				   .endif_2
     74  f67b
     75  f67b
     76  f67b				   .endif_1
     77  f67b
     78  f67b		       a0 aa		      ldy	#SENTINEL
     79  f67d		       84 d0		      sty	RamKernelGrp0
     80  f67f
     81  f67f
     82  f67f				   .K_2A
     83  f67f		       a4 ec		      ldy	[DO_GEMS_A + 2]
     84  f681		       20 9e f5 	      jsr	KernelA_GenReset
     85  f684				   .if_3
     86  f684		       d0 05		      bne	.else_3
     87  f686		       38		      sec
     88  f687		       2a		      rol
     89  f688		       4c a2 f6 	      jmp	.endif_3
     90  f68b
     91  f68b				   .else_3
     92  f68b		       18		      clc
     93  f68c		       2a		      rol
     94  f68d
     95  f68d		       a4 ec		      ldy	[DO_GEMS_A + 2]
     96  f68f		       20 c4 f5 	      jsr	KernelA_UpdateRegs
     97  f692		       84 c4		      sty	NibbleGemini2
     98  f694
     99  f694		       ac 34 fb 	      ldy	SHARD_LUT_RF1
    100  f697		       c0 02		      cpy	#2
    101  f699		       d0 03		      .byte.b	$D0, #3
    102  f69b		       a0 11		      ldy	#RESP1
    103  f69d		       2c		      .byte.b	$2C
    104  f69e		       a0 1c		      ldy	#GRP1
    105  f6a0		       84 c5		      sty	NibbleGemini2Reg
    106  f6a2
    107  f6a2
    108  f6a2				   .endif_3
    109  f6a2
    110  f6a2				   .K_3A
    111  f6a2		       a4 ed		      ldy	[DO_GEMS_A + 3]
    112  f6a4		       20 9e f5 	      jsr	KernelA_GenReset
    113  f6a7				   .if_4
    114  f6a7		       d0 05		      bne	.else_4
    115  f6a9		       38		      sec
    116  f6aa		       2a		      rol
    117  f6ab		       4c c5 f6 	      jmp	.endif_4
    118  f6ae
    119  f6ae				   .else_4
    120  f6ae		       18		      clc
    121  f6af		       2a		      rol
    122  f6b0
    123  f6b0		       a4 ed		      ldy	[DO_GEMS_A + 3]
    124  f6b2		       20 c4 f5 	      jsr	KernelA_UpdateRegs
    125  f6b5		       84 c6		      sty	NibbleGemini3
    126  f6b7
    127  f6b7		       ac 34 fb 	      ldy	SHARD_LUT_RF1
    128  f6ba		       c0 03		      cpy	#3
    129  f6bc		       d0 03		      .byte.b	$D0, #3
    130  f6be		       a0 11		      ldy	#RESP1
    131  f6c0		       2c		      .byte.b	$2C
    132  f6c1		       a0 1c		      ldy	#GRP1
    133  f6c3		       84 c7		      sty	NibbleGemini3Reg
    134  f6c5
    135  f6c5
    136  f6c5				   .endif_4
    137  f6c5
    138  f6c5		       2a		      rol
    139  f6c6		       2a		      rol
    140  f6c7		       2a		      rol
    141  f6c8		       2a		      rol
    519  f6c9		       85 c0		      sta	NibbleVar1
      0  f6cb					      NIBBLE_gem_kernel_a_2_BUILD		; TODO can this be implied
      1  f6cb		       a9 00		      lda	#0
      2  f6cd
      3  f6cd
      4  f6cd
      5  f6cd
      6  f6cd
      7  f6cd
      8  f6cd
      9  f6cd		       a4 eb		      ldy	[DO_GEMS_A + 1]
     10  f6cf		       84 ca		      sty	NibbleVdel1
     11  f6d1
     12  f6d1		       ae 35 fb 	      ldx	SHARD_LUT_VD1
     13  f6d4		       e0 04		      cpx	#4
     14  f6d6				   .if_1
     15  f6d6		       f0 0d		      beq	.else_1
     16  f6d8		       38		      sec
     17  f6d9		       2a		      rol
     18  f6da
     19  f6da		       a0 26		      ldy	#VDELP1
     20  f6dc		       84 ce		      sty	NibblePhp
     21  f6de
     22  f6de		       a4 ee		      ldy	[DO_GEMS_A + 4]
     23  f6e0		       84 ca		      sty	NibbleVdel1
     24  f6e2		       4c f2 f6 	      jmp	.endif_1
     25  f6e5
     26  f6e5				   .else_1
     27  f6e5		       18		      clc
     28  f6e6		       2a		      rol
     29  f6e7		       a4 ee		      ldy	[DO_GEMS_A + 4]
     30  f6e9		       20 c4 f5 	      jsr	KernelA_UpdateRegs
     31  f6ec		       84 c8		      sty	NibbleGemini4
     32  f6ee
     33  f6ee		       a0 11		      ldy	#RESP1
     34  f6f0		       84 ce		      sty	NibblePhp
     35  f6f2
     36  f6f2
     37  f6f2				   .endif_1
     38  f6f2
     39  f6f2
     40  f6f2
     41  f6f2		       a4 e8		      ldy	DO_MISS_A
     42  f6f4
     43  f6f4
     44  f6f4
     45  f6f4
     46  f6f4
     47  f6f4
     48  f6f4
     49  f6f4		       2a		      rol
     50  f6f5		       2a		      rol
     51  f6f6		       2a		      rol
     52  f6f7		       2a		      rol
     53  f6f8		       2a		      rol
     54  f6f9		       2a		      rol
     55  f6fa		       2a		      rol
    521  f6fb		       85 c1		      sta	NibbleVar2
    522  f6fd		       4c 91 f7 	      jmp	.next
    523  f700				   .kernel_b
      0  f700					      NIBBLE_gem_kernel_b_1_BUILD		; TODO can this be implied
      1  f700		       a9 00		      lda	#0
      2  f702
      3  f702
      4  f702
      5  f702
      6  f702
      7  f702
      8  f702
      9  f702		       a2 aa		      ldx	#SENTINEL
     10  f704		       86 cc		      stx	NibbleX
     11  f706		       86 cd		      stx	NibbleY
     12  f708		       86 d1		      stx	BuildKernelRST
     13  f70a
     14  f70a		       a0 11		      ldy	#RESP1
     15  f70c		       84 ce		      sty	NibblePhp
     16  f70e
     17  f70e		       a4 f0		      ldy	[DO_GEMS_B + 0]
     18  f710		       84 cb		      sty	NibbleGrp0
     19  f712		       84 d0		      sty	RamKernelGrp0
     20  f714
     21  f714
     22  f714		       a4 f1		      ldy	[DO_GEMS_B + 1]
     23  f716		       20 c4 f5 	      jsr	KernelA_UpdateRegs
     24  f719		       84 c2		      sty	NibbleGemini1
     25  f71b
     26  f71b		       a4 f2		      ldy	[DO_GEMS_B + 2]
     27  f71d		       20 b0 f5 	      jsr	KernelB_GenPhp
     28  f720				   .if_1
     29  f720		       d0 15		      bne	.else_1
     30  f722		       38		      sec
     31  f723		       2a		      rol
      0  f724					      CALC_REGS_AND_STORE	3, NibbleGemini3
      1  f724				   .OFFSET    SET	3
      2  f724				   .TARGET    SET	NibbleGemini3
      3  f724		       a4 f3		      ldy	[DO_GEMS_B + .OFFSET]
      4  f726		       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5  f729		       84 c6		      sty	.TARGET
     33  f72b
     34  f72b		       a2 1c		      ldx	#EMERALD_SP
     35  f72d		       86 ce		      stx	NibblePhp
     36  f72f
     37  f72f		       a4 d1		      ldy	BuildKernelRST
     38  f731		       84 d0		      sty	RamKernelGrp0
     39  f733		       2a		      rol
     40  f734		       4c 64 f7 	      jmp	.endif_1
     41  f737
     42  f737				   .else_1
     43  f737		       18		      clc
     44  f738		       2a		      rol
     45  f739
     46  f739		       a4 f3		      ldy	[DO_GEMS_B + 3]
     47  f73b		       20 b0 f5 	      jsr	KernelB_GenPhp
     48  f73e				   .if_2
     49  f73e		       d0 14		      bne	.else_2
     50  f740		       38		      sec
     51  f741		       2a		      rol
     52  f742
      0  f742					      CALC_REGS_AND_STORE	2, NibbleGemini2
      1  f742				   .OFFSET    SET	2
      2  f742				   .TARGET    SET	NibbleGemini2
      3  f742		       a4 f2		      ldy	[DO_GEMS_B + .OFFSET]
      4  f744		       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5  f747		       84 c4		      sty	.TARGET
     54  f749		       a2 1c		      ldx	#EMERALD_SP
     55  f74b		       86 ce		      stx	NibblePhp
     56  f74d
     57  f74d
     58  f74d		       a4 d1		      ldy	BuildKernelRST
     59  f74f		       84 d0		      sty	RamKernelGrp0
     60  f751		       4c 64 f7 	      jmp	.endif_2
     61  f754
     62  f754				   .else_2
     63  f754		       18		      clc
     64  f755		       2a		      rol
     65  f756
      0  f756					      CALC_REGS_AND_STORE	2, NibbleGemini2
      1  f756				   .OFFSET    SET	2
      2  f756				   .TARGET    SET	NibbleGemini2
      3  f756		       a4 f2		      ldy	[DO_GEMS_B + .OFFSET]
      4  f758		       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5  f75b		       84 c4		      sty	.TARGET
     67  f75d
      0  f75d					      CALC_REGS_AND_STORE	3, NibbleGemini3
      1  f75d				   .OFFSET    SET	3
      2  f75d				   .TARGET    SET	NibbleGemini3
      3  f75d		       a4 f3		      ldy	[DO_GEMS_B + .OFFSET]
      4  f75f		       20 c4 f5 	      jsr	KernelB_UpdateRegs
      5  f762		       84 c6		      sty	.TARGET
     69  f764
     70  f764
     71  f764				   .endif_2
     72  f764
     73  f764
     74  f764				   .endif_1
     75  f764
     76  f764		       2a		      rol
     77  f765		       2a		      rol
     78  f766		       2a		      rol
     79  f767		       2a		      rol
     80  f768		       2a		      rol
     81  f769		       2a		      rol
    525  f76a		       85 c0		      sta	NibbleVar1
      0  f76c					      NIBBLE_gem_kernel_b_2_BUILD		; TODO can this be implied
      1  f76c		       a9 00		      lda	#0
      2  f76e
      3  f76e
      4  f76e
      5  f76e
      6  f76e
      7  f76e
      8  f76e
      9  f76e
     10  f76e
     11  f76e
     12  f76e		       a4 d1		      ldy	BuildKernelRST
     13  f770		       c0 60		      cpy	#G01
     14  f772				   .if_1
     15  f772		       d0 05		      bne	.else_1
     16  f774		       38		      sec
     17  f775		       2a		      rol
     18  f776		       4c 7b f7 	      jmp	.endif_1
     19  f779
     20  f779				   .else_1
     21  f779		       18		      clc
     22  f77a		       2a		      rol
     23  f77b
     24  f77b
     25  f77b				   .endif_1
     26  f77b
     27  f77b
     28  f77b
     29  f77b
     30  f77b
     31  f77b
     32  f77b
     33  f77b
     34  f77b		       a4 f4		      ldy	[DO_GEMS_B + 4]
     35  f77d		       20 c4 f5 	      jsr	KernelA_UpdateRegs
     36  f780		       84 c8		      sty	NibbleGemini4
     37  f782
     38  f782
     39  f782
     40  f782
     41  f782
     42  f782
     43  f782
     44  f782
     45  f782
     46  f782		       66 cb		      ror	NibbleGrp0
     47  f784		       66 cc		      ror	NibbleX
     48  f786		       66 cd		      ror	NibbleY
     49  f788
     50  f788
     51  f788
     52  f788
     53  f788		       2a		      rol
     54  f789		       2a		      rol
     55  f78a		       2a		      rol
     56  f78b		       2a		      rol
     57  f78c		       2a		      rol
     58  f78d		       2a		      rol
     59  f78e		       2a		      rol
    527  f78f		       85 c1		      sta	NibbleVar2
    528  f791				   .next
    529  f791		       60		      rts
    530  f792
    531  f792
    532  f792				   NibbleCopyToRam subroutine
    533  f792							; Copy out
    534  f792		       a2 00		      ldx	#00
    535  f794		       a0 00		      ldy	#$00
    536  f796				   .loop
    537  f796		       b9 c0 00 	      lda	NIBBLE_VAR_START,y
    538  f799		       99 80 f0 	      sta	CBSRAM_NIBBLE_WRITE,y
    539  f79c		       96 c0		      stx	NIBBLE_VAR_START,y
    540  f79e		       c8		      iny
    541  f79f		       c0 10		      cpy	#NIBBLE_VAR_COUNT
    542  f7a1		       d0 f3		      bne	.loop
    543  f7a3		       60		      rts
    544  f7a4
    545  f7a4				   NibbleCopyFromRam subroutine
    546  f7a4				   .INDEX     SET	0
    547  f7a4					      REPEAT	NIBBLE_VAR_COUNT
    548  f7a4		       ad 80 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7a7		       85 c0		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7a7				   .INDEX     SET	.INDEX + 1
    547  f7a7					      REPEND
    548  f7a9		       ad 81 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7ac		       85 c1		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7ac				   .INDEX     SET	.INDEX + 1
    547  f7ac					      REPEND
    548  f7ae		       ad 82 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7b1		       85 c2		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7b1				   .INDEX     SET	.INDEX + 1
    547  f7b1					      REPEND
    548  f7b3		       ad 83 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7b6		       85 c3		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7b6				   .INDEX     SET	.INDEX + 1
    547  f7b6					      REPEND
    548  f7b8		       ad 84 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7bb		       85 c4		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7bb				   .INDEX     SET	.INDEX + 1
    547  f7bb					      REPEND
    548  f7bd		       ad 85 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7c0		       85 c5		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7c0				   .INDEX     SET	.INDEX + 1
    547  f7c0					      REPEND
    548  f7c2		       ad 86 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7c5		       85 c6		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7c5				   .INDEX     SET	.INDEX + 1
    547  f7c5					      REPEND
    548  f7c7		       ad 87 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7ca		       85 c7		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7ca				   .INDEX     SET	.INDEX + 1
    547  f7ca					      REPEND
    548  f7cc		       ad 88 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7cf		       85 c8		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7cf				   .INDEX     SET	.INDEX + 1
    547  f7cf					      REPEND
    548  f7d1		       ad 89 f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7d4		       85 c9		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7d4				   .INDEX     SET	.INDEX + 1
    547  f7d4					      REPEND
    548  f7d6		       ad 8a f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7d9		       85 ca		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7d9				   .INDEX     SET	.INDEX + 1
    547  f7d9					      REPEND
    548  f7db		       ad 8b f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7de		       85 cb		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7de				   .INDEX     SET	.INDEX + 1
    547  f7de					      REPEND
    548  f7e0		       ad 8c f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7e3		       85 cc		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7e3				   .INDEX     SET	.INDEX + 1
    547  f7e3					      REPEND
    548  f7e5		       ad 8d f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7e8		       85 cd		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7e8				   .INDEX     SET	.INDEX + 1
    547  f7e8					      REPEND
    548  f7ea		       ad 8e f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7ed		       85 ce		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7ed				   .INDEX     SET	.INDEX + 1
    547  f7ed					      REPEND
    548  f7ef		       ad 8f f1 	      lda	[CBSRAM_NIBBLE_READ + .INDEX]
    549  f7f2		       85 cf		      sta	[NIBBLE_VAR_START + .INDEX]
    550  f7f2				   .INDEX     SET	.INDEX + 1
    551  f7f4					      REPEND
    552  f7f4		       60		      rts
    553  f7f5
    554  f7f5							; TODO move this into the row kernel
    555  f7f5				   GameNibbleRun subroutine
    556  f7f5		       ae 00 f1 	      ldx	$f100
    557  f7f8		       e0 0a		      cpx	#$a
    558  f7fa		       f0 03		      beq	[. + 5]
    559  f7fc		       4c c8 f8 	      jmp	.kernel_b
    560  f7ff				   .kernel_a
    561  f7ff		       a5 c0		      lda	NibbleVar1
      0  f801					      NIBBLE_gem_kernel_a_1
      1  f801		       0a		      asl
      2  f802		       90 0d		      bcc	.else_1
      3  f804
      4  f804				   .if_1
      5  f804		       2a		      rol
      0  f805					      sleep	18
      1  f805				   .CYCLES    SET	18
      2  f805
      3  f805				  -	      IF	.CYCLES < 2
      4  f805				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f805				  -	      ERR
      6  f805					      ENDIF
      7  f805
      8  f805				  -	      IF	.CYCLES & 1
      9  f805				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f805				  -	      nop	0
     11  f805				  -	      ELSE
     12  f805				  -	      bit	VSYNC
     13  f805				  -	      ENDIF
     14  f805				  -.CYCLES    SET	.CYCLES - 3
     15  f805					      ENDIF
     16  f805
     17  f805					      REPEAT	.CYCLES / 2
     18  f805		       ea		      nop
     17  f805					      REPEND
     18  f806		       ea		      nop
     17  f806					      REPEND
     18  f807		       ea		      nop
     17  f807					      REPEND
     18  f808		       ea		      nop
     17  f808					      REPEND
     18  f809		       ea		      nop
     17  f809					      REPEND
     18  f80a		       ea		      nop
     17  f80a					      REPEND
     18  f80b		       ea		      nop
     17  f80b					      REPEND
     18  f80c		       ea		      nop
     17  f80c					      REPEND
     18  f80d		       ea		      nop
     19  f80e					      REPEND
      7  f80e
      8  f80e
      9  f80e		       4c 2f f8 	      jmp	.endif_1
     10  f811				   .else_1
     11  f811		       0a		      asl
     12  f812		       90 0f		      bcc	.else_2
     13  f814
     14  f814				   .if_2
     15  f814		       a2 86		      ldx	#[ #BC_STX ]
     16  f816		       8e 19 f0 	      stx	[[KernelA_D_W + 0] + 0]
     17  f819		       a2 11		      ldx	#[ #RESP1 ]
     18  f81b		       8e 1a f0 	      stx	[[KernelA_D_W + 1] + 0]
      0  f81e					      sleep	3
      1  f81e				   .CYCLES    SET	3
      2  f81e
      3  f81e				  -	      IF	.CYCLES < 2
      4  f81e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f81e				  -	      ERR
      6  f81e					      ENDIF
      7  f81e
      8  f81e					      IF	.CYCLES & 1
      9  f81e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f81e		       04 00		      nop	0
     11  f820				  -	      ELSE
     12  f820				  -	      bit	VSYNC
     13  f820					      ENDIF
     14  f820				   .CYCLES    SET	.CYCLES - 3
     15  f820					      ENDIF
     16  f820
     17  f820				  -	      REPEAT	.CYCLES / 2
     18  f820				  -	      nop
     19  f820					      REPEND
     20  f820
     21  f820
     22  f820		       4c 2f f8 	      jmp	.endif_2
     23  f823				   .else_2
     24  f823		       be 82 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini1 - NIBBLE_VAR_START],y
     25  f826		       8e 19 f0 	      stx	[[KernelA_D_W + 0] + 0]
     26  f829		       be 83 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini1Reg - NIBBLE_VAR_START],y
     27  f82c		       8e 1a f0 	      stx	[[KernelA_D_W + 1] + 0]
     28  f82f
     29  f82f				   .endif_2
     30  f82f
     31  f82f				   .endif_1
     32  f82f		       0a		      asl
     33  f830		       90 12		      bcc	.else_3
     34  f832
     35  f832				   .if_3
     36  f832		       a2 79		      ldx	#[ #NOP_REG ]
     37  f834		       8e 1c f0 	      stx	[[KernelA_E_W + 1] + 0]
     38  f837		       a2 11		      ldx	#[ #RESP1 ]
     39  f839		       8e 20 f0 	      stx	[[KernelA_G_W + 1] + 0]
      0  f83c					      sleep	9
      1  f83c				   .CYCLES    SET	9
      2  f83c
      3  f83c				  -	      IF	.CYCLES < 2
      4  f83c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f83c				  -	      ERR
      6  f83c					      ENDIF
      7  f83c
      8  f83c					      IF	.CYCLES & 1
      9  f83c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f83c		       04 00		      nop	0
     11  f83e				  -	      ELSE
     12  f83e				  -	      bit	VSYNC
     13  f83e					      ENDIF
     14  f83e				   .CYCLES    SET	.CYCLES - 3
     15  f83e					      ENDIF
     16  f83e
     17  f83e					      REPEAT	.CYCLES / 2
     18  f83e		       ea		      nop
     17  f83e					      REPEND
     18  f83f		       ea		      nop
     17  f83f					      REPEND
     18  f840		       ea		      nop
     19  f841					      REPEND
     41  f841
     42  f841
     43  f841		       4c 55 f8 	      jmp	.endif_3
     44  f844				   .else_3
     45  f844		       a2 11		      ldx	#[ #RESP1 ]
     46  f846		       8e 1c f0 	      stx	[[KernelA_E_W + 1] + 0]
     47  f849		       be 84 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
     48  f84c		       8e 1f f0 	      stx	[[KernelA_G_W + 0] + 0]
     49  f84f		       be 85 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2Reg - NIBBLE_VAR_START],y
     50  f852		       8e 20 f0 	      stx	[[KernelA_G_W + 1] + 0]
     51  f855
     52  f855				   .endif_3
     53  f855		       0a		      asl
     54  f856		       90 0d		      bcc	.else_4
     55  f858
     56  f858				   .if_4
     57  f858		       a2 11		      ldx	#[ #RESP1 ]
     58  f85a		       8e 22 f0 	      stx	[[KernelA_H_W + 1] + 0]
      0  f85d					      sleep	9
      1  f85d				   .CYCLES    SET	9
      2  f85d
      3  f85d				  -	      IF	.CYCLES < 2
      4  f85d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f85d				  -	      ERR
      6  f85d					      ENDIF
      7  f85d
      8  f85d					      IF	.CYCLES & 1
      9  f85d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f85d		       04 00		      nop	0
     11  f85f				  -	      ELSE
     12  f85f				  -	      bit	VSYNC
     13  f85f					      ENDIF
     14  f85f				   .CYCLES    SET	.CYCLES - 3
     15  f85f					      ENDIF
     16  f85f
     17  f85f					      REPEAT	.CYCLES / 2
     18  f85f		       ea		      nop
     17  f85f					      REPEND
     18  f860		       ea		      nop
     17  f860					      REPEND
     18  f861		       ea		      nop
     19  f862					      REPEND
     60  f862
     61  f862
     62  f862		       4c 71 f8 	      jmp	.endif_4
     63  f865				   .else_4
     64  f865		       be 86 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
     65  f868		       8e 21 f0 	      stx	[[KernelA_H_W + 0] + 0]
     66  f86b		       be 87 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3Reg - NIBBLE_VAR_START],y
     67  f86e		       8e 22 f0 	      stx	[[KernelA_H_W + 1] + 0]
     68  f871
     69  f871				   .endif_4
    563  f871		       a5 c1		      lda	NibbleVar2
      0  f873					      NIBBLE_gem_kernel_a_2
      1  f873		       0a		      asl
      2  f874		       90 1e		      bcc	.else_1
      3  f876
      4  f876				   .if_1
      5  f876		       a2 85		      ldx	#[ #BC_STA ]
      6  f878		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
      7  f87b		       a2 11		      ldx	#[ #EMERALD_SP_RESET ]
      8  f87d		       8e 24 f0 	      stx	[[KernelA_I_W + 0] + 1]
      9  f880		       a2 85		      ldx	#[ #BC_STA ]
     10  f882		       8e 25 f0 	      stx	[[KernelA_J_W + 1] + 0]
     11  f885		       a2 0e		      ldx	#[ #PF1 ]
     12  f887		       8e 26 f0 	      stx	[[KernelA_J_W + 1] + 1]
     13  f88a		       a2 08		      ldx	#[ #BC_PHP ]
     14  f88c		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
      0  f88f					      sleep	3
      1  f88f				   .CYCLES    SET	3
      2  f88f
      3  f88f				  -	      IF	.CYCLES < 2
      4  f88f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f88f				  -	      ERR
      6  f88f					      ENDIF
      7  f88f
      8  f88f					      IF	.CYCLES & 1
      9  f88f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f88f		       04 00		      nop	0
     11  f891				  -	      ELSE
     12  f891				  -	      bit	VSYNC
     13  f891					      ENDIF
     14  f891				   .CYCLES    SET	.CYCLES - 3
     15  f891					      ENDIF
     16  f891
     17  f891				  -	      REPEAT	.CYCLES / 2
     18  f891				  -	      nop
     19  f891					      REPEND
     16  f891
     17  f891
     18  f891		       4c af f8 	      jmp	.endif_1
     19  f894				   .else_1
     20  f894		       a2 08		      ldx	#[ #BC_PHP ]
     21  f896		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
     22  f899		       a2 85		      ldx	#[ #BC_STA ]
     23  f89b		       8e 24 f0 	      stx	[[KernelA_J_W + 0] + 0]
     24  f89e		       a2 0e		      ldx	#[ #PF1 ]
     25  f8a0		       8e 25 f0 	      stx	[[KernelA_J_W + 0] + 1]
     26  f8a3		       be 88 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini4 - NIBBLE_VAR_START],y
     27  f8a6		       8e 26 f0 	      stx	[[KernelA_K_W + 0] + 0]
     28  f8a9		       a2 1c		      ldx	#[ #EMERALD_SP ]
     29  f8ab		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
      0  f8ae					      sleep	2
      1  f8ae				   .CYCLES    SET	2
      2  f8ae
      3  f8ae				  -	      IF	.CYCLES < 2
      4  f8ae				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f8ae				  -	      ERR
      6  f8ae					      ENDIF
      7  f8ae
      8  f8ae				  -	      IF	.CYCLES & 1
      9  f8ae				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f8ae				  -	      nop	0
     11  f8ae				  -	      ELSE
     12  f8ae				  -	      bit	VSYNC
     13  f8ae				  -	      ENDIF
     14  f8ae				  -.CYCLES    SET	.CYCLES - 3
     15  f8ae					      ENDIF
     16  f8ae
     17  f8ae					      REPEAT	.CYCLES / 2
     18  f8ae		       ea		      nop
     19  f8af					      REPEND
     31  f8af
     32  f8af				   .endif_1
     33  f8af		       be 89 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleMissile - NIBBLE_VAR_START],y
     34  f8b2		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     35  f8b5		       be 8a f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleVdel1 - NIBBLE_VAR_START],y
     36  f8b8		       8e 2f f0 	      stx	[[KernelA_VDEL1 - $100] + 0]
     37  f8bb		       be 8b f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGrp0 - NIBBLE_VAR_START],y
     38  f8be		       8e 07 f0 	      stx	[[KernelA_VDEL0 - $100] + 0]
     39  f8c1		       a2 ff		      ldx	#[ #$ff ]
     40  f8c3		       86 cf		      stx	[NibblePs + 0]
    565  f8c5		       4c 6a f9 	      jmp	.next
    566  f8c8				   .kernel_b
    567  f8c8		       a5 c0		      lda	NibbleVar1
      0  f8ca					      NIBBLE_gem_kernel_b_1
      1  f8ca		       0a		      asl
      2  f8cb		       90 2a		      bcc	.else_1
      3  f8cd
      4  f8cd				   .if_1
      5  f8cd		       a2 84		      ldx	#[ #BC_STY ]
      6  f8cf		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
      7  f8d2		       a2 11		      ldx	#[ #EMERALD_SP_RESET ]
      8  f8d4		       8e 1e f0 	      stx	[[KernelB_E_W + 1] + 0]
      9  f8d7		       a2 08		      ldx	#[ #BC_PHP ]
     10  f8d9		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     11  f8dc		       a2 85		      ldx	#[ #BC_STA ]
     12  f8de		       8e 20 f0 	      stx	[[KernelB_G_W + 0] + 0]
     13  f8e1		       a2 0e		      ldx	#[ #PF1 ]
     14  f8e3		       8e 21 f0 	      stx	[[KernelB_G_W + 1] + 0]
     15  f8e6		       be 86 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
     16  f8e9		       8e 22 f0 	      stx	[[KernelB_H_W + 0] + 0]
     17  f8ec		       a2 1c		      ldx	#[ #EMERALD_SP ]
     18  f8ee		       8e 23 f0 	      stx	[[KernelB_H_W + 1] + 0]
     19  f8f1		       2a		      rol
      0  f8f2					      sleep	3
      1  f8f2				   .CYCLES    SET	3
      2  f8f2
      3  f8f2				  -	      IF	.CYCLES < 2
      4  f8f2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f8f2				  -	      ERR
      6  f8f2					      ENDIF
      7  f8f2
      8  f8f2					      IF	.CYCLES & 1
      9  f8f2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f8f2		       04 00		      nop	0
     11  f8f4				  -	      ELSE
     12  f8f4				  -	      bit	VSYNC
     13  f8f4					      ENDIF
     14  f8f4				   .CYCLES    SET	.CYCLES - 3
     15  f8f4					      ENDIF
     16  f8f4
     17  f8f4				  -	      REPEAT	.CYCLES / 2
     18  f8f4				  -	      nop
     19  f8f4					      REPEND
     21  f8f4
     22  f8f4
     23  f8f4		       4c 40 f9 	      jmp	.endif_1
     24  f8f7				   .else_1
     25  f8f7		       0a		      asl
     26  f8f8		       90 27		      bcc	.else_2
     27  f8fa
     28  f8fa				   .if_2
     29  f8fa		       a2 84		      ldx	#[ #BC_STY ]
     30  f8fc		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     31  f8ff		       a2 11		      ldx	#[ #EMERALD_SP_RESET ]
     32  f901		       8e 1e f0 	      stx	[[KernelB_E_W + 1] + 0]
     33  f904		       be 84 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
     34  f907		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     35  f90a		       a2 1c		      ldx	#[ #EMERALD_SP ]
     36  f90c		       8e 20 f0 	      stx	[[KernelB_F_W + 2] + 0]
     37  f90f		       a2 85		      ldx	#[ #BC_STA ]
     38  f911		       8e 21 f0 	      stx	[[KernelB_G_W + 1] + 0]
     39  f914		       a2 0e		      ldx	#[ #PF1 ]
     40  f916		       8e 22 f0 	      stx	[[KernelB_G_W + 2] + 0]
     41  f919		       a2 08		      ldx	#[ #BC_PHP ]
     42  f91b		       8e 23 f0 	      stx	[[KernelB_H_W + 1] + 0]
     43  f91e
     44  f91e
     45  f91e		       4c 40 f9 	      jmp	.endif_2
     46  f921				   .else_2
     47  f921		       be 84 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
     48  f924		       8e 1e f0 	      stx	[[KernelB_F_W + 0] + 0]
     49  f927		       a2 1c		      ldx	#[ #EMERALD_SP ]
     50  f929		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     51  f92c		       be 86 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
     52  f92f		       8e 22 f0 	      stx	[[KernelB_H_W + 0] + 0]
     53  f932		       a2 1c		      ldx	#[ #EMERALD_SP ]
     54  f934		       8e 23 f0 	      stx	[[KernelB_H_W + 1] + 0]
      0  f937					      sleep	17
      1  f937				   .CYCLES    SET	17
      2  f937
      3  f937				  -	      IF	.CYCLES < 2
      4  f937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f937				  -	      ERR
      6  f937					      ENDIF
      7  f937
      8  f937					      IF	.CYCLES & 1
      9  f937					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f937		       04 00		      nop	0
     11  f939				  -	      ELSE
     12  f939				  -	      bit	VSYNC
     13  f939					      ENDIF
     14  f939				   .CYCLES    SET	.CYCLES - 3
     15  f939					      ENDIF
     16  f939
     17  f939					      REPEAT	.CYCLES / 2
     18  f939		       ea		      nop
     17  f939					      REPEND
     18  f93a		       ea		      nop
     17  f93a					      REPEND
     18  f93b		       ea		      nop
     17  f93b					      REPEND
     18  f93c		       ea		      nop
     17  f93c					      REPEND
     18  f93d		       ea		      nop
     17  f93d					      REPEND
     18  f93e		       ea		      nop
     17  f93e					      REPEND
     18  f93f		       ea		      nop
     19  f940					      REPEND
     56  f940
     57  f940				   .endif_2
     58  f940
     59  f940				   .endif_1
    569  f940		       a5 c1		      lda	NibbleVar2
      0  f942					      NIBBLE_gem_kernel_b_2
      1  f942		       a2 c2		      ldx	#[ NibbleGemini1 ]
      2  f944		       8e 1b f0 	      stx	[KernelB_D_W + 0]
      3  f947		       0a		      asl
      4  f948		       90 09		      bcc	.else_1
      5  f94a
      6  f94a				   .if_1
      7  f94a		       a2 e0		      ldx	#[ #RamFFByte ]
      8  f94c		       8e 1a f0 	      stx	[[KernelB_C - $100 + 1] + 0]
      0  f94f					      sleep	2
      1  f94f				   .CYCLES    SET	2
      2  f94f
      3  f94f				  -	      IF	.CYCLES < 2
      4  f94f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f94f				  -	      ERR
      6  f94f					      ENDIF
      7  f94f
      8  f94f				  -	      IF	.CYCLES & 1
      9  f94f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f94f				  -	      nop	0
     11  f94f				  -	      ELSE
     12  f94f				  -	      bit	VSYNC
     13  f94f				  -	      ENDIF
     14  f94f				  -.CYCLES    SET	.CYCLES - 3
     15  f94f					      ENDIF
     16  f94f
     17  f94f					      REPEAT	.CYCLES / 2
     18  f94f		       ea		      nop
     19  f950					      REPEND
     10  f950
     11  f950
     12  f950		       4c 5a f9 	      jmp	.endif_1
     13  f953				   .else_1
     14  f953		       a2 e2		      ldx	#[ #RamPF1Value ]
     15  f955		       8e 1a f0 	      stx	[[KernelB_C - $100 + 1] + 0]
      0  f958					      sleep	3
      1  f958				   .CYCLES    SET	3
      2  f958
      3  f958				  -	      IF	.CYCLES < 2
      4  f958				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f958				  -	      ERR
      6  f958					      ENDIF
      7  f958
      8  f958					      IF	.CYCLES & 1
      9  f958					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f958		       04 00		      nop	0
     11  f95a				  -	      ELSE
     12  f95a				  -	      bit	VSYNC
     13  f95a					      ENDIF
     14  f95a				   .CYCLES    SET	.CYCLES - 3
     15  f95a					      ENDIF
     16  f95a
     17  f95a				  -	      REPEAT	.CYCLES / 2
     18  f95a				  -	      nop
     19  f95a					      REPEND
     17  f95a
     18  f95a				   .endif_1
     19  f95a		       be 88 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini4 - NIBBLE_VAR_START],y
     20  f95d		       8e 26 f0 	      stx	[KernelB_J_W + 0]
     21  f960		       be 8b f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGrp0 - NIBBLE_VAR_START],y
     22  f963		       8e 07 f0 	      stx	[[KernelB_VDEL0 - $100] + 0]
     23  f966		       a2 00		      ldx	#[ #$00 ]
     24  f968		       86 cf		      stx	[NibblePs + 0]
    571  f96a				   .next
    572  f96a		       60		      rts
    573  f96b
    574  f96b
    575  f96b							; Populate Gemini array from level_for_game
    576  f96b
    577  f96b					      mac	gemini_populate
    578  f96b				   .TARGET    SET	{1}
    579  f96b					      ldx	#%00000011
    580  f96b					      .byte	$cb, $00	; axs #0 : x = a&x - #0
    581  f96b					      ldy	GEMINI_LOOKUP,x
    582  f96b					      sty	.TARGET
    583  f96b					      endm
    584  f96b
    585  f96b					      mac	gemini_populate_missile
    586  f96b				   .TARGET    SET	{1}
    587  f96b					      ldx	#%00000001
    588  f96b					      sax	.TARGET
    589  f96b					      endm
    590  f96b
    591  fa00		       00 00 00 00*	      align	256
    592  fa00
    593  fa00				   GeminiPopulate subroutine
    594  fa00		       a5 e7		      lda	level_for_game + 3
      0  fa02					      GEMINI_POPULATE	DO_GEMS_B + 5
      1  fa02				   .TARGET    SET	DO_GEMS_B + 5
      2  fa02		       a2 03		      ldx	#%00000011
      3  fa04		       cb 00		      .byte.b	$cb, $00
      4  fa06		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa09		       84 f5		      sty	.TARGET
    596  fa0b		       6a		      ror
    597  fa0c		       6a		      ror
      0  fa0d					      GEMINI_POPULATE	DO_GEMS_A + 5
      1  fa0d				   .TARGET    SET	DO_GEMS_A + 5
      2  fa0d		       a2 03		      ldx	#%00000011
      3  fa0f		       cb 00		      .byte.b	$cb, $00
      4  fa11		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa14		       84 ef		      sty	.TARGET
    599  fa16		       6a		      ror
    600  fa17		       6a		      ror
      0  fa18					      GEMINI_POPULATE	DO_GEMS_B + 4
      1  fa18				   .TARGET    SET	DO_GEMS_B + 4
      2  fa18		       a2 03		      ldx	#%00000011
      3  fa1a		       cb 00		      .byte.b	$cb, $00
      4  fa1c		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa1f		       84 f4		      sty	.TARGET
    602  fa21		       6a		      ror
    603  fa22		       6a		      ror
      0  fa23					      GEMINI_POPULATE	DO_GEMS_A + 4
      1  fa23				   .TARGET    SET	DO_GEMS_A + 4
      2  fa23		       a2 03		      ldx	#%00000011
      3  fa25		       cb 00		      .byte.b	$cb, $00
      4  fa27		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa2a		       84 ee		      sty	.TARGET
    605  fa2c							; ror
    606  fa2c							; ror
    607  fa2c
    608  fa2c		       a5 e6		      lda	level_for_game + 2
      0  fa2e					      GEMINI_POPULATE_MISSILE	DO_MISS_B
      1  fa2e				   .TARGET    SET	DO_MISS_B
      2  fa2e		       a2 01		      ldx	#%00000001
      3  fa30		       87 e9		      sax	.TARGET
    610  fa32		       6a		      ror
      0  fa33					      GEMINI_POPULATE	DO_GEMS_B + 3
      1  fa33				   .TARGET    SET	DO_GEMS_B + 3
      2  fa33		       a2 03		      ldx	#%00000011
      3  fa35		       cb 00		      .byte.b	$cb, $00
      4  fa37		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa3a		       84 f3		      sty	.TARGET
    612  fa3c		       6a		      ror
    613  fa3d		       6a		      ror
      0  fa3e					      GEMINI_POPULATE	DO_GEMS_A + 3
      1  fa3e				   .TARGET    SET	DO_GEMS_A + 3
      2  fa3e		       a2 03		      ldx	#%00000011
      3  fa40		       cb 00		      .byte.b	$cb, $00
      4  fa42		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa45		       84 ed		      sty	.TARGET
    615  fa47		       6a		      ror
    616  fa48		       6a		      ror
      0  fa49					      GEMINI_POPULATE	DO_GEMS_B + 2
      1  fa49				   .TARGET    SET	DO_GEMS_B + 2
      2  fa49		       a2 03		      ldx	#%00000011
      3  fa4b		       cb 00		      .byte.b	$cb, $00
      4  fa4d		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa50		       84 f2		      sty	.TARGET
    618  fa52		       6a		      ror
    619  fa53		       6a		      ror
    620  fa54
    621  fa54							; Join last bit and first bit
    622  fa54		       6a		      ror
    623  fa55		       a5 e5		      lda	level_for_game + 1
    624  fa57		       2a		      rol
      0  fa58					      GEMINI_POPULATE	DO_GEMS_A + 2
      1  fa58				   .TARGET    SET	DO_GEMS_A + 2
      2  fa58		       a2 03		      ldx	#%00000011
      3  fa5a		       cb 00		      .byte.b	$cb, $00
      4  fa5c		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa5f		       84 ec		      sty	.TARGET
    626  fa61
    627  fa61		       a5 e5		      lda	level_for_game + 1
    628  fa63		       6a		      ror
      0  fa64					      GEMINI_POPULATE_MISSILE	DO_MISS_A
      1  fa64				   .TARGET    SET	DO_MISS_A
      2  fa64		       a2 01		      ldx	#%00000001
      3  fa66		       87 e8		      sax	.TARGET
    630  fa68		       6a		      ror
      0  fa69					      GEMINI_POPULATE	DO_GEMS_B + 1
      1  fa69				   .TARGET    SET	DO_GEMS_B + 1
      2  fa69		       a2 03		      ldx	#%00000011
      3  fa6b		       cb 00		      .byte.b	$cb, $00
      4  fa6d		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa70		       84 f1		      sty	.TARGET
    632  fa72		       6a		      ror
    633  fa73		       6a		      ror
      0  fa74					      GEMINI_POPULATE	DO_GEMS_A + 1
      1  fa74				   .TARGET    SET	DO_GEMS_A + 1
      2  fa74		       a2 03		      ldx	#%00000011
      3  fa76		       cb 00		      .byte.b	$cb, $00
      4  fa78		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa7b		       84 eb		      sty	.TARGET
    635  fa7d		       6a		      ror
    636  fa7e		       6a		      ror
      0  fa7f					      GEMINI_POPULATE	DO_GEMS_B + 0
      1  fa7f				   .TARGET    SET	DO_GEMS_B + 0
      2  fa7f		       a2 03		      ldx	#%00000011
      3  fa81		       cb 00		      .byte.b	$cb, $00
      4  fa83		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa86		       84 f0		      sty	.TARGET
    638  fa88							; ror
    639  fa88							; ror
    640  fa88
    641  fa88		       a5 e4		      lda	level_for_game + 0
      0  fa8a					      GEMINI_POPULATE	DO_GEMS_A + 0
      1  fa8a				   .TARGET    SET	DO_GEMS_A + 0
      2  fa8a		       a2 03		      ldx	#%00000011
      3  fa8c		       cb 00		      .byte.b	$cb, $00
      4  fa8e		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa91		       84 ea		      sty	.TARGET
    643  fa93							; ror
    644  fa93							; ror
    645  fa93
    646  fa93		       60		      rts
    647  fa94				   gemini_populate_end
    648  fa94
    649  fa94							; FIXME this should be deleted
    650  fa94				   GeminiPopulateFull subroutine
    651  fa94		       a9 ff		      lda	#%11111111
      0  fa96					      GEMINI_POPULATE	DO_GEMS_B + 5
      1  fa96				   .TARGET    SET	DO_GEMS_B + 5
      2  fa96		       a2 03		      ldx	#%00000011
      3  fa98		       cb 00		      .byte.b	$cb, $00
      4  fa9a		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fa9d		       84 f5		      sty	.TARGET
    653  fa9f		       6a		      ror
    654  faa0		       6a		      ror
      0  faa1					      GEMINI_POPULATE	DO_GEMS_A + 5
      1  faa1				   .TARGET    SET	DO_GEMS_A + 5
      2  faa1		       a2 03		      ldx	#%00000011
      3  faa3		       cb 00		      .byte.b	$cb, $00
      4  faa5		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  faa8		       84 ef		      sty	.TARGET
    656  faaa		       6a		      ror
    657  faab		       6a		      ror
      0  faac					      GEMINI_POPULATE	DO_GEMS_B + 4
      1  faac				   .TARGET    SET	DO_GEMS_B + 4
      2  faac		       a2 03		      ldx	#%00000011
      3  faae		       cb 00		      .byte.b	$cb, $00
      4  fab0		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fab3		       84 f4		      sty	.TARGET
    659  fab5		       6a		      ror
    660  fab6		       6a		      ror
      0  fab7					      GEMINI_POPULATE	DO_GEMS_A + 4
      1  fab7				   .TARGET    SET	DO_GEMS_A + 4
      2  fab7		       a2 03		      ldx	#%00000011
      3  fab9		       cb 00		      .byte.b	$cb, $00
      4  fabb		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fabe		       84 ee		      sty	.TARGET
    662  fac0							; ror
    663  fac0							; ror
    664  fac0
    665  fac0		       a9 ff		      lda	#%11111111
      0  fac2					      GEMINI_POPULATE_MISSILE	DO_MISS_B
      1  fac2				   .TARGET    SET	DO_MISS_B
      2  fac2		       a2 01		      ldx	#%00000001
      3  fac4		       87 e9		      sax	.TARGET
    667  fac6		       6a		      ror
      0  fac7					      GEMINI_POPULATE	DO_GEMS_B + 3
      1  fac7				   .TARGET    SET	DO_GEMS_B + 3
      2  fac7		       a2 03		      ldx	#%00000011
      3  fac9		       cb 00		      .byte.b	$cb, $00
      4  facb		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  face		       84 f3		      sty	.TARGET
    669  fad0		       6a		      ror
    670  fad1		       6a		      ror
      0  fad2					      GEMINI_POPULATE	DO_GEMS_A + 3
      1  fad2				   .TARGET    SET	DO_GEMS_A + 3
      2  fad2		       a2 03		      ldx	#%00000011
      3  fad4		       cb 00		      .byte.b	$cb, $00
      4  fad6		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fad9		       84 ed		      sty	.TARGET
    672  fadb		       6a		      ror
    673  fadc		       6a		      ror
      0  fadd					      GEMINI_POPULATE	DO_GEMS_B + 2
      1  fadd				   .TARGET    SET	DO_GEMS_B + 2
      2  fadd		       a2 03		      ldx	#%00000011
      3  fadf		       cb 00		      .byte.b	$cb, $00
      4  fae1		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fae4		       84 f2		      sty	.TARGET
    675  fae6		       6a		      ror
    676  fae7		       6a		      ror
    677  fae8
    678  fae8							; Join last bit and first bit
    679  fae8		       6a		      ror
    680  fae9		       a9 ff		      lda	#%11111111
    681  faeb		       2a		      rol
      0  faec					      GEMINI_POPULATE	DO_GEMS_A + 2
      1  faec				   .TARGET    SET	DO_GEMS_A + 2
      2  faec		       a2 03		      ldx	#%00000011
      3  faee		       cb 00		      .byte.b	$cb, $00
      4  faf0		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  faf3		       84 ec		      sty	.TARGET
    683  faf5
    684  faf5		       a9 ff		      lda	#%11111111
    685  faf7		       6a		      ror
      0  faf8					      GEMINI_POPULATE_MISSILE	DO_MISS_A
      1  faf8				   .TARGET    SET	DO_MISS_A
      2  faf8		       a2 01		      ldx	#%00000001
      3  fafa		       87 e8		      sax	.TARGET
    687  fafc		       6a		      ror
      0  fafd					      GEMINI_POPULATE	DO_GEMS_B + 1
      1  fafd				   .TARGET    SET	DO_GEMS_B + 1
      2  fafd		       a2 03		      ldx	#%00000011
      3  faff		       cb 00		      .byte.b	$cb, $00
      4  fb01		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fb04		       84 f1		      sty	.TARGET
    689  fb06		       6a		      ror
    690  fb07		       6a		      ror
      0  fb08					      GEMINI_POPULATE	DO_GEMS_A + 1
      1  fb08				   .TARGET    SET	DO_GEMS_A + 1
      2  fb08		       a2 03		      ldx	#%00000011
      3  fb0a		       cb 00		      .byte.b	$cb, $00
      4  fb0c		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fb0f		       84 eb		      sty	.TARGET
    692  fb11		       6a		      ror
    693  fb12		       6a		      ror
      0  fb13					      GEMINI_POPULATE	DO_GEMS_B + 0
      1  fb13				   .TARGET    SET	DO_GEMS_B + 0
      2  fb13		       a2 03		      ldx	#%00000011
      3  fb15		       cb 00		      .byte.b	$cb, $00
      4  fb17		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fb1a		       84 f0		      sty	.TARGET
    695  fb1c							; ror
    696  fb1c							; ror
    697  fb1c
    698  fb1c		       a9 ff		      lda	#%11111111
      0  fb1e					      GEMINI_POPULATE	DO_GEMS_A + 0
      1  fb1e				   .TARGET    SET	DO_GEMS_A + 0
      2  fb1e		       a2 03		      ldx	#%00000011
      3  fb20		       cb 00		      .byte.b	$cb, $00
      4  fb22		       bc 30 fb 	      ldy	GEMINI_LOOKUP,x
      5  fb25		       84 ea		      sty	.TARGET
    700  fb27							; ror
    701  fb27							; ror
    702  fb27
    703  fb27		       60		      rts
    704  fb28
    705  fb28
    706  fb30		       00 00 00 00*	      align	16
    707  fb30
    708  fb30				   GEMINI_LOOKUP
    709  fb30		       00 60 06 66	      .byte.b	G00, G01, G10, G11
    710  fb34
    711  fb34				   SHARD_LUT_RF1
    712  fb34		       00		      .byte.b	#0
    713  fb35				   SHARD_LUT_VD1
    714  fb35		       00		      .byte.b	#0
    715  fb36
------- FILE main.s
------- FILE game_state.s LEVEL 2 PASS 2
      0  fb36					      include	"game_state.s"
      1  fb36							; Perform a left rotation on the 32 bit number at
      2  fb36							; location VLA and store the result at location
      3  fb36							; RES. If VLA and RES are the same then the
      4  fb36							; operation is applied directly to the memory,
      5  fb36							; otherwise it is done in the accumulator.
      6  fb36							;
      7  fb36							; On exit: A = ??, X & Y are unchanged.
      8  fb36
      9  fb36							;http://www.obelisk.me.uk/6502/maclib.inc but reversed
     10  fb36					      mac	_ror32
     11  fb36				   VLA	      EQU	{1}
     12  fb36				   RES	      EQU	{2}
     13  fb36					      IF	VLA != RES
     14  fb36					      LDA	VLA+0
     15  fb36					      ROR	A
     16  fb36					      STA	RES+0
     17  fb36					      LDA	VLA+1
     18  fb36					      ROR	A
     19  fb36					      STA	RES+1
     20  fb36					      LDA	VLA+2
     21  fb36					      ROR	A
     22  fb36					      STA	RES+2
     23  fb36					      LDA	VLA+3
     24  fb36					      ROR	A
     25  fb36					      STA	RES+3
     26  fb36					      ELSE
     27  fb36					      ROR	VLA+0
     28  fb36					      ROR	VLA+1
     29  fb36					      ROR	VLA+2
     30  fb36					      ROR	VLA+3
     31  fb36					      ENDIF
     32  fb36					      ENDM
     33  fb36							; Add two 32 bit numbers together and store the
     34  fb36							; result in another memory location. RES may be
     35  fb36							; the same as either VLA or VLB.
     36  fb36							;
     37  fb36							; On exit: A = ??, X & Y are unchanged.
     38  fb36
     39  fb36				   game_state_adder
     40  fb36		       00		      .byte.b	#$0
     41  fb37		       00		      .byte.b	#$0
     42  fb38		       00		      .byte.b	#$0
     43  fb39		       10		      .byte.b	#%10000
     44  fb3a
     45  fb3a					      mac	_add32
     46  fb3a				   .VLA       EQU	{1}
     47  fb3a				   .VLB       EQU	{2}
     48  fb3a				   .RES       EQU	{3}
     49  fb3a					      CLC
     50  fb3a					      LDA	.VLA+3
     51  fb3a					      ADC	.VLB+3
     52  fb3a					      STA	.RES+3
     53  fb3a					      LDA	.VLA+2
     54  fb3a					      ADC	.VLB+2
     55  fb3a					      STA	.RES+2
     56  fb3a					      LDA	.VLA+1
     57  fb3a					      ADC	.VLB+1
     58  fb3a					      STA	.RES+1
     59  fb3a					      LDA	.VLA+0
     60  fb3a					      ADC	.VLB+0
     61  fb3a					      STA	.RES+0
     62  fb3a					      ENDM
     63  fb3a
     64  fb3a				   game_state_setup
     65  fb3a							; Set up the level
     66  fb3a		       a9 fb		      lda	#%11111011
     67  fb3c		       85 e4		      sta	[level_for_game + 0]
     68  fb3e		       a9 ff		      lda	#%11111111
     69  fb40		       85 e5		      sta	[level_for_game + 1]
     70  fb42		       a9 ff		      lda	#%11111111
     71  fb44		       85 e6		      sta	[level_for_game + 2]
     72  fb46		       a9 ff		      lda	#%11111111
     73  fb48		       85 e7		      sta	[level_for_game + 3]
     74  fb4a		       60		      rts
     75  fb4b
     76  fb50		       00 00 00 00*	      align	16
     77  fb50				   game_state_mask
     78  fb50		       7f		      .byte.b	#%01111111
     79  fb51		       bf		      .byte.b	#%10111111
     80  fb52		       df		      .byte.b	#%11011111
     81  fb53		       ef		      .byte.b	#%11101111
     82  fb54		       f7		      .byte.b	#%11110111
     83  fb55		       fb		      .byte.b	#%11111011
     84  fb56		       fd		      .byte.b	#%11111101
     85  fb57		       fe		      .byte.b	#%11111110
     86  fb58
     87  fb58				   game_state_tick subroutine
     88  fb58							; jsr game_state_setup
     89  fb58
     90  fb58							; Get index [0, 25]
     91  fb58		       18		      clc
     92  fb59		       a5 d7		      lda	XPos
     93  fb5b		       e9 02		      sbc	#2
     94  fb5d		       4a		      lsr
     95  fb5e		       4a		      lsr
     96  fb5f		       85 d2		      sta	Temp
     97  fb61
     98  fb61							; Load bit offset
     99  fb61		       29 07		      and	#%111
    100  fb63		       a8		      tay
    101  fb64		       b9 50 fb 	      lda	game_state_mask,y
    102  fb67		       85 d3		      sta	Temp2
    103  fb69
    104  fb69							; Load sprite offset
    105  fb69		       a5 d2		      lda	Temp
    106  fb6b		       4a		      lsr
    107  fb6c		       4a		      lsr
    108  fb6d		       4a		      lsr
    109  fb6e		       a8		      tay
    110  fb6f		       a5 d3		      lda	Temp2
    111  fb71		       39 e4 00 	      and	level_for_game,y
    112  fb74		       99 e4 00 	      sta	level_for_game,y
    113  fb77		       60		      rts
    114  fb78
    115  fb78				   game_state_tick_1 subroutine
      0  fb78					      _ADD32	level_for_game, game_state_adder, level_for_game
      1  fb78		       00 e4	   .VLA       EQU	level_for_game
      2  fb78		       fb 36	   .VLB       EQU	game_state_adder
      3  fb78		       00 e4	   .RES       EQU	level_for_game
      4  fb78		       18		      CLC
      5  fb79		       a5 e7		      LDA	.VLA+3
      6  fb7b		       6d 39 fb 	      ADC	.VLB+3
      7  fb7e		       85 e7		      STA	.RES+3
      8  fb80		       a5 e6		      LDA	.VLA+2
      9  fb82		       6d 38 fb 	      ADC	.VLB+2
     10  fb85		       85 e6		      STA	.RES+2
     11  fb87		       a5 e5		      LDA	.VLA+1
     12  fb89		       6d 37 fb 	      ADC	.VLB+1
     13  fb8c		       85 e5		      STA	.RES+1
     14  fb8e		       a5 e4		      LDA	.VLA+0
     15  fb90		       6d 36 fb 	      ADC	.VLB+0
     16  fb93		       85 e4		      STA	.RES+0
    117  fb95		       60		      rts
    118  fb96
    119  fb96							; game_state_tick:
    120  fb96							;     lda FrameCount
    121  fb96							;     and #%111
    122  fb96							;     bne .skiprotate
    123  fb96							;     lda level_for_game + 3
    124  fb96							;     ror
    125  fb96							; .rollall:
    126  fb96							;     _ROR32 level_for_game, level_for_game
    127  fb96
    128  fb96							;     lda #%11101111
    129  fb96							;     cmp [level_for_game + 3]
    130  fb96							;     bne .skiprotate
    131  fb96							;     jmp game_state_setup
    132  fb96							; .skiprotate:
    133  fb96							;     rts
------- FILE main.s
------- FILE kernel_border.s LEVEL 2 PASS 2
      0  fb96					      include	"kernel_border.s"
      1  fb96							; Visible Kernel
      2  fb96
      3  fb96				   KernelBorder subroutine
      4  fb96		       85 02		      sta	WSYNC	; ??? Is this needed?
      5  fb98
      6  fb98							; First HMOVE
      7  fb98		       85 2a		      sta	HMOVE
      8  fb9a
      9  fb9a							; Border top
     10  fb9a		       a9 00		      lda	#0
     11  fb9c		       85 08		      sta	COLUPF
     12  fb9e		       85 0e		      sta	PF1
     13  fba0		       85 0f		      sta	PF2
     14  fba2		       a9 02		      lda	#SIGNAL_LINE
     15  fba4		       85 09		      sta	COLUBK
     16  fba6
     17  fba6					      REPEAT	6
     18  fba6		       85 02		      sta	WSYNC
     17  fba6					      REPEND
     18  fba8		       85 02		      sta	WSYNC
     17  fba8					      REPEND
     18  fbaa		       85 02		      sta	WSYNC
     17  fbaa					      REPEND
     18  fbac		       85 02		      sta	WSYNC
     17  fbac					      REPEND
     18  fbae		       85 02		      sta	WSYNC
     17  fbae					      REPEND
     18  fbb0		       85 02		      sta	WSYNC
     19  fbb2					      REPEND
     20  fbb2
     21  fbb2		       a9 00		      lda	#0
     22  fbb4		       85 09		      sta	COLUBK
     23  fbb6		       85 02		      sta	WSYNC
     24  fbb8
     25  fbb8							; Start top border
     26  fbb8				   border_top
     27  fbb8							; Make the playfield solid.
     28  fbb8		       a9 3f		      lda	#%00111111
     29  fbba		       85 0e		      sta	PF1
     30  fbbc		       a9 ff		      lda	#%11111111
     31  fbbe		       85 0f		      sta	PF2
     32  fbc0
     33  fbc0		       a9 42		      lda	#COL_BG
     34  fbc2		       a0 00		      ldy	#0
     35  fbc4
     36  fbc4							; X_XXXX_XX
     37  fbc4							; Commented lines removed to save on space.
     38  fbc4		       85 08		      sta	COLUPF
     39  fbc6		       85 02		      sta	WSYNC
     40  fbc8		       84 08		      sty	COLUPF
     41  fbca		       85 02		      sta	WSYNC
     42  fbcc		       85 08		      sta	COLUPF
     43  fbce		       85 02		      sta	WSYNC
     44  fbd0							; sta COLUPF
     45  fbd0		       85 02		      sta	WSYNC
     46  fbd2							; sta COLUPF
     47  fbd2		       85 02		      sta	WSYNC
     48  fbd4		       84 08		      sty	COLUPF
     49  fbd6		       85 02		      sta	WSYNC
     50  fbd8		       85 08		      sta	COLUPF
     51  fbda
     52  fbda		       85 02		      sta	WSYNC
     53  fbdc							; sta COLUPF
     54  fbdc
     55  fbdc				   PlayArea
     56  fbdc							; PF is now the playing area
      0  fbdc					      ASSERT_RUNTIME	"_scycles == #0"
      1  fbdc				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fbdc  && !(  _scycles == #0  ) }
      2  fbdc					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  fbdc					      sleep	61
      1  fbdc				   .CYCLES    SET	61
      2  fbdc
      3  fbdc				  -	      IF	.CYCLES < 2
      4  fbdc				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbdc				  -	      ERR
      6  fbdc					      ENDIF
      7  fbdc
      8  fbdc					      IF	.CYCLES & 1
      9  fbdc					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbdc		       04 00		      nop	0
     11  fbde				  -	      ELSE
     12  fbde				  -	      bit	VSYNC
     13  fbde					      ENDIF
     14  fbde				   .CYCLES    SET	.CYCLES - 3
     15  fbde					      ENDIF
     16  fbde
     17  fbde					      REPEAT	.CYCLES / 2
     18  fbde		       ea		      nop
     17  fbde					      REPEND
     18  fbdf		       ea		      nop
     17  fbdf					      REPEND
     18  fbe0		       ea		      nop
     17  fbe0					      REPEND
     18  fbe1		       ea		      nop
     17  fbe1					      REPEND
     18  fbe2		       ea		      nop
     17  fbe2					      REPEND
     18  fbe3		       ea		      nop
     17  fbe3					      REPEND
     18  fbe4		       ea		      nop
     17  fbe4					      REPEND
     18  fbe5		       ea		      nop
     17  fbe5					      REPEND
     18  fbe6		       ea		      nop
     17  fbe6					      REPEND
     18  fbe7		       ea		      nop
     17  fbe7					      REPEND
     18  fbe8		       ea		      nop
     17  fbe8					      REPEND
     18  fbe9		       ea		      nop
     17  fbe9					      REPEND
     18  fbea		       ea		      nop
     17  fbea					      REPEND
     18  fbeb		       ea		      nop
     17  fbeb					      REPEND
     18  fbec		       ea		      nop
     17  fbec					      REPEND
     18  fbed		       ea		      nop
     17  fbed					      REPEND
     18  fbee		       ea		      nop
     17  fbee					      REPEND
     18  fbef		       ea		      nop
     17  fbef					      REPEND
     18  fbf0		       ea		      nop
     17  fbf0					      REPEND
     18  fbf1		       ea		      nop
     17  fbf1					      REPEND
     18  fbf2		       ea		      nop
     17  fbf2					      REPEND
     18  fbf3		       ea		      nop
     17  fbf3					      REPEND
     18  fbf4		       ea		      nop
     17  fbf4					      REPEND
     18  fbf5		       ea		      nop
     17  fbf5					      REPEND
     18  fbf6		       ea		      nop
     17  fbf6					      REPEND
     18  fbf7		       ea		      nop
     17  fbf7					      REPEND
     18  fbf8		       ea		      nop
     17  fbf8					      REPEND
     18  fbf9		       ea		      nop
     17  fbf9					      REPEND
     18  fbfa		       ea		      nop
     19  fbfb					      REPEND
     59  fbfb		       a9 00		      lda	#%00000000
     60  fbfd		       85 0d		      sta	PF0
     61  fbff		       a9 20		      lda	#%00100000
     62  fc01		       85 0e		      sta	PF1
     63  fc03		       a9 00		      lda	#%00000000
     64  fc05		       85 0f		      sta	PF2
      0  fc07					      ASSERT_RUNTIME	"_scycles == #0"
      1  fc07				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fc07  && !(  _scycles == #0  ) }
      2  fc07					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  fc07					      sleep	7
      1  fc07				   .CYCLES    SET	7
      2  fc07
      3  fc07				  -	      IF	.CYCLES < 2
      4  fc07				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc07				  -	      ERR
      6  fc07					      ENDIF
      7  fc07
      8  fc07					      IF	.CYCLES & 1
      9  fc07					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc07		       04 00		      nop	0
     11  fc09				  -	      ELSE
     12  fc09				  -	      bit	VSYNC
     13  fc09					      ENDIF
     14  fc09				   .CYCLES    SET	.CYCLES - 3
     15  fc09					      ENDIF
     16  fc09
     17  fc09					      REPEAT	.CYCLES / 2
     18  fc09		       ea		      nop
     17  fc09					      REPEND
     18  fc0a		       ea		      nop
     19  fc0b					      REPEND
     67  fc0b		       4c 3d fc 	      jmp	row_start
     68  fc0e							; enter row on cycle 10.
     69  fc0e
     70  fc0e							; reset the background for bottom of playfield
     71  fc0e				   border_bottom
     72  fc0e							;sta WSYNC
     73  fc0e
     74  fc0e							; Form the bottom of the level frame.
     75  fc0e		       a9 3f		      lda	#%00111111
     76  fc10		       85 0e		      sta	PF1
     77  fc12		       a9 ff		      lda	#%11111111
     78  fc14		       85 0f		      sta	PF2
     79  fc16
     80  fc16							; Clear all sprites.
     81  fc16		       a9 00		      lda	#0
     82  fc18		       85 1c		      sta	EMERALD_SP
     83  fc1a		       85 1b		      sta	JET_SP
     84  fc1c		       85 1e		      sta	EMERALD_MI_ENABLE
     85  fc1e
     86  fc1e		       a9 42		      lda	#COL_BG
     87  fc20		       a0 00		      ldy	#0
     88  fc22		       85 02		      sta	WSYNC
     89  fc24
     90  fc24		       84 08		      sty	COLUPF
     91  fc26		       85 02		      sta	WSYNC
     92  fc28
     93  fc28		       85 08		      sta	COLUPF
     94  fc2a		       85 02		      sta	WSYNC
     95  fc2c
     96  fc2c		       85 02		      sta	WSYNC
     97  fc2e
     98  fc2e		       85 02		      sta	WSYNC
     99  fc30
    100  fc30		       84 08		      sty	COLUPF
    101  fc32		       85 02		      sta	WSYNC
    102  fc34
    103  fc34		       85 08		      sta	COLUPF
    104  fc36		       85 02		      sta	WSYNC
    105  fc38		       85 02		      sta	WSYNC
    106  fc3a		       4c 4d f4 	      jmp	FrameEnd
------- FILE main.s
------- FILE kernel_row.s LEVEL 2 PASS 2
      0  fc3d					      include	"kernel_row.s"
      1  fc3d							; Frame Start
      2  fc3d
      3  fc3d							; Macros for calculating sprite values (GRPx).
      4  fc3d
      5  fc3d							; mac jet_spritedata_calc
      6  fc3d							;
      7  fc3d							; loads the offset from Frame0 in Y, and the sprite value in A, and stores it in
      8  fc3d							; GRP0.
      9  fc3d					      mac	jet_spritedata_calc
     10  fc3d					      dec	RamRowJetpackIndex
     11  fc3d					      ldy	RamRowJetpackIndex
     12  fc3d					      ldx	Frame0,Y
     13  fc3d					      stx	JET_SP
     14  fc3d					      endm
     15  fc3d
     16  fc3d				   row_start
     17  fc3d
     18  fc3d							; [scanline 1]
     19  fc3d				   row_1
     20  fc3d							; Enter after scanline starts on row "9" and wraps
      0  fc3d					      ASSERT_RUNTIME	"_scycles == #10"
      1  fc3d				   .COND      SET	"_scycles == #10"
 ASSERT: breakif { pc== $fc3d  && !(  _scycles == #10  ) }
      2  fc3d					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     22  fc3d
     23  fc3d							; Load sprite details
     24  fc3d		       a9 0f		      lda	[#SPRITE_HEIGHT + #7]
     25  fc3f		       c5 d6		      cmp	SpriteEnd	; 5c
     26  fc41		       a9 00		      lda	#0	; 2c
     27  fc43							; constant 6c: if carry set, load SpriteEnd into y
     28  fc43		       b0 01		      .byte.b	$b0, $01	; 2c / 3c (taken)  : bcs +01 (skipping 1-byte bit instr)
     29  fc45		       0c		      .byte.b	$0c	; 4c / 0c		: bit (skip next two bytes)
     30  fc46		       a5 d6		      lda	SpriteEnd
     31  fc48		       69 08		      adc	#8
     32  fc4a		       85 e3		      sta	RamRowJetpackIndex
     33  fc4c
     34  fc4c							; Load sprite
     35  fc4c		       c6 e3		      dec	RamRowJetpackIndex
     36  fc4e		       a4 e3		      ldy	RamRowJetpackIndex
     37  fc50		       be 00 ff 	      ldx	Frame0,Y
     38  fc53		       86 1b		      stx	JET_SP
     39  fc55
     40  fc55							; TODO assert cycle is not in visible range!
     41  fc55
     42  fc55							; Decrease SpriteEnd
     43  fc55		       38		      sec
     44  fc56		       a5 d6		      lda	SpriteEnd
     45  fc58		       e9 08		      sbc	#8
     46  fc5a		       85 d6		      sta	SpriteEnd
     47  fc5c
     48  fc5c							; Idle.
     49  fc5c		       85 02		      sta	WSYNC
     50  fc5e							; sleep 33
     51  fc5e
      0  fc5e					      ASSERT_RUNTIME	"_scycles == #0"
      1  fc5e				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fc5e  && !(  _scycles == #0  ) }
      2  fc5e					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     53  fc5e
     54  fc5e							; [scanline 2]
     55  fc5e				   row_2
      0  fc5e					      jet_spritedata_calc
      1  fc5e		       c6 e3		      dec	RamRowJetpackIndex
      2  fc60		       a4 e3		      ldy	RamRowJetpackIndex
      3  fc62		       be 00 ff 	      ldx	Frame0,Y
      4  fc65		       86 1b		      stx	JET_SP
      0  fc67					      sleep	5
      1  fc67				   .CYCLES    SET	5
      2  fc67
      3  fc67				  -	      IF	.CYCLES < 2
      4  fc67				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc67				  -	      ERR
      6  fc67					      ENDIF
      7  fc67
      8  fc67					      IF	.CYCLES & 1
      9  fc67					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc67		       04 00		      nop	0
     11  fc69				  -	      ELSE
     12  fc69				  -	      bit	VSYNC
     13  fc69					      ENDIF
     14  fc69				   .CYCLES    SET	.CYCLES - 3
     15  fc69					      ENDIF
     16  fc69
     17  fc69					      REPEAT	.CYCLES / 2
     18  fc69		       ea		      nop
     19  fc6a					      REPEND
     58  fc6a
     59  fc6a							; Black out playfield
     60  fc6a							; TODO This should be done with playfield pixels, not color.
     61  fc6a		       a9 00		      lda	#0
     62  fc6c		       85 08		      sta	COLUPF
     63  fc6e
     64  fc6e							; [[[Nibble VM.]]]
      0  fc6e					      sleep	25
      1  fc6e				   .CYCLES    SET	25
      2  fc6e
      3  fc6e				  -	      IF	.CYCLES < 2
      4  fc6e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc6e				  -	      ERR
      6  fc6e					      ENDIF
      7  fc6e
      8  fc6e					      IF	.CYCLES & 1
      9  fc6e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc6e		       04 00		      nop	0
     11  fc70				  -	      ELSE
     12  fc70				  -	      bit	VSYNC
     13  fc70					      ENDIF
     14  fc70				   .CYCLES    SET	.CYCLES - 3
     15  fc70					      ENDIF
     16  fc70
     17  fc70					      REPEAT	.CYCLES / 2
     18  fc70		       ea		      nop
     17  fc70					      REPEND
     18  fc71		       ea		      nop
     17  fc71					      REPEND
     18  fc72		       ea		      nop
     17  fc72					      REPEND
     18  fc73		       ea		      nop
     17  fc73					      REPEND
     18  fc74		       ea		      nop
     17  fc74					      REPEND
     18  fc75		       ea		      nop
     17  fc75					      REPEND
     18  fc76		       ea		      nop
     17  fc76					      REPEND
     18  fc77		       ea		      nop
     17  fc77					      REPEND
     18  fc78		       ea		      nop
     17  fc78					      REPEND
     18  fc79		       ea		      nop
     17  fc79					      REPEND
     18  fc7a		       ea		      nop
     19  fc7b					      REPEND
     66  fc7b
     67  fc7b							; Load PF1 value
     68  fc7b		       a9 3d		      lda	#%00111101
     69  fc7d		       85 e2		      sta	RamPF1Value
     70  fc7f
     71  fc7f		       a9 04		      lda	#4
     72  fc81		       8d 96 02 	      sta	TIM64T
     73  fc84
     74  fc84							; Set stack pointer for PHP use from NibblePhp.
     75  fc84							; FIXME need to fix these and other Nibble references
     76  fc84		       a6 ce		      ldx	NibblePhp
     77  fc86		       ca		      dex
     78  fc87		       9a		      txs
     79  fc88
     80  fc88							; Enable playfield at end of scanline
     81  fc88		       a9 42		      lda	#COL_BG
     82  fc8a		       85 08		      sta	COLUPF
     83  fc8c
     84  fc8c							; Set overflow flag
     85  fc8c		       24 cf		      bit	NibblePs
     86  fc8e
      0  fc8e					      ASSERT_RUNTIME	"_scycles == #0"
      1  fc8e				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fc8e  && !(  _scycles == #0  ) }
      2  fc8e					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     88  fc8e
     89  fc8e							; [scanline 3]
     90  fc8e				   row_3
     91  fc8e							; Current row and next two rows.
     92  fc8e		       a4 e3		      ldy	RamRowJetpackIndex
     93  fc90		       88		      dey
     94  fc91		       be 00 ff 	      ldx	Frame0,Y
     95  fc94		       86 1b		      stx	JET_SP
     96  fc96		       88		      dey
     97  fc97		       be 00 ff 	      ldx	Frame0,Y
     98  fc9a		       86 d0		      stx	RamKernelGrp0
     99  fc9c		       88		      dey
    100  fc9d		       be 00 ff 	      ldx	Frame0,Y
    101  fca0		       8e 03 f0 	      stx	[KernelA_GRP0 - $100]
    102  fca3		       84 e3		      sty	RamRowJetpackIndex
    103  fca5
    104  fca5							; [[[Nibble VM.]]]
    105  fca5							; Idle.
      0  fca5					      sleep	22
      1  fca5				   .CYCLES    SET	22
      2  fca5
      3  fca5				  -	      IF	.CYCLES < 2
      4  fca5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fca5				  -	      ERR
      6  fca5					      ENDIF
      7  fca5
      8  fca5				  -	      IF	.CYCLES & 1
      9  fca5				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fca5				  -	      nop	0
     11  fca5				  -	      ELSE
     12  fca5				  -	      bit	VSYNC
     13  fca5				  -	      ENDIF
     14  fca5				  -.CYCLES    SET	.CYCLES - 3
     15  fca5					      ENDIF
     16  fca5
     17  fca5					      REPEAT	.CYCLES / 2
     18  fca5		       ea		      nop
     17  fca5					      REPEND
     18  fca6		       ea		      nop
     17  fca6					      REPEND
     18  fca7		       ea		      nop
     17  fca7					      REPEND
     18  fca8		       ea		      nop
     17  fca8					      REPEND
     18  fca9		       ea		      nop
     17  fca9					      REPEND
     18  fcaa		       ea		      nop
     17  fcaa					      REPEND
     18  fcab		       ea		      nop
     17  fcab					      REPEND
     18  fcac		       ea		      nop
     17  fcac					      REPEND
     18  fcad		       ea		      nop
     17  fcad					      REPEND
     18  fcae		       ea		      nop
     17  fcae					      REPEND
     18  fcaf		       ea		      nop
     19  fcb0					      REPEND
    107  fcb0
    108  fcb0							; Setup for kernel
    109  fcb0		       38		      sec		; clear carry bit
    110  fcb1		       a6 cc		      ldx	NibbleX
    111  fcb3		       a4 cd		      ldy	NibbleY
    112  fcb5
    113  fcb5							; Jump immediately into scanlines 4-5 aka "kernel_gem"
    114  fcb5		       a5 ca		      lda	NibbleVdel1
    115  fcb7		       85 1c		      sta	EMERALD_SP
    116  fcb9		       a5 d0		      lda	RamKernelGrp0	; Load sprite 2 into A
    117  fcbb							; [scanline 4]
    118  fcbb							; [scanline 5]
      0  fcbb					      ASSERT_RUNTIME	"_scycles == #73"
      1  fcbb				   .COND      SET	"_scycles == #73"
 ASSERT: breakif { pc== $fcbb  && !(  _scycles == #73  ) }
      2  fcbb					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    120  fcbb		       4c 04 f1 	      jmp	CBSRAM_KERNEL_ENTRY
    121  fcbe
    122  fcbe							; [scanline 6]
    123  fcbe
    124  fcbe				   row_after_kernel
    125  fcbe				   row_6
      0  fcbe					      ASSERT_RUNTIME	"_scycles == #0"
      1  fcbe				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fcbe  && !(  _scycles == #0  ) }
      2  fcbe					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    127  fcbe
    128  fcbe							; Cleanup from the kernel.
    129  fcbe		       a9 00		      lda	#0
    130  fcc0		       85 1e		      sta	EMERALD_MI_ENABLE
    131  fcc2		       85 1c		      sta	EMERALD_SP
    132  fcc4		       85 08		      sta	COLUPF
    133  fcc6
    134  fcc6		       a9 20		      lda	#%00100000
    135  fcc8		       85 0e		      sta	PF1
    136  fcca
      0  fcca					      jet_spritedata_calc
      1  fcca		       c6 e3		      dec	RamRowJetpackIndex
      2  fccc		       a4 e3		      ldy	RamRowJetpackIndex
      3  fcce		       be 00 ff 	      ldx	Frame0,Y
      4  fcd1		       86 1b		      stx	JET_SP
    138  fcd3
    139  fcd3							; Load nibble index.
    140  fcd3		       a0 00		      ldy	#0
    141  fcd5
    142  fcd5							; Idle.
    143  fcd5		       85 02		      sta	WSYNC
    144  fcd7
    145  fcd7							; [scanline 7]
    146  fcd7				   row_7
      0  fcd7					      ASSERT_RUNTIME	"_scycles == #0"
      1  fcd7				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fcd7  && !(  _scycles == #0  ) }
      2  fcd7					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    148  fcd7
    149  fcd7							; FIXME this should be enabled!
    150  fcd7							; jet_spritedata_calc
    151  fcd7
    152  fcd7		       a9 42		      lda	#COL_BG
    153  fcd9		       85 08		      sta	COLUPF
    154  fcdb
    155  fcdb							; Idle.
    156  fcdb							; sleep 71
    157  fcdb
    158  fcdb							; Run Kernel.
    159  fcdb		       a5 c1		      lda	NibbleVar2
      0  fcdd					      NIBBLE_gem_kernel_a_2
      1  fcdd		       0a		      asl
      2  fcde		       90 1e		      bcc	.else_1
      3  fce0
      4  fce0				   .if_1
      5  fce0		       a2 85		      ldx	#[ #BC_STA ]
      6  fce2		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
      7  fce5		       a2 11		      ldx	#[ #EMERALD_SP_RESET ]
      8  fce7		       8e 24 f0 	      stx	[[KernelA_I_W + 0] + 1]
      9  fcea		       a2 85		      ldx	#[ #BC_STA ]
     10  fcec		       8e 25 f0 	      stx	[[KernelA_J_W + 1] + 0]
     11  fcef		       a2 0e		      ldx	#[ #PF1 ]
     12  fcf1		       8e 26 f0 	      stx	[[KernelA_J_W + 1] + 1]
     13  fcf4		       a2 08		      ldx	#[ #BC_PHP ]
     14  fcf6		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
      0  fcf9					      sleep	3
      1  fcf9				   .CYCLES    SET	3
      2  fcf9
      3  fcf9				  -	      IF	.CYCLES < 2
      4  fcf9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fcf9				  -	      ERR
      6  fcf9					      ENDIF
      7  fcf9
      8  fcf9					      IF	.CYCLES & 1
      9  fcf9					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fcf9		       04 00		      nop	0
     11  fcfb				  -	      ELSE
     12  fcfb				  -	      bit	VSYNC
     13  fcfb					      ENDIF
     14  fcfb				   .CYCLES    SET	.CYCLES - 3
     15  fcfb					      ENDIF
     16  fcfb
     17  fcfb				  -	      REPEAT	.CYCLES / 2
     18  fcfb				  -	      nop
     19  fcfb					      REPEND
     16  fcfb
     17  fcfb
     18  fcfb		       4c 19 fd 	      jmp	.endif_1
     19  fcfe				   .else_1
     20  fcfe		       a2 08		      ldx	#[ #BC_PHP ]
     21  fd00		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
     22  fd03		       a2 85		      ldx	#[ #BC_STA ]
     23  fd05		       8e 24 f0 	      stx	[[KernelA_J_W + 0] + 0]
     24  fd08		       a2 0e		      ldx	#[ #PF1 ]
     25  fd0a		       8e 25 f0 	      stx	[[KernelA_J_W + 0] + 1]
     26  fd0d		       be 88 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini4 - NIBBLE_VAR_START],y
     27  fd10		       8e 26 f0 	      stx	[[KernelA_K_W + 0] + 0]
     28  fd13		       a2 1c		      ldx	#[ #EMERALD_SP ]
     29  fd15		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
      0  fd18					      sleep	2
      1  fd18				   .CYCLES    SET	2
      2  fd18
      3  fd18				  -	      IF	.CYCLES < 2
      4  fd18				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd18				  -	      ERR
      6  fd18					      ENDIF
      7  fd18
      8  fd18				  -	      IF	.CYCLES & 1
      9  fd18				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd18				  -	      nop	0
     11  fd18				  -	      ELSE
     12  fd18				  -	      bit	VSYNC
     13  fd18				  -	      ENDIF
     14  fd18				  -.CYCLES    SET	.CYCLES - 3
     15  fd18					      ENDIF
     16  fd18
     17  fd18					      REPEAT	.CYCLES / 2
     18  fd18		       ea		      nop
     19  fd19					      REPEND
     31  fd19
     32  fd19				   .endif_1
     33  fd19		       be 89 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleMissile - NIBBLE_VAR_START],y
     34  fd1c		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     35  fd1f		       be 8a f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleVdel1 - NIBBLE_VAR_START],y
     36  fd22		       8e 2f f0 	      stx	[[KernelA_VDEL1 - $100] + 0]
     37  fd25		       be 8b f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGrp0 - NIBBLE_VAR_START],y
     38  fd28		       8e 07 f0 	      stx	[[KernelA_VDEL0 - $100] + 0]
     39  fd2b		       a2 ff		      ldx	#[ #$ff ]
     40  fd2d		       86 cf		      stx	[NibblePs + 0]
    161  fd2f							; sleep 5
    162  fd2f
    163  fd2f							; [scanline 8]
    164  fd2f				   row_8
      0  fd2f					      ASSERT_RUNTIME	"_scycles == #0"
      1  fd2f				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fd2f  && !(  _scycles == #0  ) }
      2  fd2f					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    166  fd2f
    167  fd2f							; FIXME this should be enabled!
    168  fd2f							; jet_spritedata_calc
    169  fd2f
    170  fd2f							; [NIBBLE VM]
    171  fd2f		       a5 c0		      lda	NibbleVar1
      0  fd31					      NIBBLE_gem_kernel_a_1
      1  fd31		       0a		      asl
      2  fd32		       90 0d		      bcc	.else_1
      3  fd34
      4  fd34				   .if_1
      5  fd34		       2a		      rol
      0  fd35					      sleep	18
      1  fd35				   .CYCLES    SET	18
      2  fd35
      3  fd35				  -	      IF	.CYCLES < 2
      4  fd35				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd35				  -	      ERR
      6  fd35					      ENDIF
      7  fd35
      8  fd35				  -	      IF	.CYCLES & 1
      9  fd35				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd35				  -	      nop	0
     11  fd35				  -	      ELSE
     12  fd35				  -	      bit	VSYNC
     13  fd35				  -	      ENDIF
     14  fd35				  -.CYCLES    SET	.CYCLES - 3
     15  fd35					      ENDIF
     16  fd35
     17  fd35					      REPEAT	.CYCLES / 2
     18  fd35		       ea		      nop
     17  fd35					      REPEND
     18  fd36		       ea		      nop
     17  fd36					      REPEND
     18  fd37		       ea		      nop
     17  fd37					      REPEND
     18  fd38		       ea		      nop
     17  fd38					      REPEND
     18  fd39		       ea		      nop
     17  fd39					      REPEND
     18  fd3a		       ea		      nop
     17  fd3a					      REPEND
     18  fd3b		       ea		      nop
     17  fd3b					      REPEND
     18  fd3c		       ea		      nop
     17  fd3c					      REPEND
     18  fd3d		       ea		      nop
     19  fd3e					      REPEND
      7  fd3e
      8  fd3e
      9  fd3e		       4c 5f fd 	      jmp	.endif_1
     10  fd41				   .else_1
     11  fd41		       0a		      asl
     12  fd42		       90 0f		      bcc	.else_2
     13  fd44
     14  fd44				   .if_2
     15  fd44		       a2 86		      ldx	#[ #BC_STX ]
     16  fd46		       8e 19 f0 	      stx	[[KernelA_D_W + 0] + 0]
     17  fd49		       a2 11		      ldx	#[ #RESP1 ]
     18  fd4b		       8e 1a f0 	      stx	[[KernelA_D_W + 1] + 0]
      0  fd4e					      sleep	3
      1  fd4e				   .CYCLES    SET	3
      2  fd4e
      3  fd4e				  -	      IF	.CYCLES < 2
      4  fd4e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd4e				  -	      ERR
      6  fd4e					      ENDIF
      7  fd4e
      8  fd4e					      IF	.CYCLES & 1
      9  fd4e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd4e		       04 00		      nop	0
     11  fd50				  -	      ELSE
     12  fd50				  -	      bit	VSYNC
     13  fd50					      ENDIF
     14  fd50				   .CYCLES    SET	.CYCLES - 3
     15  fd50					      ENDIF
     16  fd50
     17  fd50				  -	      REPEAT	.CYCLES / 2
     18  fd50				  -	      nop
     19  fd50					      REPEND
     20  fd50
     21  fd50
     22  fd50		       4c 5f fd 	      jmp	.endif_2
     23  fd53				   .else_2
     24  fd53		       be 82 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini1 - NIBBLE_VAR_START],y
     25  fd56		       8e 19 f0 	      stx	[[KernelA_D_W + 0] + 0]
     26  fd59		       be 83 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini1Reg - NIBBLE_VAR_START],y
     27  fd5c		       8e 1a f0 	      stx	[[KernelA_D_W + 1] + 0]
     28  fd5f
     29  fd5f				   .endif_2
     30  fd5f
     31  fd5f				   .endif_1
     32  fd5f		       0a		      asl
     33  fd60		       90 12		      bcc	.else_3
     34  fd62
     35  fd62				   .if_3
     36  fd62		       a2 79		      ldx	#[ #NOP_REG ]
     37  fd64		       8e 1c f0 	      stx	[[KernelA_E_W + 1] + 0]
     38  fd67		       a2 11		      ldx	#[ #RESP1 ]
     39  fd69		       8e 20 f0 	      stx	[[KernelA_G_W + 1] + 0]
      0  fd6c					      sleep	9
      1  fd6c				   .CYCLES    SET	9
      2  fd6c
      3  fd6c				  -	      IF	.CYCLES < 2
      4  fd6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd6c				  -	      ERR
      6  fd6c					      ENDIF
      7  fd6c
      8  fd6c					      IF	.CYCLES & 1
      9  fd6c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd6c		       04 00		      nop	0
     11  fd6e				  -	      ELSE
     12  fd6e				  -	      bit	VSYNC
     13  fd6e					      ENDIF
     14  fd6e				   .CYCLES    SET	.CYCLES - 3
     15  fd6e					      ENDIF
     16  fd6e
     17  fd6e					      REPEAT	.CYCLES / 2
     18  fd6e		       ea		      nop
     17  fd6e					      REPEND
     18  fd6f		       ea		      nop
     17  fd6f					      REPEND
     18  fd70		       ea		      nop
     19  fd71					      REPEND
     41  fd71
     42  fd71
     43  fd71		       4c 85 fd 	      jmp	.endif_3
     44  fd74				   .else_3
     45  fd74		       a2 11		      ldx	#[ #RESP1 ]
     46  fd76		       8e 1c f0 	      stx	[[KernelA_E_W + 1] + 0]
     47  fd79		       be 84 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2 - NIBBLE_VAR_START],y
     48  fd7c		       8e 1f f0 	      stx	[[KernelA_G_W + 0] + 0]
     49  fd7f		       be 85 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini2Reg - NIBBLE_VAR_START],y
     50  fd82		       8e 20 f0 	      stx	[[KernelA_G_W + 1] + 0]
     51  fd85
     52  fd85				   .endif_3
     53  fd85		       0a		      asl
     54  fd86		       90 0d		      bcc	.else_4
     55  fd88
     56  fd88				   .if_4
     57  fd88		       a2 11		      ldx	#[ #RESP1 ]
     58  fd8a		       8e 22 f0 	      stx	[[KernelA_H_W + 1] + 0]
      0  fd8d					      sleep	9
      1  fd8d				   .CYCLES    SET	9
      2  fd8d
      3  fd8d				  -	      IF	.CYCLES < 2
      4  fd8d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd8d				  -	      ERR
      6  fd8d					      ENDIF
      7  fd8d
      8  fd8d					      IF	.CYCLES & 1
      9  fd8d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd8d		       04 00		      nop	0
     11  fd8f				  -	      ELSE
     12  fd8f				  -	      bit	VSYNC
     13  fd8f					      ENDIF
     14  fd8f				   .CYCLES    SET	.CYCLES - 3
     15  fd8f					      ENDIF
     16  fd8f
     17  fd8f					      REPEAT	.CYCLES / 2
     18  fd8f		       ea		      nop
     17  fd8f					      REPEND
     18  fd90		       ea		      nop
     17  fd90					      REPEND
     18  fd91		       ea		      nop
     19  fd92					      REPEND
     60  fd92
     61  fd92
     62  fd92		       4c a1 fd 	      jmp	.endif_4
     63  fd95				   .else_4
     64  fd95		       be 86 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3 - NIBBLE_VAR_START],y
     65  fd98		       8e 21 f0 	      stx	[[KernelA_H_W + 0] + 0]
     66  fd9b		       be 87 f1 	      ldx	[CBSRAM_NIBBLE_READ + NibbleGemini3Reg - NIBBLE_VAR_START],y
     67  fd9e		       8e 22 f0 	      stx	[[KernelA_H_W + 1] + 0]
     68  fda1
     69  fda1				   .endif_4
    173  fda1							; sleep 3
    174  fda1
    175  fda1							; Idle.
    176  fda1							; sleep 51
    177  fda1							; sta WSYNC
    178  fda1
    179  fda1							; [scanline 8-1]
      0  fda1					      ASSERT_RUNTIME	"_scycles == #0"
      1  fda1				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fda1  && !(  _scycles == #0  ) }
      2  fda1					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    181  fda1							; Repeat loop until LoopCount < 0
    182  fda1		       c6 d4		      dec	LoopCount
    183  fda3		       f0 03		      beq	row_end
    184  fda5		       4c 3d fc 	      jmp	row_start
    185  fda8				   row_end
    186  fda8		       4c 0e fc 	      jmp	border_bottom
------- FILE main.s
------- FILE kernel_gem.s LEVEL 2 PASS 2
      0  fdab					      include	"kernel_gem.s"
      1  fdab							;
      2  fdab							; Gem Kernels
      3  fdab							;
      4  fdab							; Gems are displayed in alternating kernels. This chart shows
      5  fdab							; which kernel is responsible for which gem, with missiles denoted.
      6  fdab							;
      7  fdab							;  1:	 |SS  SS  MSS  |SS   SS  SS  |	      kernel 1 (S = Sprite, M = missile)
      8  fdab							;  2:	 |  SS	SS   SS|  SSM  SS  SS|	      kernel 2
      9  fdab							;  =	 |1122112221122|1122111221122|	      kernel #
     10  fdab							;  #	 0^	 8^	  17^	    26^       gem index
     11  fdab							;
     12  fdab							; The middle bar indicates where the pattern reverses.
     13  fdab							;
     14  fdab							; Because we can repeat a sprite multiple times, and reset the sprite
     15  fdab							; occurance mid-line, we can render close to half of the 26 gems a line
     16  fdab							; requires with a single sprite. By alternating sprites each frame with an...
     17  fdab							; acceptable amount of flicker (15Hz) we can render almost all the gems on each
     18  fdab							; line, except for two. These are instead rendered by the missile, which
     19  fdab							; corresponds to the sprite and must have the same color and repeat pattern.
     20  fdab
     21  fdab							; for copying
     22  fe00		       00 00 00 00*	      align	256
     23  fe00
     24  fe00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     25  fe00							;
     26  fe00							; GEM KERNEL A
     27  fe00							;
     28  fe00
     29  fe00				   kernel_1_start subroutine
     30  fe00					      rorg	$f100
     31  fe00
     32  fe00							; Kernel Marker
     33  fe00		       0a		      .byte.b	$A
     34  fe01
     35  fe01				   KernelA_early
      0  fe01					      ASSERT_RUNTIME_KERNEL	$A, "v == #1"
      1  fe01				   .KERNEL    SET	$A
      2  fe01				   .COND      SET	"v == #1"
 ASSERT: breakif { pc== $f101  && ( *$f100 ==  $a   ) && ! (  v == #1  ) }
      3  fe01					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     37  fe01		       b8		      clv
     38  fe02
     39  fe02							; Early code to set next Player GRP0. Immediate value is overwritten
     40  fe02		       a9 ff		      lda	#$ff
     41  fe02		       f1 03	   KernelA_GRP0 =	. - 1
     42  fe04
     43  fe04				   KernelA    subroutine
      0  fe04					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #0"
      1  fe04				   .KERNEL    SET	$A
      2  fe04				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $a   ) && ! (  _scycles == #0  ) }
      3  fe04					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     45  fe04
     46  fe04							; Write Player from accumulator. When writing to the other sprite, the
     47  fe04							; TIA will copy Gemini 0A into visible sprite register
     48  fe04		       85 1b		      sta	JET_SP
     49  fe06							; Write Gemini 1A into visible sprite register
     50  fe06		       a9 66		      lda	#%01100110
     51  fe06		       f1 07	   KernelA_VDEL0 =	. - 1
     52  fe08		       85 1c		      sta	EMERALD_SP
     53  fe0a
     54  fe0a							; Register config
     55  fe0a		       a9 08		      lda	#%00001000
     56  fe0c		       85 0c		      sta	REFP1
     57  fe0e
     58  fe0e		       a9 20		      lda	#%00100000
     59  fe10		       85 0e		      sta	PF1
     60  fe12
     61  fe12							; Reset stack pointer
     62  fe12		       68		      pla
     63  fe13
     64  fe13							; 22c is critical start of precise GRP0 timing for Kernel A
      0  fe13					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #22"
      1  fe13				   .KERNEL    SET	$A
      2  fe13				   .COND      SET	"_scycles == #22"
 ASSERT: breakif { pc== $f113  && ( *$f100 ==  $a   ) && ! (  _scycles == #22  ) }
      3  fe13					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     66  fe13				   KernelA_A
     67  fe13		       85 11		      sta	EMERALD_SP_RESET	; RESPx must be strobed on cycle 25c.
     68  fe15
     69  fe15							; RST0 vvv
     70  fe15				   KernelA_B
     71  fe15		       a5 e2		      lda	RamPF1Value
     72  fe17				   KernelA_C
     73  fe17		       84 26		      sty	VDELP1	; disable delayed sprite
     74  fe19				   KernelA_D
     75  fe19							; sty EMERALD_SP ; Gemini 1A
      0  fe19					      sleep	3
      1  fe19				   .CYCLES    SET	3
      2  fe19
      3  fe19				  -	      IF	.CYCLES < 2
      4  fe19				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fe19				  -	      ERR
      6  fe19					      ENDIF
      7  fe19
      8  fe19					      IF	.CYCLES & 1
      9  fe19					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fe19		       04 00		      nop	0
     11  fe1b				  -	      ELSE
     12  fe1b				  -	      bit	VSYNC
     13  fe1b					      ENDIF
     14  fe1b				   .CYCLES    SET	.CYCLES - 3
     15  fe1b					      ENDIF
     16  fe1b
     17  fe1b				  -	      REPEAT	.CYCLES / 2
     18  fe1b				  -	      nop
     19  fe1b					      REPEND
     77  fe1b							; RST0 ^^^
     78  fe1b
     79  fe1b				   KernelA_E
     80  fe1b		       85 11		      sta	EMERALD_SP_RESET	; Reset "medium close" NUSIZ repetition
     81  fe1d				   KernelA_F
     82  fe1d		       86 1e		      stx	EMERALD_MI_ENABLE	; Enable the missile (if register uses the %0xx00110 pattern)
     83  fe1f				   KernelA_G
     84  fe1f		       84 1c		      sty	EMERALD_SP	; Gemini 2A
     85  fe21
     86  fe21				   KernelA_H
     87  fe21		       84 1c		      sty	EMERALD_SP	; Gemini 3A, modified for RST2 along with HMM1
     88  fe23
      0  fe23					      ASSERT_RUNTIME_KERNEL	$A, "c == #1"
      1  fe23				   .KERNEL    SET	$A
      2  fe23				   .COND      SET	"c == #1"
 ASSERT: breakif { pc== $f123  && ( *$f100 ==  $a   ) && ! (  c == #1  ) }
      3  fe23					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     90  fe23							; RST4 vvv
     91  fe23				   KernelA_I
     92  fe23		       08		      php		; Reset "medium close" NUSIZ repetition
     93  fe24				   KernelA_J		; unchanging
     94  fe24		       85 0e		      sta	PF1	; Write asymmetrical playfield register
     95  fe26				   KernelA_K
     96  fe26		       84 1c		      sty	EMERALD_SP	; Gemini 4A
     97  fe28							; RST4 ^^^
     98  fe28
     99  fe28				   KernelA_L
    100  fe28		       a5 de		      lda	RamZeroByte	; FIXME this doesn't belong here
    101  fe2a				   KernelA_M
    102  fe2a		       84 26		      sty	VDELP1	; Gemini 5A ; need a way to skip this vlaue
    103  fe2c				   KernelA_N
    104  fe2c		       85 1e		      sta	EMERALD_MI_ENABLE	; disable missile FIXME better place for this?
    105  fe2e				   KernelA_O
    106  fe2e		       a9 66		      lda	#%01100110
    107  fe2e		       f1 2f	   KernelA_VDEL1 =	. - 1
    108  fe30
    109  fe30							; End visible line
      0  fe30					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #66"
      1  fe30				   .KERNEL    SET	$A
      2  fe30				   .COND      SET	"_scycles == #66"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $a   ) && ! (  _scycles == #66  ) }
      3  fe30					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    111  fe30				   KernelA_branch
    112  fe30		       85 1c		      sta	EMERALD_SP	; set VDEL1
    113  fe32
    114  fe32							; Branch or return.
    115  fe32		       70 cd		      bvs	KernelA_early
      0  fe34					      sleep	2
      1  fe34				   .CYCLES    SET	2
      2  fe34
      3  fe34				  -	      IF	.CYCLES < 2
      4  fe34				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fe34				  -	      ERR
      6  fe34					      ENDIF
      7  fe34
      8  fe34				  -	      IF	.CYCLES & 1
      9  fe34				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fe34				  -	      nop	0
     11  fe34				  -	      ELSE
     12  fe34				  -	      bit	VSYNC
     13  fe34				  -	      ENDIF
     14  fe34				  -.CYCLES    SET	.CYCLES - 3
     15  fe34					      ENDIF
     16  fe34
     17  fe34					      REPEAT	.CYCLES / 2
     18  fe34		       ea		      nop
     19  fe35					      REPEND
    117  fe35		       4c be fc 	      jmp	row_after_kernel
    118  fe38
    119  fe38					      rend
    120  fe38				   kernel_1_end
      0  fe38					      ASSERT_SIZE	kernel_1_start, kernel_1_end, $40
      1  fe38				   .STARTA    SET	kernel_1_start
      2  fe38				   .ENDA      SET	kernel_1_end
      3  fe38				   .LEN       SET	$40
      4  fe38				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fe38				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fe38				  -	      err
      7  fe38					      endif
    122  fe38
    123  fe38							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    124  fe38							;
    125  fe38							; GEM KERNEL B
    126  fe38							;
    127  fe38
    128  fe38				   kernel_2_start subroutine
    129  fe38					      rorg	$f100
    130  fe38
    131  fe38							; Kernel Marker
    132  fe38		       0b		      .byte.b	$B
    133  fe39
    134  fe39		       b8		      clv
    135  fe3a
    136  fe3a				   KernelB_early
    137  fe3a							; Early code to set next GRP0 image. Value is overwritten
    138  fe3a		       a9 ff		      lda	#$ff
    139  fe3a		       f1 03	   KernelB_GRP0 =	. - 1
    140  fe3c
    141  fe3c				   KernelB    subroutine
      0  fe3c					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #0"
      1  fe3c				   .KERNEL    SET	$B
      2  fe3c				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $b   ) && ! (  _scycles == #0  ) }
      3  fe3c					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    143  fe3c
    144  fe3c							; Write Player from accumulator. When writing to the other sprite, the
    145  fe3c							; TIA will copy Gemini 0A into visible sprite register
    146  fe3c		       85 1b		      sta	JET_SP
    147  fe3e		       a9 aa		      lda	#%10101010
    148  fe3e		       f1 07	   KernelB_VDEL0 =	. - 1
    149  fe40							; Write Gemini 1A into delayed sprite register
    150  fe40		       85 1c		      sta	EMERALD_SP
    151  fe42
    152  fe42							; Reset stack
    153  fe42		       68		      pla
    154  fe43
    155  fe43							; 6c
    156  fe43		       a9 20		      lda	#%00100000
    157  fe45		       85 0e		      sta	PF1
    158  fe47
    159  fe47							; Register config
    160  fe47		       a9 ff		      lda	#$ff
    161  fe49		       85 1e		      sta	EMERALD_MI_ENABLE	; enable missile
    162  fe4b
    163  fe4b							; Set processor register bit for PHP sprite rendering.
      0  fe4b					      sleep	3
      1  fe4b				   .CYCLES    SET	3
      2  fe4b
      3  fe4b				  -	      IF	.CYCLES < 2
      4  fe4b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fe4b				  -	      ERR
      6  fe4b					      ENDIF
      7  fe4b
      8  fe4b					      IF	.CYCLES & 1
      9  fe4b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fe4b		       04 00		      nop	0
     11  fe4d				  -	      ELSE
     12  fe4d				  -	      bit	VSYNC
     13  fe4d					      ENDIF
     14  fe4d				   .CYCLES    SET	.CYCLES - 3
     15  fe4d					      ENDIF
     16  fe4d
     17  fe4d				  -	      REPEAT	.CYCLES / 2
     18  fe4d				  -	      nop
     19  fe4d					      REPEND
    165  fe4d
    166  fe4d							; 25c is critical start of precise GRP0 timing for Kernel B
      0  fe4d					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #25"
      1  fe4d				   .KERNEL    SET	$B
      2  fe4d				   .COND      SET	"_scycles == #25"
 ASSERT: breakif { pc== $f115  && ( *$f100 ==  $b   ) && ! (  _scycles == #25  ) }
      3  fe4d					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    168  fe4d				   KernelB_A
    169  fe4d		       85 11		      sta	EMERALD_SP_RESET
    170  fe4f				   KernelB_B
    171  fe4f		       a5 e2		      lda	RamPF1Value
    172  fe51				   KernelB_C
    173  fe51		       c5 e2		      cmp	RamPF1Value
    174  fe53				   KernelB_D
    175  fe53		       86 1c		      stx	EMERALD_SP	; Gemini 1B
    176  fe55
    177  fe55							; below has one php load (could just be RESET)
    178  fe55				   KernelB_E
    179  fe55		       08		      php
    180  fe56				   KernelB_F
    181  fe56		       84 1c		      sty	EMERALD_SP	; Gemini 2B
    182  fe58				   KernelB_G
    183  fe58		       85 0e		      sta	PF1
    184  fe5a				   KernelB_H
    185  fe5a		       84 1c		      sty	EMERALD_SP	; Gemini 3B; TODO write php instead fixed
    186  fe5c							; above has one PHP load
    187  fe5c
    188  fe5c				   KernelB_I
    189  fe5c		       85 11		      sta	EMERALD_SP_RESET
    190  fe5e				   KernelB_J
    191  fe5e		       84 1c		      sty	EMERALD_SP	; Gemini 4B
    192  fe60				   KernelB_K
    193  fe60		       85 1e		      sta	EMERALD_MI_ENABLE	; FIXME this can't rely on sta
    194  fe62				   KernelB_L
    195  fe62		       86 1c		      stx	EMERALD_SP	; Gemini 5B
    196  fe64
    197  fe64				   KernelB_M
      0  fe64					      sleep	3
      1  fe64				   .CYCLES    SET	3
      2  fe64
      3  fe64				  -	      IF	.CYCLES < 2
      4  fe64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fe64				  -	      ERR
      6  fe64					      ENDIF
      7  fe64
      8  fe64					      IF	.CYCLES & 1
      9  fe64					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fe64		       04 00		      nop	0
     11  fe66				  -	      ELSE
     12  fe66				  -	      bit	VSYNC
     13  fe66					      ENDIF
     14  fe66				   .CYCLES    SET	.CYCLES - 3
     15  fe66					      ENDIF
     16  fe66
     17  fe66				  -	      REPEAT	.CYCLES / 2
     18  fe66				  -	      nop
     19  fe66					      REPEND
    199  fe66				   KernelB_N
      0  fe66					      sleep	3
      1  fe66				   .CYCLES    SET	3
      2  fe66
      3  fe66				  -	      IF	.CYCLES < 2
      4  fe66				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fe66				  -	      ERR
      6  fe66					      ENDIF
      7  fe66
      8  fe66					      IF	.CYCLES & 1
      9  fe66					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fe66		       04 00		      nop	0
     11  fe68				  -	      ELSE
     12  fe68				  -	      bit	VSYNC
     13  fe68					      ENDIF
     14  fe68				   .CYCLES    SET	.CYCLES - 3
     15  fe68					      ENDIF
     16  fe68
     17  fe68				  -	      REPEAT	.CYCLES / 2
     18  fe68				  -	      nop
     19  fe68					      REPEND
    201  fe68
    202  fe68							; End visible line
      0  fe68					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #67"
      1  fe68				   .KERNEL    SET	$B
      2  fe68				   .COND      SET	"_scycles == #67"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $b   ) && ! (  _scycles == #67  ) }
      3  fe68					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    204  fe68
    205  fe68				   KernelB_branch
    206  fe68		       ad 84 02 	      lda	INTIM
    207  fe6b		       d0 cd		      bne	KernelB_early
    208  fe6d		       4c be fc 	      jmp	row_after_kernel
    209  fe70
    210  fe70					      rend
    211  fe70				   kernel_2_end
      0  fe70					      ASSERT_SIZE	kernel_2_start, kernel_2_end, $40
      1  fe70				   .STARTA    SET	kernel_2_start
      2  fe70				   .ENDA      SET	kernel_2_end
      3  fe70				   .LEN       SET	$40
      4  fe70				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fe70				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fe70				  -	      err
      7  fe70					      endif
------- FILE main.s
------- FILE data_sprites.s LEVEL 2 PASS 2
      0  fe70					      include	"data_sprites.s"
      1  fe70
      2  ff00		       00 00 00 00*	      align	256
      3  ff00
      4  ff00				   Frame0
      5  ff00							; 8 buffer
      6  ff00		       00		      .byte.b	#%00000000
      7  ff01		       00		      .byte.b	#%00000000
      8  ff02		       00		      .byte.b	#%00000000
      9  ff03		       00		      .byte.b	#%00000000
     10  ff04		       00		      .byte.b	#%00000000
     11  ff05		       00		      .byte.b	#%00000000
     12  ff06		       00		      .byte.b	#%00000000
     13  ff07		       00		      .byte.b	#%00000000
     14  ff08
     15  ff08							; 8 rows
     16  ff08		       60		      .byte.b	#%01100000
     17  ff09		       60		      .byte.b	#%01100000
     18  ff0a		       60		      .byte.b	#%01100000
     19  ff0b		       c0		      .byte.b	#%11000000
     20  ff0c		       c0		      .byte.b	#%11000000
     21  ff0d		       f0		      .byte.b	#%11110000
     22  ff0e		       c0		      .byte.b	#%11000000
     23  ff0f		       c0		      .byte.b	#%11000000
     24  ff10
     25  ff10							; 8 buffer
     26  ff10		       00		      .byte.b	#%00000000
     27  ff11		       00		      .byte.b	#%00000000
     28  ff12		       00		      .byte.b	#%00000000
     29  ff13		       00		      .byte.b	#%00000000
     30  ff14		       00		      .byte.b	#%00000000
     31  ff15		       00		      .byte.b	#%00000000
     32  ff16		       00		      .byte.b	#%00000000
     33  ff17		       00		      .byte.b	#%00000000
------- FILE main.s
------- FILE data_levels.s LEVEL 2 PASS 2
      0  ff18					      include	"data_levels.s"
      1  ff18					      align	8
      2  ff18
      3  ff18				   shard_map
      4  ff18		       40		      .byte.b	%01000000	; [1, 0, 0]
      5  ff19				   shard_map_end
------- FILE main.s
    136  ff19
    137  fffc					      org	$fffc
    138  fffc		       09 f2		      .word.w	Start
    139  fffe		       09 f2		      .word.w	Start
