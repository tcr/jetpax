------- FILE main.s LEVEL 1 PASS 2
      1  fffe					      processor	6502
      2  10000 ????
      3  10000 ????						; Nibble null methods
      4  10000 ????				       mac	nibble_start_kernel
      5  10000 ????				       seg.U	ignoreme	; comment out rest of code
      6  10000 ????				       endm
      7  10000 ????				       mac	nibble_if
      8  10000 ????				       endm
      9  10000 ????				       mac	nibble_write
     10  10000 ????				       endm
     11  10000 ????				       mac	nibble_write_opcode
     12  10000 ????				       endm
     13  10000 ????				       mac	nibble_else
     14  10000 ????				       endm
     15  10000 ????				       mac	nibble_end_if
     16  10000 ????				       endm
     17  10000 ????				       mac	nibble_end_kernel
     18  10000 ????				       seg	CodeBank3
     19  10000 ????				       endm
     20  10000 ????
     21  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     22  10000 ????				       mac	assert_runtime
     23  10000 ????			    .COND      SET	{1}
     24  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     25  10000 ????				       endm
     26  10000 ????
     27  10000 ????
     28  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     29  10000 ????				       mac	assert_runtime_kernel
     30  10000 ????			    .KERNEL    SET	{1}
     31  10000 ????			    .COND      SET	{2}
     32  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     33  10000 ????				       endm
     34  10000 ????
     35  10000 ????						; Static assertions for size
     36  10000 ????				       mac	assert_size
     37  10000 ????			    .STARTA    SET	{1}
     38  10000 ????			    .ENDA      SET	{2}
     39  10000 ????			    .LEN       SET	{3}
     40  10000 ????				       if	[[.ENDA - .STARTA] >= .LEN]
     41  10000 ????				       echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
     42  10000 ????				       err
     43  10000 ????				       endif
     44  10000 ????				       endm
     45  10000 ????				       mac	assert_size_exact
     46  10000 ????			    .STARTA    SET	{1}
     47  10000 ????			    .ENDA      SET	{2}
     48  10000 ????			    .LEN       SET	{3}
     49  10000 ????				       if	[[.ENDA - .STARTA] != .LEN]
     50  10000 ????				       echo	""
     51  10000 ????				       echo	"Error: Violated size limit", [.ENDA - .STARTA], "vs", .LEN
     52  10000 ????				       err
     53  10000 ????				       endif
     54  10000 ????				       endm
     55  10000 ????
     56  10000 ????						; Global headers
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE main.s
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????
    163  0000 ????						; EOF
------- FILE main.s
------- FILE xmacro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"xmacro.h"
      1  0000 ????
      2  0000 ????						;-------------------------------------------------------
      3  0000 ????						; Usage: TIMER_SETUP lines
      4  0000 ????						; where lines is the number of scanlines to skip (> 2).
      5  0000 ????						; The timer will be set so that it expires before this number
      6  0000 ????						; of scanlines. A WSYNC will be done first.
      7  0000 ????
      8  0000 ????				      MAC	timer_setup
      9  0000 ????			   .lines     SET	{1}
     10  0000 ????				      lda	#(((.lines)*76-14)/64)
     11  0000 ????				      sta	WSYNC
     12  0000 ????				      sta	TIM64T
     13  0000 ????				      ENDM
     14  0000 ????
     15  0000 ????						;-------------------------------------------------------
     16  0000 ????						; Use with TIMER_SETUP to wait for timer to complete.
     17  0000 ????						; You may want to do a WSYNC afterwards, since the timer
     18  0000 ????						; is not accurate to the beginning/end of a scanline.
     19  0000 ????
     20  0000 ????				      MAC	timer_wait
     21  0000 ????			   .waittimer
     22  0000 ????				      lda	INTIM
     23  0000 ????				      bne	.waittimer
     24  0000 ????				      sta	WSYNC
     25  0000 ????				      ENDM
     26  0000 ????
------- FILE main.s
     60  0000 ????
     61  0000 ????						; RAM and constants
------- FILE game_define.s LEVEL 2 PASS 2
      0  0000 ????				      include	"game_define.s"
      1 U0000 ????				      seg.u	Defines
      2 U0000 ????
      3 U0000 ????	       00 10	   ROW_COUNT  =	16
      4 U0000 ????	       00 02	   SIGNAL_LINE =	$02
      5 U0000 ????	       00 07	   FrameSkip  =	%111	; Tick (every 8 frames)
      6 U0000 ????
      7 U0000 ????						; RAM+ memory map
      8 U0000 ????
      9 U0000 ????	       f0 00	   CBSRAM_KERNEL_WRITE =	$f000
     10 U0000 ????	       f1 00	   CBSRAM_KERNEL_READ =	$f100
     11 U0000 ????	       f1 04	   CBSRAM_KERNEL_ENTRY =	[CBSRAM_KERNEL_READ + 4]
     12 U0000 ????
     13 U0000 ????	       f0 40	   RAMP_STORAGE_W =	$f040	; is this just max(frame_1_end, frame_2_end) ?
     14 U0000 ????	       f1 40	   RAMP_STORAGE_R =	$f140
     15 U0000 ????
     16 U0000 ????
     17 U0000 ????						; NUSIZ values
     18 U0000 ????
     19 U0000 ????	       00 13	   THREE_COPIES =	%00010011
     20 U0000 ????
     21 U0000 ????
     22 U0000 ????						; Colors
     23 U0000 ????
     24 U0000 ????	       00 42	   COL_BG     =	$42
     25 U0000 ????	       00 cc	   COL_EMERALD =	$CC
     26 U0000 ????	       00 cc	   COL_EMERALD_2 =	$CC
     27 U0000 ????
     28 U0000 ????
     29 U0000 ????						; HMOVE values for missiles
     30 U0000 ????
     31 U0000 ????	       00 1c	   KERNEL_A_MISSILE_SLEEP =	28
     32 U0000 ????	       00 00	   KERNEL_A_MISSILE_HMOVE =	$00
     33 U0000 ????
     34 U0000 ????	       00 33	   KERNEL_B_MISSILE_SLEEP =	51
     35 U0000 ????	       00 10	   KERNEL_B_MISSILE_HMOVE =	$10
     36 U0000 ????
     37 U0000 ????						; Missile values when 2A=RST
     38 U0000 ????						; KERNEL_B_MISSILE_SLEEP equ 46
     39 U0000 ????						; KERNEL_B_MISSILE_HMOVE equ $20
     40 U0000 ????
     41 U0000 ????
     42 U0000 ????						; Sprite details
     43 U0000 ????
     44 U0000 ????	       00 07	   EMERALD_SP_COLOR =	COLUP1
     45 U0000 ????	       00 1c	   EMERALD_SP =	GRP1
     46 U0000 ????	       00 1e	   EMERALD_MI_ENABLE =	ENAM1
     47 U0000 ????	       00 11	   EMERALD_SP_RESET =	RESP1
     48 U0000 ????	       00 13	   EMERALD_MI_RESET =	RESM1
     49 U0000 ????	       00 21	   EMERALD_SP_HMOVE =	HMP1
     50 U0000 ????	       00 23	   EMERALD_MI_HMOVE =	HMM1
     51 U0000 ????	       00 05	   EMERALD_COPIES =	NUSIZ1
     52 U0000 ????
     53 U0000 ????	       00 1b	   JET_SP     =	GRP0
     54 U0000 ????	       00 10	   JET_SP_RESET =	RESP0
     55 U0000 ????	       00 20	   JET_SP_HMOVE =	HMP0
     56 U0000 ????	       00 06	   JET_SP_COLOR =	COLUP0
     57 U0000 ????
     58 U0000 ????
     59 U0000 ????						; Game dimensionsn
     60 U0000 ????
     61 U0000 ????						; Spriteend is HEIGHT_OFFSET - YPos
     62 U0000 ????	       00 08	   SPRITE_HEIGHT =	8
     63 U0000 ????	       00 c8	   HEIGHT_OFFSET =	200
     64 U0000 ????
     65 U0000 ????						; Compared with YPos
     66 U0000 ????	       00 48	   FLOOR_OFFSET =	72
     67 U0000 ????	       00 c0	   CEILING_OFFSET =	192
     68 U0000 ????
     69 U0000 ????						; Starting player position
     70 U0000 ????	       00 48	   YPosStart  =	72
     71 U0000 ????	       00 58	   XPosStart  =	88
     72 U0000 ????
     73 U0000 ????						; Top left corner
     74 U0000 ????						; YPosStart equ 190
     75 U0000 ????						; XPosStart equ 28
------- FILE main.s
------- FILE game_vars.s LEVEL 2 PASS 2
      0 U0000 ????				      include	"game_vars.s"
      1 U00c0 ????				      seg.u	Variables
      2 U00c0 ????
      3 U0080					      org	$80
      4 U0080
      5 U0080		       00	   DebugKernelID byte.b		; which kernel are we running this frame? (for debugging)
      6 U0081
      7 U0081		       00	   Temp       byte.b
      8 U0082		       00	   Temp2      byte.b
      9 U0083
     10 U0083							; Counters
     11 U0083		       00	   RowCount   byte.b
     12 U0084		       00	   LoopCount  byte.b
     13 U0085		       00	   FrameCount byte.b
     14 U0086
     15 U0086		       00	   YP1	      byte.b
     16 U0087		       00	   SpriteEnd  byte.b
     17 U0088		       00	   XPos       byte.b		; X position of player sprite
     18 U0089
     19 U0089
     20 U0089		       00	   Speed1     byte.b
     21 U008a		       00	   Speed2     byte.b
     22 U008b
     23 U008b		       00	   YPos       byte.b		; Y position of player sprite
     24 U008c		       00	   YPos2      byte.b
     25 U008d
     26 U008d		       00	   GEM_02_TARGET byte.b
     27 U008e
     28 U008e		       00	   JMP_ADDR   byte.b
     29 U008f		       00	   JMP_ADDR_2 byte.b
     30 U0090
     31 U0090		       00	   ROW_DEMO_INDEX byte.b
     32 U0091
     33 U0091		       00	   RamNibbleTemp byte.b
     34 U0092		       00	   RamNibbleVar1 byte.b
     35 U0093		       00	   RamNibbleVar2 byte.b
     36 U0094		       00	   RamZeroByte byte.b
     37 U0095		       00	   RamLowerSixByte byte.b
     38 U0096		       00	   RamFFByte  byte.b
     39 U0097		       00	   RamStackBkp byte.b
     40 U0098
     41 U0098		       00	   RamRowJetpackIndex byte.b		; sprite counter
     42 U0099
     43 U0099							; Kernel support
     44 U0099		       00	   RamPSByte  byte.b
     45 U009a		       00	   RamPF1Value byte.b
     46 U009b		       00	   RamKernelGRP0 byte.b		; temp
     47 U009c		       00	   RamKernelPhpTarget byte.b
     48 U009d		       00	   RamKernelX byte.b
     49 U009e		       00	   RamKernelY byte.b
     50 U009f
     51 U009f		       00	   RamKernelGemini1 byte.b
     52 U00a0		       00	   RamKernelGemini1Reg byte.b
     53 U00a1		       00	   RamKernelGemini2 byte.b
     54 U00a2		       00	   RamKernelGemini2Reg byte.b
     55 U00a3		       00	   RamKernelGemini3 byte.b
     56 U00a4		       00	   RamKernelGemini3Reg byte.b
     57 U00a5		       00	   RamKernelGemini4 byte.b
     58 U00a6		       00	   RamKernelGemini4Reg byte.b
     59 U00a7		       00	   RamKernelGemini5 byte.b
     60 U00a8
     61 U00a8		       00	   BuildKernelX byte.b
     62 U00a9		       00	   BuildKernelY byte.b
     63 U00aa		       00	   BuildKernelRST byte.b
     64 U00ab		       00	   BuildKernelGrp0 byte.b
     65 U00ac		       00	   BuildKernelVdel1 byte.b
     66 U00ad		       00	   BuildKernelMissile byte.b
     67 U00ae
     68 U00ae		       00	   level_for_game byte.b
     69 U00af		       00		      byte.b
     70 U00b0		       00		      byte.b
     71 U00b1		       00		      byte.b
     72 U00b2
     73 U00b2		       00	   DO_MISS_A  byte.b
     74 U00b3		       00	   DO_MISS_B  byte.b
     75 U00b4		       00	   DO_GEMS_A  byte.b
     76 U00b5		       00		      byte.b
     77 U00b6		       00		      byte.b
     78 U00b7		       00		      byte.b
     79 U00b8		       00		      byte.b
     80 U00b9		       00		      byte.b
     81 U00ba		       00	   DO_GEMS_B  byte.b
     82 U00bb		       00		      byte.b
     83 U00bc		       00		      byte.b
     84 U00bd		       00		      byte.b
     85 U00be		       00		      byte.b
     86 U00bf		       00		      byte.b
------- FILE main.s
     64 U00c0
     65 U00c0							; Bank 1
     66  e000 ????				      seg	CodeBank1
     67  d000					      org	$D000
     68  d000					      rorg	$F000
     69  d000		       00	   BANK1      byte.b
     70  d200					      org	$d200
     71  d200					      rorg	$d200
     72  d200				   Bank1Start
     73  d200		       ad fa ff 	      lda	$fffa
     74  d203		       ea		      nop
     75  d204		       ea		      nop
     76  d205		       ea		      nop
     77  d206
     78  dffc					      org	$dffc
     79  dffc					      rorg	$fffc
     80  dffc		       00 d2		      .word.w	Bank1Start
     81  dffe		       00 d2		      .word.w	Bank1Start
     82  e000
     83  e000							; Bank 2
     84  f000 ????				      seg	CodeBank2
     85  e000					      org	$E000
     86  e000					      rorg	$F000
     87  e000		       00	   BANK2      byte.b
     88  e200					      org	$e200
     89  e200					      rorg	$f200
     90  e200				   Bank2Start
     91  e200		       ad fa ff 	      lda	$fffa
     92  e203		       ea		      nop
     93  e204		       ea		      nop
     94  e205		       ea		      nop
     95  e206
     96  effc					      org	$effc
     97  effc					      rorg	$fffc
     98  effc		       00 f2		      .word.w	Bank2Start
     99  effe		       00 f2		      .word.w	Bank2Start
    100  f000
    101  f000							; Bank 3
    102  10000 ????				       seg	CodeBank3
    103  f000					      org	$F000
    104  f000					      rorg	$F000
    105  f000		       00	   BANK3      byte.b
    106  f200					      org	$f200
    107  f200					      rorg	$f200
    108  f200				   Bank3Start
    109  f200		       ad fa ff 	      lda	$fffa
    110  f203		       ea		      nop
    111  f204		       ea		      nop
    112  f205		       ea		      nop
    113  f206		       4c 09 f2 	      jmp	Start
    114  f209
    115  f209							; Bank 3 source code
------- FILE game_init.s LEVEL 2 PASS 2
      0  f209					      include	"game_init.s"
      1  f209							; Game Initialization after power on or reset
      2  f209
      3  f209				   IFTRACKER  SET	1
      4  f209
      5  f209				   IFTRACKER  SET	2
      6  f209
      7  f209				   Start
      0  f209					      CLEAN_START
      1  f209		       78		      sei
      2  f20a		       d8		      cld
      3  f20b
      4  f20b		       a2 00		      ldx	#0
      5  f20d		       8a		      txa
      6  f20e		       a8		      tay
      7  f20f		       ca	   .CLEAR_STACK dex
      8  f210		       9a		      txs
      9  f211		       48		      pha
     10  f212		       d0 fb		      bne	.CLEAR_STACK
     11  f214
      9  f214
     10  f214							; Disable interrupt flag in processor status (it's useless anyway)
     11  f214		       58		      cli
     12  f215
     13  f215				   InitSetup
     14  f215		       a9 00		      lda	#0
     15  f217		       85 85		      sta	FrameCount
     16  f219
     17  f219							; P0 has three copies
     18  f219		       a9 13		      lda	#%00010011
     19  f21b		       85 05		      sta	EMERALD_COPIES
     20  f21d
     21  f21d		       a9 00		      lda	#$00
     22  f21f		       85 09		      sta	COLUBK
     23  f221		       a9 01		      lda	#%00000001
     24  f223		       85 0a		      sta	CTRLPF	; reflect playfield
     25  f225
     26  f225							; Disable VDEL
     27  f225		       a9 00		      lda	#0
     28  f227		       85 25		      sta	VDELP0
     29  f229		       85 26		      sta	VDELP1
     30  f22b
     31  f22b							; Player 0
     32  f22b		       a2 cc		      ldx	#COL_EMERALD
     33  f22d		       86 07		      stx	EMERALD_SP_COLOR
     34  f22f
     35  f22f							; Player 1
     36  f22f		       a9 0f		      lda	#$0f
     37  f231		       85 06		      sta	JET_SP_COLOR
     38  f233		       a9 00		      lda	#$00
     39  f235		       85 1b		      sta	JET_SP
     40  f237
     41  f237							; Positions
     42  f237		       a9 48		      lda	#YPosStart
     43  f239		       85 8b		      sta	YPos
     44  f23b		       a9 58		      lda	#XPosStart
     45  f23d		       85 88		      sta	XPos
     46  f23f		       a9 00		      lda	#0
     47  f241		       85 89		      sta	Speed1
     48  f243		       85 8a		      sta	Speed2
     49  f245		       85 8c		      sta	YPos2
     50  f247
     51  f247		       a9 00		      lda	#0
     52  f249		       85 90		      sta	ROW_DEMO_INDEX
     53  f24b
     54  f24b							; Store 0 into RamZeroByte
     55  f24b		       a9 00		      lda	#0
     56  f24d		       85 94		      sta	RamZeroByte
     57  f24f		       a9 3f		      lda	#%00111111
     58  f251		       85 95		      sta	RamLowerSixByte
     59  f253		       a9 ff		      lda	#$ff
     60  f255		       85 96		      sta	RamFFByte
     61  f257
     62  f257							; Setup level.
     63  f257		       20 da f9 	      jsr	game_state_setup
     64  f25a
     65  f25a							; Start with vertical sync (to reset frame)
     66  f25a		       4c 00 f4 	      jmp	VerticalSync
------- FILE main.s
------- FILE kernel_loader.s LEVEL 2 PASS 2
      0  f25d					      include	"kernel_loader.s"
      1  f25d							; Copies the gem kernels to RAM
      2  f25d
      3  f25d							; Copy Kernel A to CBSRAM
      4  f25d				   LoadKernelA subroutine
      5  f25d		       a0 37		      ldy	#(kernel_1_end - kernel_1_start)-1
      6  f25f				   .loop
      7  f25f		       b9 00 fc 	      lda	kernel_1_start,Y
      8  f262		       99 00 10 	      sta	$1000,Y
      9  f265		       88		      dey
     10  f266		       d0 f7		      bne	.loop
     11  f268		       ad 00 fc 	      lda	kernel_1_start
     12  f26b		       8d 00 10 	      sta	$1000
     13  f26e		       60		      rts
     14  f26f
     15  f26f							; Copy Kernel B to CBSRAM
     16  f26f				   LoadKernelB subroutine
     17  f26f		       a0 37		      ldy	#(kernel_2_end - kernel_2_start)-1
     18  f271				   .loop
     19  f271		       b9 38 fc 	      lda	kernel_2_start,Y
     20  f274		       99 00 10 	      sta	$1000,Y
     21  f277		       88		      dey
     22  f278		       d0 f7		      bne	.loop
     23  f27a		       ad 38 fc 	      lda	kernel_2_start
     24  f27d		       8d 00 10 	      sta	$1000
     25  f280		       60		      rts
------- FILE main.s
------- FILE nibble.s LEVEL 2 PASS 2
      0  f281					      include	"nibble.s"
      1  f281
      2  f281					      MAC	nibble_gem_kernel_a_1_build
      3  f281					      lda	#0
      4  f281					      ldx	#SENTINEL
      5  f281					      stx	BuildKernelX
      6  f281					      stx	BuildKernelY
      7  f281					      stx	BuildKernelRST
      8  f281							; Gemini 1A
      9  f281				   .K_1A
     10  f281					      ldy	[DO_GEMS_A + 0]
     11  f281					      jsr	KernelA_GenReset
     12  f281				   .if_1
     13  f281					      bne	.else_1
     14  f281					      sec
     15  f281					      rol
     16  f281							; Special: Encoding RST0
     17  f281							; Rewrite lda RamKernelPF1 to be #immediate
     18  f281					      ldy	#BC_LDA_IMM
     19  f281					      sty	[KernelA_B - $100]
     20  f281					      ldy	#%10100000
     21  f281					      sty	[KernelA_B - $100 + 1]
     22  f281							; Store 1A in GRP0
     23  f281					      ldy	[DO_GEMS_A + 1]
     24  f281					      sty	BuildKernelGrp0
     25  f281							; Gemini 1A is RESPx
     26  f281					      ldy	#EMERALD_SP_RESET
     27  f281					      sty	[KernelA_C - $100 + 1]
     28  f281							; Turn 3-cycle NOP into 4-cycle
     29  f281					      ldy	#$14
     30  f281					      sty	[KernelA_D - $100]
     31  f281					      jmp	.endif_1
     32  f281							; [BIT DEPTH] #1 If-End @ 1
     33  f281					      rol
     34  f281
     35  f281				   .else_1
     36  f281					      clc
     37  f281					      rol
     38  f281							; Store 0A in GRP0
     39  f281					      ldy	[DO_GEMS_A + 0]
     40  f281					      sty	BuildKernelGrp0
     41  f281					      ldy	[DO_GEMS_A + 1]
     42  f281					      jsr	KernelA_GenReset
     43  f281				   .if_2
     44  f281					      bne	.else_2
     45  f281					      sec
     46  f281					      rol
     47  f281							; GEM1ASWITCH
     48  f281					      jmp	.endif_2
     49  f281							; [BIT DEPTH] #2 If-End @ 2
     50  f281
     51  f281				   .else_2
     52  f281					      clc
     53  f281					      rol
     54  f281							; Calculate the 1A value
     55  f281					      ldy	SHARD_LUT_RF1
     56  f281					      cpy	#1
     57  f281					      .byte	$D0, #3
     58  f281					      ldy	#RESP1
     59  f281					      .byte	$2C
     60  f281					      ldy	#GRP1
     61  f281					      sty	RamKernelGemini1Reg
     62  f281							; Set opcode
     63  f281					      ldx	SHARD_LUT_RF1
     64  f281					      cpx	#1
     65  f281					      ldy	#BC_STX
     66  f281					      .byte	$F0, #5
     67  f281					      ldy	[DO_GEMS_A + 1]
     68  f281					      jsr	KernelA_UpdateRegs
     69  f281					      sty	RamKernelGemini1
     70  f281							; [BIT DEPTH] #2 *If-End @ 2
     71  f281							; [BIT DEPTH] #2 Else-End @ 2
     72  f281				   .endif_2
     73  f281							; [BIT DEPTH] #1 *If-End @ 1
     74  f281							; [BIT DEPTH] #1 Else-End @ 2
     75  f281				   .endif_1
     76  f281							; BuildKernelX, BuildKernelY are upgraded if not set
     77  f281							; Gemini 2A
     78  f281				   .K_2A
     79  f281					      ldy	[DO_GEMS_A + 2]
     80  f281					      jsr	KernelA_GenReset
     81  f281				   .if_3
     82  f281					      bne	.else_3
     83  f281					      sec
     84  f281					      rol
     85  f281					      jmp	.endif_3
     86  f281							; [BIT DEPTH] #3 If-End @ 3
     87  f281
     88  f281				   .else_3
     89  f281					      clc
     90  f281					      rol
     91  f281							; Set opcode
     92  f281					      ldy	[DO_GEMS_A + 2]
     93  f281					      jsr	KernelA_UpdateRegs
     94  f281					      sty	RamKernelGemini2
     95  f281							; Set opcode target
     96  f281					      ldy	SHARD_LUT_RF1
     97  f281					      cpy	#2
     98  f281					      .byte	$D0, #3
     99  f281					      ldy	#RESP1
    100  f281					      .byte	$2C
    101  f281					      ldy	#GRP1
    102  f281					      sty	RamKernelGemini2Reg
    103  f281							; [BIT DEPTH] #3 *If-End @ 3
    104  f281							; [BIT DEPTH] #3 Else-End @ 3
    105  f281				   .endif_3
    106  f281							; Gemini 3A
    107  f281				   .K_3A
    108  f281					      ldy	[DO_GEMS_A + 3]
    109  f281					      jsr	KernelA_GenReset
    110  f281				   .if_4
    111  f281					      bne	.else_4
    112  f281					      sec
    113  f281					      rol
    114  f281					      jmp	.endif_4
    115  f281							; [BIT DEPTH] #4 If-End @ 4
    116  f281
    117  f281				   .else_4
    118  f281					      clc
    119  f281					      rol
    120  f281							; Set opcode
    121  f281					      ldy	[DO_GEMS_A + 3]
    122  f281					      jsr	KernelA_UpdateRegs
    123  f281					      sty	RamKernelGemini3
    124  f281							; Set opcode target
    125  f281					      ldy	SHARD_LUT_RF1
    126  f281					      cpy	#3
    127  f281					      .byte	$D0, #3
    128  f281					      ldy	#RESP1
    129  f281					      .byte	$2C
    130  f281					      ldy	#GRP1
    131  f281					      sty	RamKernelGemini3Reg
    132  f281							; [BIT DEPTH] #4 *If-End @ 4
    133  f281							; [BIT DEPTH] #4 Else-End @ 4
    134  f281				   .endif_4
    135  f281							; [BIT DEPTH] Final: 4 (out of 8 bits)
    136  f281					      rol
    137  f281					      rol
    138  f281					      rol
    139  f281					      rol
    140  f281					      ENDM
    141  f281
    142  f281					      MAC	nibble_gem_kernel_a_2_build
    143  f281					      lda	#0
    144  f281							; VD1 default
    145  f281					      ldx	[DO_GEMS_A + 1]
    146  f281					      stx	BuildKernelVdel1
    147  f281							; Gemini 4A
    148  f281					      ldx	SHARD_LUT_VD1
    149  f281					      cpx	#4
    150  f281				   .if_1
    151  f281					      beq	.else_1
    152  f281					      sec
    153  f281					      rol
    154  f281							; Set PHP
    155  f281							; Update VDEL1
    156  f281					      ldx	[DO_GEMS_A + 4]
    157  f281					      stx	BuildKernelVdel1
    158  f281					      jmp	.endif_1
    159  f281							; [BIT DEPTH] #1 If-End @ 1
    160  f281
    161  f281				   .else_1
    162  f281					      clc
    163  f281					      rol
    164  f281					      ldy	[DO_GEMS_A + 4]
    165  f281					      jsr	KernelA_UpdateRegs
    166  f281					      sty	RamKernelGemini4
    167  f281							; Set PHP
    168  f281							; [BIT DEPTH] #1 *If-End @ 1
    169  f281							; [BIT DEPTH] #1 Else-End @ 1
    170  f281				   .endif_1
    171  f281							; Gemini 5A
    172  f281							; TODO eventually...?
    173  f281							; Missile
    174  f281					      ldy	DO_MISS_A
    175  f281				   .if_2
    176  f281					      bne	.else_2
    177  f281					      sec
    178  f281					      rol
    179  f281					      jmp	.endif_2
    180  f281							; [BIT DEPTH] #2 If-End @ 2
    181  f281
    182  f281				   .else_2
    183  f281					      clc
    184  f281					      rol
    185  f281							; [BIT DEPTH] #2 *If-End @ 2
    186  f281							; [BIT DEPTH] #2 Else-End @ 2
    187  f281				   .endif_2
    188  f281							; VD1
    189  f281							; GRP0
    190  f281							; X
    191  f281							; Y
    192  f281							; [BIT DEPTH] Final: 2 (out of 8 bits)
    193  f281					      rol
    194  f281					      rol
    195  f281					      rol
    196  f281					      rol
    197  f281					      rol
    198  f281					      rol
    199  f281					      ENDM
    200  f281
    201  f281					      MAC	nibble_gem_kernel_b_build
    202  f281					      lda	#0
    203  f281							; Php target default
    204  f281					      ldx	#RESP1
    205  f281					      stx	RamKernelPhpTarget
    206  f281					      ldx	#SENTINEL
    207  f281					      stx	BuildKernelX
    208  f281					      stx	BuildKernelY
    209  f281					      stx	BuildKernelRST
    210  f281							; Gemini 0B
    211  f281					      ldy	[DO_GEMS_B + 0]
    212  f281					      sty	BuildKernelGrp0
    213  f281							; NIBBLE_WRITE KernelB_D_W, RamKernelGemini0
    214  f281							; Gemini 1B
    215  f281					      ldy	[DO_GEMS_B + 1]
    216  f281					      jsr	KernelA_UpdateRegs
    217  f281					      sty	RamKernelGemini1
    218  f281							; Calculate Gemini 2B
    219  f281					      ldy	[DO_GEMS_B + 2]
    220  f281					      jsr	KernelB_UpdateRegs
    221  f281					      sty	RamKernelGemini2
    222  f281							; Calculate Gemini 3B
    223  f281					      ldy	[DO_GEMS_B + 3]
    224  f281					      jsr	KernelB_UpdateRegs
    225  f281					      sty	RamKernelGemini3
    226  f281							; Gemini 2B
    227  f281					      ldy	[DO_GEMS_B + 2]
    228  f281					      jsr	KernelB_GenPhp
    229  f281				   .if_1
    230  f281					      bne	.else_1
    231  f281					      sec
    232  f281					      rol
    233  f281							; Write to PHP in 2B
    234  f281					      jmp	.endif_1
    235  f281							; [BIT DEPTH] #1 If-End @ 1
    236  f281
    237  f281				   .else_1
    238  f281					      clc
    239  f281					      rol
    240  f281							; [BIT DEPTH] #1 *If-End @ 1
    241  f281							; [BIT DEPTH] #1 Else-End @ 1
    242  f281				   .endif_1
    243  f281							; Gemini 3B
    244  f281					      ldy	[DO_GEMS_B + 3]
    245  f281					      jsr	KernelB_GenPhp
    246  f281				   .if_2
    247  f281					      bne	.else_2
    248  f281					      sec
    249  f281					      rol
    250  f281							; Write to PHP in 3B
    251  f281					      jmp	.endif_2
    252  f281							; [BIT DEPTH] #2 If-End @ 2
    253  f281
    254  f281				   .else_2
    255  f281					      clc
    256  f281					      rol
    257  f281							; [BIT DEPTH] #2 *If-End @ 2
    258  f281							; [BIT DEPTH] #2 Else-End @ 2
    259  f281				   .endif_2
    260  f281							; Write out PHP
    261  f281					      ldy	BuildKernelRST
    262  f281					      cpy	#G01
    263  f281				   .if_3
    264  f281					      bne	.else_3
    265  f281					      sec
    266  f281					      rol
    267  f281					      jmp	.endif_3
    268  f281							; [BIT DEPTH] #3 If-End @ 3
    269  f281
    270  f281				   .else_3
    271  f281					      clc
    272  f281					      rol
    273  f281							; [BIT DEPTH] #3 *If-End @ 3
    274  f281							; [BIT DEPTH] #3 Else-End @ 3
    275  f281				   .endif_3
    276  f281							; Missile
    277  f281							; ldy DO_MISS_B
    278  f281							; NIBBLE_IF eq
    279  f281							; NIBBLE_WRITE [KernelB_K - $100], #BC_STA
    280  f281							; NIBBLE_ELSE
    281  f281							;     NIBBLE_WRITE [KernelB_K - $100], BuildKernelMissile
    282  f281							; NIBBLE_END_IF
    283  f281							; Gemini 4B
    284  f281					      ldy	[DO_GEMS_B + 4]
    285  f281					      jsr	KernelA_UpdateRegs
    286  f281					      sty	RamKernelGemini4
    287  f281							; TODO if no PHP, rewrite previous section:
    288  f281							; NIBBLE_IF cs
    289  f281							;
    290  f281							;     NIBBLE_WRITE [KernelB_E_W + 0], #BC_PHP
    291  f281							;     NIBBLE_WRITE [KernelB_F_W + 0], #BC_STY, #EMERALD_SP
    292  f281							;     NIBBLE_WRITE [KernelB_G_W + 0], #BC_STA, #PF1
    293  f281							;     NIBBLE_WRITE [KernelB_H_W + 0], #BC_STY, #EMERALD_SP
    294  f281							; NIBBLE_END_IF
    295  f281							; Make adjustments for sprites.
    296  f281					      ror	BuildKernelGrp0
    297  f281					      ror	BuildKernelX
    298  f281					      ror	BuildKernelY
    299  f281							;
    300  f281							; NIBBLE_WRITE [KernelB_VDEL1 - $100], BuildKernelVdel1
    301  f281							; GRP0
    302  f281							; X
    303  f281							; Y
    304  f281							; [BIT DEPTH] Final: 3 (out of 8 bits)
    305  f281					      rol
    306  f281					      rol
    307  f281					      rol
    308  f281					      rol
    309  f281					      rol
    310  f281					      ENDM
    311  f281
    312  f281
    313  f281					      MAC	nibble_gem_kernel_a_1
    314  f281				   .if_1
    315  f281					      asl
    316  f281					      bcc	.else_1
    317  f281					      jmp	.endif_1
    318  f281				   .else_1
    319  f281				   .if_2
    320  f281					      asl
    321  f281					      bcc	.else_2
    322  f281					      ldx	#BC_STX
    323  f281					      stx	[KernelA_D_W + 0]
    324  f281					      ldx	#RESP1
    325  f281					      stx	[KernelA_D_W + 1]
    326  f281					      jmp	.endif_2
    327  f281				   .else_2
    328  f281					      ldx	RamKernelGemini1
    329  f281					      stx	[KernelA_D_W + 0]
    330  f281					      ldx	RamKernelGemini1Reg
    331  f281					      stx	[KernelA_D_W + 1]
    332  f281				   .endif_2
    333  f281				   .endif_1
    334  f281				   .if_3
    335  f281					      asl
    336  f281					      bcc	.else_3
    337  f281					      ldx	#NOP_REG
    338  f281					      stx	[KernelA_E_W + 1 + 0]
    339  f281					      ldx	#RESP1
    340  f281					      stx	[KernelA_G_W + 1 + 0]
    341  f281					      jmp	.endif_3
    342  f281				   .else_3
    343  f281					      ldx	#RESP1
    344  f281					      stx	[KernelA_E_W + 1 + 0]
    345  f281					      ldx	RamKernelGemini2
    346  f281					      stx	[KernelA_G_W + 0]
    347  f281					      ldx	RamKernelGemini2Reg
    348  f281					      stx	[KernelA_G_W + 1]
    349  f281				   .endif_3
    350  f281				   .if_4
    351  f281					      asl
    352  f281					      bcc	.else_4
    353  f281					      ldx	#RESP1
    354  f281					      stx	[KernelA_H_W + 1 + 0]
    355  f281					      jmp	.endif_4
    356  f281				   .else_4
    357  f281					      ldx	RamKernelGemini3
    358  f281					      stx	[KernelA_H_W + 0]
    359  f281					      ldx	RamKernelGemini3Reg
    360  f281					      stx	[KernelA_H_W + 1]
    361  f281				   .endif_4
    362  f281					      ENDM
    363  f281
    364  f281					      MAC	nibble_gem_kernel_a_2
    365  f281				   .if_1
    366  f281					      asl
    367  f281					      bcc	.else_1
    368  f281					      ldx	#BC_STA
    369  f281					      stx	[[KernelA_I_W + 0] + 0]
    370  f281					      ldx	#EMERALD_SP_RESET
    371  f281					      stx	[[KernelA_I_W + 0] + 1]
    372  f281					      ldx	#BC_STA
    373  f281					      stx	[[KernelA_J_W + 1] + 0]
    374  f281					      ldx	#PF1
    375  f281					      stx	[[KernelA_J_W + 1] + 1]
    376  f281					      ldx	#BC_PHP
    377  f281					      stx	[[KernelA_K_W + 1] + 0]
    378  f281					      ldx	#VDELP1
    379  f281					      stx	[RamKernelPhpTarget + 0]
    380  f281					      jmp	.endif_1
    381  f281				   .else_1
    382  f281					      ldx	#BC_PHP
    383  f281					      stx	[[KernelA_I_W + 0] + 0]
    384  f281					      ldx	#BC_STA
    385  f281					      stx	[[KernelA_J_W + 0] + 0]
    386  f281					      ldx	#PF1
    387  f281					      stx	[[KernelA_J_W + 0] + 1]
    388  f281					      ldx	RamKernelGemini4
    389  f281					      stx	[KernelA_K_W + 0]
    390  f281					      ldx	#EMERALD_SP
    391  f281					      stx	[KernelA_K_W + 1]
    392  f281					      ldx	#RESP1
    393  f281					      stx	[RamKernelPhpTarget + 0]
    394  f281				   .endif_1
    395  f281				   .if_2
    396  f281					      asl
    397  f281					      bcc	.else_2
    398  f281					      ldx	#BC_NOP
    399  f281					      stx	[[KernelA_F - $100] + 0]
    400  f281					      jmp	.endif_2
    401  f281				   .else_2
    402  f281					      ldx	BuildKernelMissile
    403  f281					      stx	[[KernelA_F - $100] + 0]
    404  f281				   .endif_2
    405  f281					      ldx	BuildKernelVdel1
    406  f281					      stx	[[KernelA_VDEL1 - $100] + 0]
    407  f281					      ldx	BuildKernelGrp0
    408  f281					      stx	[[KernelA_VDEL0 - $100] + 0]
    409  f281					      ldx	BuildKernelX
    410  f281					      stx	[RamKernelX + 0]
    411  f281					      ldx	BuildKernelY
    412  f281					      stx	[RamKernelY + 0]
    413  f281					      ldx	#$ff
    414  f281					      stx	[RamPSByte + 0]
    415  f281					      ENDM
    416  f281
    417  f281					      MAC	nibble_gem_kernel_b
    418  f281					      ldx	RamKernelGemini1
    419  f281					      stx	[KernelB_D_W + 0]
    420  f281				   .if_1
    421  f281					      asl
    422  f281					      bcc	.else_1
    423  f281					      ldx	#EMERALD_SP
    424  f281					      stx	[RamKernelPhpTarget + 0]
    425  f281					      ldx	#BC_STY
    426  f281					      stx	[[KernelB_E_W + 0] + 0]
    427  f281					      ldx	#EMERALD_SP_RESET
    428  f281					      stx	[[KernelB_E_W + 0] + 1]
    429  f281					      ldx	#BC_PHP
    430  f281					      stx	[[KernelB_F_W + 1] + 0]
    431  f281					      ldx	#BC_STA
    432  f281					      stx	[[KernelB_G_W + 0] + 0]
    433  f281					      ldx	#PF1
    434  f281					      stx	[[KernelB_G_W + 0] + 1]
    435  f281					      ldx	RamKernelGemini3
    436  f281					      stx	[[KernelB_H_W + 0] + 0]
    437  f281					      ldx	#EMERALD_SP
    438  f281					      stx	[[KernelB_H_W + 0] + 1]
    439  f281					      jmp	.endif_1
    440  f281				   .else_1
    441  f281					      ldx	RamKernelGemini2
    442  f281					      stx	[KernelB_F_W + 0]
    443  f281					      ldx	#EMERALD_SP
    444  f281					      stx	[KernelB_F_W + 1]
    445  f281				   .endif_1
    446  f281				   .if_2
    447  f281					      asl
    448  f281					      bcc	.else_2
    449  f281					      ldx	#EMERALD_SP
    450  f281					      stx	[RamKernelPhpTarget + 0]
    451  f281					      ldx	#BC_STY
    452  f281					      stx	[[KernelB_E_W + 0] + 0]
    453  f281					      ldx	#EMERALD_SP_RESET
    454  f281					      stx	[[KernelB_E_W + 0] + 1]
    455  f281					      ldx	RamKernelGemini2
    456  f281					      stx	[[KernelB_F_W + 1] + 0]
    457  f281					      ldx	#EMERALD_SP
    458  f281					      stx	[[KernelB_F_W + 1] + 1]
    459  f281					      ldx	#BC_STA
    460  f281					      stx	[[KernelB_G_W + 1] + 0]
    461  f281					      ldx	#PF1
    462  f281					      stx	[[KernelB_G_W + 1] + 1]
    463  f281					      ldx	#BC_PHP
    464  f281					      stx	[[KernelB_H_W + 1] + 0]
    465  f281					      jmp	.endif_2
    466  f281				   .else_2
    467  f281					      ldx	RamKernelGemini3
    468  f281					      stx	[KernelB_H_W + 0]
    469  f281					      ldx	#EMERALD_SP
    470  f281					      stx	[KernelB_H_W + 1]
    471  f281				   .endif_2
    472  f281				   .if_3
    473  f281					      asl
    474  f281					      bcc	.else_3
    475  f281					      ldx	#$c5
    476  f281					      stx	[[KernelB_C - $100] + 0]
    477  f281					      ldx	#RamFFByte
    478  f281					      stx	[[KernelB_C - $100] + 1]
    479  f281					      jmp	.endif_3
    480  f281				   .else_3
    481  f281					      ldx	#$c5
    482  f281					      stx	[[KernelB_C - $100] + 0]
    483  f281					      ldx	#RamPF1Value
    484  f281					      stx	[[KernelB_C - $100] + 1]
    485  f281				   .endif_3
    486  f281					      ldx	RamKernelGemini4
    487  f281					      stx	[KernelB_J_W + 0]
    488  f281					      ldx	BuildKernelGrp0
    489  f281					      stx	[[KernelB_VDEL0 - $100] + 0]
    490  f281					      ldx	BuildKernelX
    491  f281					      stx	[RamKernelX + 0]
    492  f281					      ldx	BuildKernelY
    493  f281					      stx	[RamKernelY + 0]
    494  f281					      ldx	#$00
    495  f281					      stx	[RamPSByte + 0]
    496  f281					      ENDM
    497  f281
    498  f281
------- FILE main.s
------- FILE nibble_shard.s LEVEL 2 PASS 2
      0  f281					      include	"nibble_shard.s"
      1  f281							; conflict: 11011000 #%0011 #%1000
      2  f281							; conflict: 11011001 #%0011 #%1000
      3  f281							; conflict: 11011010 #%0011 #%1000
      4  f281							; conflict: 11011011 #%0011 #%1000
      5  f281							; conflict: 11100100 #%1000 #%0011
      6  f281							; conflict: 11100101 #%1000 #%0011
      7  f281							; conflict: 11100110 #%1000 #%0011
      8  f281							; conflict: 11100111 #%1000 #%0011
      9  f281							; conflict: 01111000 #%1000 #%0001
     10  f281							; conflict: 01111001 #%1000 #%0001
     11  f281							; conflict: 01111010 #%1000 #%0001
     12  f281							; conflict: 01111011 #%1000 #%0001
     13  f281							; conflict: 10110100 #%1000 #%0001
     14  f281							; conflict: 10110101 #%1000 #%0001
     15  f281							; conflict: 10110110 #%1000 #%0001
     16  f281							; conflict: 10110111 #%1000 #%0001
     17  f300		       00 00 00 00*	      align	256
     18  f300		       00	   .shard_0   .byte.b	#0
     19  f301		       00	   .shard_1   .byte.b	#0
     20  f302		       00	   .shard_2   .byte.b	#0
     21  f303		       00	   .shard_3   .byte.b	#0
     22  f304		       00	   .shard_4   .byte.b	#0
     23  f305		       00	   .shard_5   .byte.b	#0
     24  f306		       00	   .shard_6   .byte.b	#0
     25  f307		       00	   .shard_7   .byte.b	#0
     26  f308		       00	   .shard_8   .byte.b	#0
     27  f309		       00	   .shard_9   .byte.b	#0
     28  f30a		       00	   .shard_10  .byte.b	#0
     29  f30b		       00	   .shard_11  .byte.b	#0
     30  f30c		       00	   .shard_12  .byte.b	#0
     31  f30d		       00	   .shard_13  .byte.b	#0
     32  f30e		       00	   .shard_14  .byte.b	#0
     33  f30f		       00	   .shard_15  .byte.b	#0
     34  f310		       00	   .shard_16  .byte.b	#0
     35  f311		       00	   .shard_17  .byte.b	#0
     36  f312		       00	   .shard_18  .byte.b	#0
     37  f313		       00	   .shard_19  .byte.b	#0
     38  f314		       00	   .shard_20  .byte.b	#0
     39  f315		       00	   .shard_21  .byte.b	#0
     40  f316		       00	   .shard_22  .byte.b	#0
     41  f317		       00	   .shard_23  .byte.b	#0
     42  f318		       00	   .shard_24  .byte.b	#0
     43  f319		       00	   .shard_25  .byte.b	#0
     44  f31a		       00	   .shard_26  .byte.b	#0
     45  f31b		       00	   .shard_27  .byte.b	#0
     46  f31c		       00	   .shard_28  .byte.b	#0
     47  f31d		       00	   .shard_29  .byte.b	#0
     48  f31e		       00	   .shard_30  .byte.b	#0
     49  f31f		       00	   .shard_31  .byte.b	#0
     50  f320		       00	   .shard_32  .byte.b	#0
     51  f321		       00	   .shard_33  .byte.b	#0
     52  f322		       00	   .shard_34  .byte.b	#0
     53  f323		       00	   .shard_35  .byte.b	#0
     54  f324		       00	   .shard_36  .byte.b	#0
     55  f325		       00	   .shard_37  .byte.b	#0
     56  f326		       00	   .shard_38  .byte.b	#0
     57  f327		       00	   .shard_39  .byte.b	#0
     58  f328		       00	   .shard_40  .byte.b	#0
     59  f329		       00	   .shard_41  .byte.b	#0
     60  f32a		       00	   .shard_42  .byte.b	#0
     61  f32b		       00	   .shard_43  .byte.b	#0
     62  f32c		       00	   .shard_44  .byte.b	#0
     63  f32d		       00	   .shard_45  .byte.b	#0
     64  f32e		       00	   .shard_46  .byte.b	#0
     65  f32f		       00	   .shard_47  .byte.b	#0
     66  f330		       00	   .shard_48  .byte.b	#0
     67  f331		       00	   .shard_49  .byte.b	#0
     68  f332		       00	   .shard_50  .byte.b	#0
     69  f333		       00	   .shard_51  .byte.b	#0
     70  f334		       00	   .shard_52  .byte.b	#0
     71  f335		       00	   .shard_53  .byte.b	#0
     72  f336		       00	   .shard_54  .byte.b	#0
     73  f337		       00	   .shard_55  .byte.b	#0
     74  f338		       00	   .shard_56  .byte.b	#0
     75  f339		       00	   .shard_57  .byte.b	#0
     76  f33a		       00	   .shard_58  .byte.b	#0
     77  f33b		       00	   .shard_59  .byte.b	#0
     78  f33c		       00	   .shard_60  .byte.b	#0
     79  f33d		       00	   .shard_61  .byte.b	#0
     80  f33e		       00	   .shard_62  .byte.b	#0
     81  f33f		       00	   .shard_63  .byte.b	#0
     82  f340		       00	   .shard_64  .byte.b	#0
     83  f341		       00	   .shard_65  .byte.b	#0
     84  f342		       00	   .shard_66  .byte.b	#0
     85  f343		       00	   .shard_67  .byte.b	#0
     86  f344		       00	   .shard_68  .byte.b	#0
     87  f345		       00	   .shard_69  .byte.b	#0
     88  f346		       00	   .shard_70  .byte.b	#0
     89  f347		       00	   .shard_71  .byte.b	#0
     90  f348		       00	   .shard_72  .byte.b	#0
     91  f349		       00	   .shard_73  .byte.b	#0
     92  f34a		       00	   .shard_74  .byte.b	#0
     93  f34b		       00	   .shard_75  .byte.b	#0
     94  f34c		       00	   .shard_76  .byte.b	#0
     95  f34d		       00	   .shard_77  .byte.b	#0
     96  f34e		       00	   .shard_78  .byte.b	#0
     97  f34f		       00	   .shard_79  .byte.b	#0
     98  f350		       00	   .shard_80  .byte.b	#0
     99  f351		       00	   .shard_81  .byte.b	#0
    100  f352		       00	   .shard_82  .byte.b	#0
    101  f353		       00	   .shard_83  .byte.b	#0
    102  f354		       00	   .shard_84  .byte.b	#0
    103  f355		       00	   .shard_85  .byte.b	#0
    104  f356		       00	   .shard_86  .byte.b	#0
    105  f357		       00	   .shard_87  .byte.b	#0
    106  f358		       00	   .shard_88  .byte.b	#0
    107  f359		       00	   .shard_89  .byte.b	#0
    108  f35a		       00	   .shard_90  .byte.b	#0
    109  f35b		       00	   .shard_91  .byte.b	#0
    110  f35c		       00	   .shard_92  .byte.b	#0
    111  f35d		       00	   .shard_93  .byte.b	#0
    112  f35e		       00	   .shard_94  .byte.b	#0
    113  f35f		       00	   .shard_95  .byte.b	#0
    114  f360		       00	   .shard_96  .byte.b	#0
    115  f361		       00	   .shard_97  .byte.b	#0
    116  f362		       00	   .shard_98  .byte.b	#0
    117  f363		       00	   .shard_99  .byte.b	#0
    118  f364		       00	   .shard_100 .byte.b	#0
    119  f365		       00	   .shard_101 .byte.b	#0
    120  f366		       00	   .shard_102 .byte.b	#0
    121  f367		       00	   .shard_103 .byte.b	#0
    122  f368		       00	   .shard_104 .byte.b	#0
    123  f369		       00	   .shard_105 .byte.b	#0
    124  f36a		       00	   .shard_106 .byte.b	#0
    125  f36b		       00	   .shard_107 .byte.b	#0
    126  f36c		       02	   .shard_108 .byte.b	#%0010
    127  f36d		       02	   .shard_109 .byte.b	#%0010
    128  f36e		       02	   .shard_110 .byte.b	#%0010
    129  f36f		       02	   .shard_111 .byte.b	#%0010
    130  f370		       00	   .shard_112 .byte.b	#0
    131  f371		       00	   .shard_113 .byte.b	#0
    132  f372		       00	   .shard_114 .byte.b	#0
    133  f373		       00	   .shard_115 .byte.b	#0
    134  f374		       00	   .shard_116 .byte.b	#0
    135  f375		       00	   .shard_117 .byte.b	#0
    136  f376		       00	   .shard_118 .byte.b	#0
    137  f377		       00	   .shard_119 .byte.b	#0
    138  f378		       08	   .shard_120 .byte.b	#%1000
    139  f379		       08	   .shard_121 .byte.b	#%1000
    140  f37a		       08	   .shard_122 .byte.b	#%1000
    141  f37b		       08	   .shard_123 .byte.b	#%1000
    142  f37c		       00	   .shard_124 .byte.b	#0
    143  f37d		       00	   .shard_125 .byte.b	#0
    144  f37e		       00	   .shard_126 .byte.b	#0
    145  f37f		       00	   .shard_127 .byte.b	#0
    146  f380		       00	   .shard_128 .byte.b	#0
    147  f381		       00	   .shard_129 .byte.b	#0
    148  f382		       00	   .shard_130 .byte.b	#0
    149  f383		       00	   .shard_131 .byte.b	#0
    150  f384		       00	   .shard_132 .byte.b	#0
    151  f385		       00	   .shard_133 .byte.b	#0
    152  f386		       00	   .shard_134 .byte.b	#0
    153  f387		       00	   .shard_135 .byte.b	#0
    154  f388		       00	   .shard_136 .byte.b	#0
    155  f389		       00	   .shard_137 .byte.b	#0
    156  f38a		       00	   .shard_138 .byte.b	#0
    157  f38b		       00	   .shard_139 .byte.b	#0
    158  f38c		       00	   .shard_140 .byte.b	#0
    159  f38d		       00	   .shard_141 .byte.b	#0
    160  f38e		       00	   .shard_142 .byte.b	#0
    161  f38f		       00	   .shard_143 .byte.b	#0
    162  f390		       00	   .shard_144 .byte.b	#0
    163  f391		       00	   .shard_145 .byte.b	#0
    164  f392		       00	   .shard_146 .byte.b	#0
    165  f393		       00	   .shard_147 .byte.b	#0
    166  f394		       00	   .shard_148 .byte.b	#0
    167  f395		       00	   .shard_149 .byte.b	#0
    168  f396		       00	   .shard_150 .byte.b	#0
    169  f397		       00	   .shard_151 .byte.b	#0
    170  f398		       00	   .shard_152 .byte.b	#0
    171  f399		       00	   .shard_153 .byte.b	#0
    172  f39a		       00	   .shard_154 .byte.b	#0
    173  f39b		       00	   .shard_155 .byte.b	#0
    174  f39c		       02	   .shard_156 .byte.b	#%0010
    175  f39d		       02	   .shard_157 .byte.b	#%0010
    176  f39e		       02	   .shard_158 .byte.b	#%0010
    177  f39f		       02	   .shard_159 .byte.b	#%0010
    178  f3a0		       00	   .shard_160 .byte.b	#0
    179  f3a1		       00	   .shard_161 .byte.b	#0
    180  f3a2		       00	   .shard_162 .byte.b	#0
    181  f3a3		       00	   .shard_163 .byte.b	#0
    182  f3a4		       00	   .shard_164 .byte.b	#0
    183  f3a5		       00	   .shard_165 .byte.b	#0
    184  f3a6		       00	   .shard_166 .byte.b	#0
    185  f3a7		       00	   .shard_167 .byte.b	#0
    186  f3a8		       00	   .shard_168 .byte.b	#0
    187  f3a9		       00	   .shard_169 .byte.b	#0
    188  f3aa		       00	   .shard_170 .byte.b	#0
    189  f3ab		       00	   .shard_171 .byte.b	#0
    190  f3ac		       00	   .shard_172 .byte.b	#0
    191  f3ad		       00	   .shard_173 .byte.b	#0
    192  f3ae		       00	   .shard_174 .byte.b	#0
    193  f3af		       00	   .shard_175 .byte.b	#0
    194  f3b0		       00	   .shard_176 .byte.b	#0
    195  f3b1		       00	   .shard_177 .byte.b	#0
    196  f3b2		       00	   .shard_178 .byte.b	#0
    197  f3b3		       00	   .shard_179 .byte.b	#0
    198  f3b4		       08	   .shard_180 .byte.b	#%1000
    199  f3b5		       08	   .shard_181 .byte.b	#%1000
    200  f3b6		       08	   .shard_182 .byte.b	#%1000
    201  f3b7		       08	   .shard_183 .byte.b	#%1000
    202  f3b8		       00	   .shard_184 .byte.b	#0
    203  f3b9		       00	   .shard_185 .byte.b	#0
    204  f3ba		       00	   .shard_186 .byte.b	#0
    205  f3bb		       00	   .shard_187 .byte.b	#0
    206  f3bc		       00	   .shard_188 .byte.b	#0
    207  f3bd		       00	   .shard_189 .byte.b	#0
    208  f3be		       00	   .shard_190 .byte.b	#0
    209  f3bf		       00	   .shard_191 .byte.b	#0
    210  f3c0		       00	   .shard_192 .byte.b	#0
    211  f3c1		       00	   .shard_193 .byte.b	#0
    212  f3c2		       00	   .shard_194 .byte.b	#0
    213  f3c3		       00	   .shard_195 .byte.b	#0
    214  f3c4		       00	   .shard_196 .byte.b	#0
    215  f3c5		       00	   .shard_197 .byte.b	#0
    216  f3c6		       00	   .shard_198 .byte.b	#0
    217  f3c7		       00	   .shard_199 .byte.b	#0
    218  f3c8		       00	   .shard_200 .byte.b	#0
    219  f3c9		       00	   .shard_201 .byte.b	#0
    220  f3ca		       00	   .shard_202 .byte.b	#0
    221  f3cb		       00	   .shard_203 .byte.b	#0
    222  f3cc		       00	   .shard_204 .byte.b	#0
    223  f3cd		       00	   .shard_205 .byte.b	#0
    224  f3ce		       00	   .shard_206 .byte.b	#0
    225  f3cf		       00	   .shard_207 .byte.b	#0
    226  f3d0		       00	   .shard_208 .byte.b	#0
    227  f3d1		       00	   .shard_209 .byte.b	#0
    228  f3d2		       00	   .shard_210 .byte.b	#0
    229  f3d3		       00	   .shard_211 .byte.b	#0
    230  f3d4		       00	   .shard_212 .byte.b	#0
    231  f3d5		       00	   .shard_213 .byte.b	#0
    232  f3d6		       00	   .shard_214 .byte.b	#0
    233  f3d7		       00	   .shard_215 .byte.b	#0
    234  f3d8		       03	   .shard_216 .byte.b	#%0011
    235  f3d9		       03	   .shard_217 .byte.b	#%0011
    236  f3da		       03	   .shard_218 .byte.b	#%0011
    237  f3db		       03	   .shard_219 .byte.b	#%0011
    238  f3dc		       00	   .shard_220 .byte.b	#0
    239  f3dd		       00	   .shard_221 .byte.b	#0
    240  f3de		       00	   .shard_222 .byte.b	#0
    241  f3df		       00	   .shard_223 .byte.b	#0
    242  f3e0		       00	   .shard_224 .byte.b	#0
    243  f3e1		       00	   .shard_225 .byte.b	#0
    244  f3e2		       00	   .shard_226 .byte.b	#0
    245  f3e3		       00	   .shard_227 .byte.b	#0
    246  f3e4		       08	   .shard_228 .byte.b	#%1000
    247  f3e5		       08	   .shard_229 .byte.b	#%1000
    248  f3e6		       08	   .shard_230 .byte.b	#%1000
    249  f3e7		       08	   .shard_231 .byte.b	#%1000
    250  f3e8		       00	   .shard_232 .byte.b	#0
    251  f3e9		       00	   .shard_233 .byte.b	#0
    252  f3ea		       00	   .shard_234 .byte.b	#0
    253  f3eb		       00	   .shard_235 .byte.b	#0
    254  f3ec		       00	   .shard_236 .byte.b	#0
    255  f3ed		       00	   .shard_237 .byte.b	#0
    256  f3ee		       00	   .shard_238 .byte.b	#0
    257  f3ef		       00	   .shard_239 .byte.b	#0
    258  f3f0		       00	   .shard_240 .byte.b	#0
    259  f3f1		       00	   .shard_241 .byte.b	#0
    260  f3f2		       00	   .shard_242 .byte.b	#0
    261  f3f3		       00	   .shard_243 .byte.b	#0
    262  f3f4		       00	   .shard_244 .byte.b	#0
    263  f3f5		       00	   .shard_245 .byte.b	#0
    264  f3f6		       00	   .shard_246 .byte.b	#0
    265  f3f7		       00	   .shard_247 .byte.b	#0
    266  f3f8		       00	   .shard_248 .byte.b	#0
    267  f3f9		       00	   .shard_249 .byte.b	#0
    268  f3fa		       00	   .shard_250 .byte.b	#0
    269  f3fb		       00	   .shard_251 .byte.b	#0
    270  f3fc		       00	   .shard_252 .byte.b	#0
    271  f3fd		       00	   .shard_253 .byte.b	#0
    272  f3fe		       00	   .shard_254 .byte.b	#0
    273  f3ff		       00	   .shard_255 .byte.b	#0
------- FILE main.s
------- FILE game_frame.s LEVEL 2 PASS 2
      0  f400					      include	"game_frame.s"
      1  f400
      2  f400							; Vertical Sync
      3  f400				   VerticalSync subroutine
      0  f400					      VERTICAL_SYNC
      1  f400		       a9 0e		      lda	#%1110
      2  f402		       85 02	   .VSLP1     sta	WSYNC
      3  f404		       85 00		      sta	VSYNC
      4  f406		       4a		      lsr
      5  f407		       d0 f9		      bne	.VSLP1
      5  f409
      6  f409				   FrameStart subroutine
      7  f409							; FIXME we can't skip this: ASSERT_RUNTIME "_scan == #0"
      8  f409
      9  f409				   VerticalBlank subroutine
      0  f409					      TIMER_SETUP	37
      1  f409				   .lines     SET	37
      2  f409		       a9 2b		      lda	#(((.lines)*76-14)/64)
      3  f40b		       85 02		      sta	WSYNC
      4  f40d		       8d 96 02 	      sta	TIM64T
     11  f410
     12  f410							; Scanline counter
     13  f410		       a9 10		      lda	#ROW_COUNT
     14  f412		       85 84		      sta	LoopCount
     15  f414
     16  f414							; Frame counter
     17  f414		       e6 85		      inc	FrameCount
     18  f416
     19  f416							; Skip every 8 frames for increasing demo index
     20  f416		       a5 85		      lda	FrameCount
     21  f418		       29 07		      and	#FrameSkip
     22  f41a		       c9 07		      cmp	#FrameSkip
     23  f41c		       d0 0d		      bne	.next_next_thing
     24  f41e
     25  f41e		       18		      clc
     26  f41f		       a5 90		      lda	ROW_DEMO_INDEX
     27  f421		       69 04		      adc	#4
     28  f423		       c9 68		      cmp	#[level_01_end - level_01]
     29  f425		       90 02		      bcc	.next_thing_local
     30  f427		       a9 00		      lda	#0
     31  f429				   .next_thing_local
     32  f429		       85 90		      sta	ROW_DEMO_INDEX
     33  f42b				   .next_next_thing
     34  f42b		       85 02		      sta	WSYNC
     35  f42d
     36  f42d							; Positioning
      0  f42d					      SLEEP	40
      1  f42d				   .CYCLES    SET	40
      2  f42d
      3  f42d				  -	      IF	.CYCLES < 2
      4  f42d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f42d				  -	      ERR
      6  f42d					      ENDIF
      7  f42d
      8  f42d				  -	      IF	.CYCLES & 1
      9  f42d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f42d				  -	      nop	0
     11  f42d				  -	      ELSE
     12  f42d				  -	      bit	VSYNC
     13  f42d				  -	      ENDIF
     14  f42d				  -.CYCLES    SET	.CYCLES - 3
     15  f42d					      ENDIF
     16  f42d
     17  f42d					      REPEAT	.CYCLES / 2
     18  f42d		       ea		      nop
     17  f42d					      REPEND
     18  f42e		       ea		      nop
     17  f42e					      REPEND
     18  f42f		       ea		      nop
     17  f42f					      REPEND
     18  f430		       ea		      nop
     17  f430					      REPEND
     18  f431		       ea		      nop
     17  f431					      REPEND
     18  f432		       ea		      nop
     17  f432					      REPEND
     18  f433		       ea		      nop
     17  f433					      REPEND
     18  f434		       ea		      nop
     17  f434					      REPEND
     18  f435		       ea		      nop
     17  f435					      REPEND
     18  f436		       ea		      nop
     17  f436					      REPEND
     18  f437		       ea		      nop
     17  f437					      REPEND
     18  f438		       ea		      nop
     17  f438					      REPEND
     18  f439		       ea		      nop
     17  f439					      REPEND
     18  f43a		       ea		      nop
     17  f43a					      REPEND
     18  f43b		       ea		      nop
     17  f43b					      REPEND
     18  f43c		       ea		      nop
     17  f43c					      REPEND
     18  f43d		       ea		      nop
     17  f43d					      REPEND
     18  f43e		       ea		      nop
     17  f43e					      REPEND
     18  f43f		       ea		      nop
     17  f43f					      REPEND
     18  f440		       ea		      nop
     19  f441					      REPEND
     38  f441		       85 11		      sta	EMERALD_SP_RESET	; position 1st player
     39  f443		       85 02		      sta	WSYNC
     40  f445
     41  f445							; Misc
     42  f445		       a9 00		      lda	#00
     43  f447		       85 1e		      sta	EMERALD_MI_ENABLE
     44  f449
     45  f449							; Assign dervied SpriteEnd value
     46  f449		       18		      clc
     47  f44a		       a9 c8		      lda	#HEIGHT_OFFSET
     48  f44c		       e5 8b		      sbc	YPos
     49  f44e		       85 87		      sta	SpriteEnd
     50  f450
     51  f450							; Player 1
     52  f450		       a5 88		      lda	XPos
     53  f452		       a2 00		      ldx	#0
     54  f454		       20 bd f5 	      jsr	SetHorizPos
     55  f457
     56  f457							; Load the kernel into CBSRAM.
     57  f457				   game_frame_kernel_loader subroutine
     58  f457							; Kernel A or B
     59  f457		       a9 01		      lda	#01
     60  f459		       25 85		      and	FrameCount
     61  f45b		       d0 06		      bne	.kernel_b
     62  f45d				   .kernel_a
     63  f45d							; Load kernel A into CBSRAM
     64  f45d		       20 5d f2 	      jsr	LoadKernelA
     65  f460		       4c 66 f4 	      jmp	.complete
     66  f463				   .kernel_b
     67  f463							; Load kernel B into CBSRAM
     68  f463		       20 6f f2 	      jsr	LoadKernelB
     69  f466				   .complete
     70  f466
     71  f466							; Populate the kernel with gemini changes.
     72  f466				   game_frame_populate subroutine
     73  f466							; Extract 26-bit string to full Gemini profile
     74  f466		       20 00 f9 	      jsr	gemini_populate
     75  f469							; Run nibble populate.
     76  f469		       20 2a f6 	      jsr	game_nibble_populate
     77  f46c
     78  f46c							; Complete frame setup.
     79  f46c				   game_frame_setup subroutine
     80  f46c							; Kernel A or B
     81  f46c		       a9 01		      lda	#01
     82  f46e		       25 85		      and	FrameCount
     83  f470		       d0 1d		      bne	.kernel_b
     84  f472
     85  f472				   .kernel_a
     86  f472							; Move missile
     87  f472		       85 02		      sta	WSYNC
      0  f474					      sleep	KERNEL_A_MISSILE_SLEEP
      1  f474				   .CYCLES    SET	KERNEL_A_MISSILE_SLEEP
      2  f474
      3  f474				  -	      IF	.CYCLES < 2
      4  f474				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f474				  -	      ERR
      6  f474					      ENDIF
      7  f474
      8  f474				  -	      IF	.CYCLES & 1
      9  f474				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f474				  -	      nop	0
     11  f474				  -	      ELSE
     12  f474				  -	      bit	VSYNC
     13  f474				  -	      ENDIF
     14  f474				  -.CYCLES    SET	.CYCLES - 3
     15  f474					      ENDIF
     16  f474
     17  f474					      REPEAT	.CYCLES / 2
     18  f474		       ea		      nop
     17  f474					      REPEND
     18  f475		       ea		      nop
     17  f475					      REPEND
     18  f476		       ea		      nop
     17  f476					      REPEND
     18  f477		       ea		      nop
     17  f477					      REPEND
     18  f478		       ea		      nop
     17  f478					      REPEND
     18  f479		       ea		      nop
     17  f479					      REPEND
     18  f47a		       ea		      nop
     17  f47a					      REPEND
     18  f47b		       ea		      nop
     17  f47b					      REPEND
     18  f47c		       ea		      nop
     17  f47c					      REPEND
     18  f47d		       ea		      nop
     17  f47d					      REPEND
     18  f47e		       ea		      nop
     17  f47e					      REPEND
     18  f47f		       ea		      nop
     17  f47f					      REPEND
     18  f480		       ea		      nop
     17  f480					      REPEND
     18  f481		       ea		      nop
     19  f482					      REPEND
     89  f482		       85 13		      sta	EMERALD_MI_RESET
     90  f484		       a9 00		      lda	#KERNEL_A_MISSILE_HMOVE
     91  f486		       85 23		      sta	EMERALD_MI_HMOVE
     92  f488
     93  f488							; DEBUG: Set per-kernel color
     94  f488		       a2 cc		      ldx	#COL_EMERALD
     95  f48a		       86 07		      stx	EMERALD_SP_COLOR
     96  f48c
     97  f48c		       4c e0 f4 	      jmp	.complete
     98  f48f
     99  f48f				   .kernel_b
    100  f48f							; Move missile
    101  f48f		       85 02		      sta	WSYNC
      0  f491					      sleep	KERNEL_B_MISSILE_SLEEP
      1  f491				   .CYCLES    SET	KERNEL_B_MISSILE_SLEEP
      2  f491
      3  f491				  -	      IF	.CYCLES < 2
      4  f491				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f491				  -	      ERR
      6  f491					      ENDIF
      7  f491
      8  f491					      IF	.CYCLES & 1
      9  f491					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f491		       04 00		      nop	0
     11  f493				  -	      ELSE
     12  f493				  -	      bit	VSYNC
     13  f493					      ENDIF
     14  f493				   .CYCLES    SET	.CYCLES - 3
     15  f493					      ENDIF
     16  f493
     17  f493					      REPEAT	.CYCLES / 2
     18  f493		       ea		      nop
     17  f493					      REPEND
     18  f494		       ea		      nop
     17  f494					      REPEND
     18  f495		       ea		      nop
     17  f495					      REPEND
     18  f496		       ea		      nop
     17  f496					      REPEND
     18  f497		       ea		      nop
     17  f497					      REPEND
     18  f498		       ea		      nop
     17  f498					      REPEND
     18  f499		       ea		      nop
     17  f499					      REPEND
     18  f49a		       ea		      nop
     17  f49a					      REPEND
     18  f49b		       ea		      nop
     17  f49b					      REPEND
     18  f49c		       ea		      nop
     17  f49c					      REPEND
     18  f49d		       ea		      nop
     17  f49d					      REPEND
     18  f49e		       ea		      nop
     17  f49e					      REPEND
     18  f49f		       ea		      nop
     17  f49f					      REPEND
     18  f4a0		       ea		      nop
     17  f4a0					      REPEND
     18  f4a1		       ea		      nop
     17  f4a1					      REPEND
     18  f4a2		       ea		      nop
     17  f4a2					      REPEND
     18  f4a3		       ea		      nop
     17  f4a3					      REPEND
     18  f4a4		       ea		      nop
     17  f4a4					      REPEND
     18  f4a5		       ea		      nop
     17  f4a5					      REPEND
     18  f4a6		       ea		      nop
     17  f4a6					      REPEND
     18  f4a7		       ea		      nop
     17  f4a7					      REPEND
     18  f4a8		       ea		      nop
     17  f4a8					      REPEND
     18  f4a9		       ea		      nop
     17  f4a9					      REPEND
     18  f4aa		       ea		      nop
     19  f4ab					      REPEND
    103  f4ab		       85 13		      sta	EMERALD_MI_RESET
    104  f4ad		       a9 10		      lda	#KERNEL_B_MISSILE_HMOVE
    105  f4af		       85 23		      sta	EMERALD_MI_HMOVE
    106  f4b1
    107  f4b1		       a5 b3		      lda	DO_MISS_B
    108  f4b3		       d0 25		      bne	.kernel_b_continue
    109  f4b5		       85 02		      sta	WSYNC
      0  f4b7					      sleep	KERNEL_B_MISSILE_SLEEP + 8
      1  f4b7				   .CYCLES    SET	KERNEL_B_MISSILE_SLEEP + 8
      2  f4b7
      3  f4b7				  -	      IF	.CYCLES < 2
      4  f4b7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f4b7				  -	      ERR
      6  f4b7					      ENDIF
      7  f4b7
      8  f4b7					      IF	.CYCLES & 1
      9  f4b7					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f4b7		       04 00		      nop	0
     11  f4b9				  -	      ELSE
     12  f4b9				  -	      bit	VSYNC
     13  f4b9					      ENDIF
     14  f4b9				   .CYCLES    SET	.CYCLES - 3
     15  f4b9					      ENDIF
     16  f4b9
     17  f4b9					      REPEAT	.CYCLES / 2
     18  f4b9		       ea		      nop
     17  f4b9					      REPEND
     18  f4ba		       ea		      nop
     17  f4ba					      REPEND
     18  f4bb		       ea		      nop
     17  f4bb					      REPEND
     18  f4bc		       ea		      nop
     17  f4bc					      REPEND
     18  f4bd		       ea		      nop
     17  f4bd					      REPEND
     18  f4be		       ea		      nop
     17  f4be					      REPEND
     18  f4bf		       ea		      nop
     17  f4bf					      REPEND
     18  f4c0		       ea		      nop
     17  f4c0					      REPEND
     18  f4c1		       ea		      nop
     17  f4c1					      REPEND
     18  f4c2		       ea		      nop
     17  f4c2					      REPEND
     18  f4c3		       ea		      nop
     17  f4c3					      REPEND
     18  f4c4		       ea		      nop
     17  f4c4					      REPEND
     18  f4c5		       ea		      nop
     17  f4c5					      REPEND
     18  f4c6		       ea		      nop
     17  f4c6					      REPEND
     18  f4c7		       ea		      nop
     17  f4c7					      REPEND
     18  f4c8		       ea		      nop
     17  f4c8					      REPEND
     18  f4c9		       ea		      nop
     17  f4c9					      REPEND
     18  f4ca		       ea		      nop
     17  f4ca					      REPEND
     18  f4cb		       ea		      nop
     17  f4cb					      REPEND
     18  f4cc		       ea		      nop
     17  f4cc					      REPEND
     18  f4cd		       ea		      nop
     17  f4cd					      REPEND
     18  f4ce		       ea		      nop
     17  f4ce					      REPEND
     18  f4cf		       ea		      nop
     17  f4cf					      REPEND
     18  f4d0		       ea		      nop
     17  f4d0					      REPEND
     18  f4d1		       ea		      nop
     17  f4d1					      REPEND
     18  f4d2		       ea		      nop
     17  f4d2					      REPEND
     18  f4d3		       ea		      nop
     17  f4d3					      REPEND
     18  f4d4		       ea		      nop
     19  f4d5					      REPEND
    111  f4d5		       85 13		      sta	EMERALD_MI_RESET
    112  f4d7		       4c dc f4 	      jmp	.kernel_b_continue_2
    113  f4da
    114  f4da				   .kernel_b_continue
    115  f4da		       85 02		      sta	WSYNC
    116  f4dc				   .kernel_b_continue_2
    117  f4dc							; DEBUG: Set per-kernel color
    118  f4dc		       a2 cc		      ldx	#COL_EMERALD
    119  f4de							; ldx #$e4
    120  f4de		       86 07		      stx	EMERALD_SP_COLOR
    121  f4e0
    122  f4e0				   .complete
    123  f4e0
    124  f4e0				   VerticalBlankEnd
    125  f4e0							; Wait until the end of Vertical blank.
      0  f4e0					      TIMER_WAIT
      1  f4e0				   .waittimer
      2  f4e0		       ad 84 02 	      lda	INTIM
      3  f4e3		       d0 fb		      bne	.waittimer
      4  f4e5		       85 02		      sta	WSYNC
      0  f4e7					      ASSERT_RUNTIME	"_scan == #37"
      1  f4e7				   .COND      SET	"_scan == #37"
 ASSERT: breakif { pc== $f4e7  && !(  _scan == #37  ) }
      2  f4e7					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    128  f4e7
    129  f4e7							; Save stack pointer
    130  f4e7		       ba		      tsx
    131  f4e8		       86 97		      stx	RamStackBkp
    132  f4ea
    133  f4ea							; Start rendering the kernel.
    134  f4ea		       4c 36 fa 	      jmp	KernelBorder
    135  f4ed
    136  f500		       00 00 00 00*	      align	256	; TODO why
    137  f500
    138  f500				   FrameEnd   subroutine
    139  f500		       85 02		      sta	WSYNC
    140  f502
    141  f502							; Blank all background colors.
    142  f502		       a9 00		      lda	#0
    143  f504		       85 08		      sta	COLUPF
    144  f506		       85 0f		      sta	PF2
    145  f508		       85 0e		      sta	PF1
    146  f50a		       85 1c		      sta	EMERALD_SP
    147  f50c
    148  f50c							; Guide lines (2x)
    149  f50c		       a9 02		      lda	#SIGNAL_LINE
    150  f50e		       85 09		      sta	COLUBK
    151  f510					      REPEAT	6
    152  f510		       85 02		      sta	WSYNC
    151  f510					      REPEND
    152  f512		       85 02		      sta	WSYNC
    151  f512					      REPEND
    152  f514		       85 02		      sta	WSYNC
    151  f514					      REPEND
    152  f516		       85 02		      sta	WSYNC
    151  f516					      REPEND
    152  f518		       85 02		      sta	WSYNC
    151  f518					      REPEND
    152  f51a		       85 02		      sta	WSYNC
    153  f51c					      REPEND
    154  f51c		       a9 00		      lda	#$00
    155  f51e		       85 09		      sta	COLUBK
    156  f520
    157  f520							; Restore stack pointer
    158  f520		       a6 97		      ldx	RamStackBkp
    159  f522		       9a		      txs
    160  f523
    161  f523							; Display the rest of the blank screen.
      0  f523					      TIMER_SETUP	25
      1  f523				   .lines     SET	25
      2  f523		       a9 1d		      lda	#(((.lines)*76-14)/64)
      3  f525		       85 02		      sta	WSYNC
      4  f527		       8d 96 02 	      sta	TIM64T
    163  f52a		       85 02		      sta	WSYNC
      0  f52c					      TIMER_WAIT
      1  f52c				   .waittimer
      2  f52c		       ad 84 02 	      lda	INTIM
      3  f52f		       d0 fb		      bne	.waittimer
      4  f531		       85 02		      sta	WSYNC
      0  f533					      ASSERT_RUNTIME	"_scan == (#37 + #184)"
      1  f533				   .COND      SET	"_scan == (#37 + #184)"
 ASSERT: breakif { pc== $f533  && !(  _scan == (#37 + #184)  ) }
      2  f533					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    166  f533
    167  f533							; Overscan
    168  f533				   Overscan   subroutine
    169  f533		       85 01		      sta	VBLANK
      0  f535					      TIMER_SETUP	29
      1  f535				   .lines     SET	29
      2  f535		       a9 22		      lda	#(((.lines)*76-14)/64)
      3  f537		       85 02		      sta	WSYNC
      4  f539		       8d 96 02 	      sta	TIM64T
    171  f53c
    172  f53c		       20 4f f5 	      jsr	MoveJoystick
    173  f53f		       20 86 f5 	      jsr	SpeedCalculation
    174  f542		       20 f8 f9 	      jsr	game_state_tick
    175  f545
      0  f545					      TIMER_WAIT
      1  f545				   .waittimer
      2  f545		       ad 84 02 	      lda	INTIM
      3  f548		       d0 fb		      bne	.waittimer
      4  f54a		       85 02		      sta	WSYNC
      0  f54c					      ASSERT_RUNTIME	"_scan == (#37 + #184 + #29)"
      1  f54c				   .COND      SET	"_scan == (#37 + #184 + #29)"
 ASSERT: breakif { pc== $f54c  && !(  _scan == (#37 + #184 + #29)  ) }
      2  f54c					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    178  f54c
    179  f54c		       4c 00 f4 	      jmp	VerticalSync
------- FILE main.s
------- FILE game_input.s LEVEL 2 PASS 2
      0  f54f					      include	"game_input.s"
      1  f54f							; Handles input checking. Called from overscan.
      2  f54f
      3  f54f							; Read joystick movement and apply to object 0
      4  f54f				   MoveJoystick
      5  f54f							; Move vertically
      6  f54f							; (up and down are actually reversed since ypos starts at bottom)
      7  f54f							;     ldx YPos
      8  f54f		       a9 10		      lda	#%00010000	;Up?
      9  f551		       2c 80 02 	      bit	SWCHA
     10  f554		       d0 0d		      bne	SkipMoveUp
     11  f556
     12  f556		       18		      clc
     13  f557		       a5 8a		      lda	Speed2
     14  f559		       69 0c		      adc	#12
     15  f55b		       85 8a		      sta	Speed2
     16  f55d		       a5 89		      lda	Speed1
     17  f55f		       69 00		      adc	#00
     18  f561		       85 89		      sta	Speed1
     19  f563
     20  f563				   SkipMoveUp
     21  f563		       a6 88		      ldx	XPos
     22  f565
     23  f565							; Only check left/right on odd frames;
     24  f565							; TODO make this just a fractional speed
     25  f565							; rather than dropping frames
     26  f565		       a9 01		      lda	#01
     27  f567		       25 85		      and	FrameCount
     28  f569		       d0 18		      bne	SkipMoveRight
     29  f56b
     30  f56b
     31  f56b							; Move horizontally
     32  f56b		       a9 40		      lda	#%01000000	;Left?
     33  f56d		       2c 80 02 	      bit	SWCHA
     34  f570		       d0 05		      bne	SkipMoveLeft
     35  f572		       e0 1d		      cpx	#29
     36  f574		       90 01		      bcc	SkipMoveLeft
     37  f576		       ca		      dex
     38  f577
     39  f577							; Reflect
     40  f577							;     lda #$ff
     41  f577							;     sta REFP0
     42  f577				   SkipMoveLeft
     43  f577		       a9 80		      lda	#%10000000	;Right?
     44  f579		       2c 80 02 	      bit	SWCHA
     45  f57c		       d0 05		      bne	SkipMoveRight
     46  f57e		       e0 80		      cpx	#128
     47  f580		       b0 01		      bcs	SkipMoveRight
     48  f582		       e8		      inx
     49  f583
     50  f583							; Reflect
     51  f583							;     lda #$0
     52  f583							;     sta REFP0
     53  f583				   SkipMoveRight
     54  f583		       86 88		      stx	XPos
     55  f585		       60		      rts
     56  f586
     57  f586
     58  f586				   SpeedCalculation
     59  f586		       38		      sec
     60  f587		       a5 8a		      lda	Speed2
     61  f589		       e9 07		      sbc	#7
     62  f58b		       85 8a		      sta	Speed2
     63  f58d		       a5 89		      lda	Speed1
     64  f58f		       e9 00		      sbc	#0
     65  f591		       85 89		      sta	Speed1
     66  f593
     67  f593		       18		      clc
     68  f594		       a5 8c		      lda	YPos2
     69  f596		       65 8a		      adc	Speed2
     70  f598		       85 8c		      sta	YPos2
     71  f59a		       a5 8b		      lda	YPos
     72  f59c		       65 89		      adc	Speed1
     73  f59e		       85 8b		      sta	YPos
     74  f5a0
     75  f5a0		       c9 48		      cmp	#FLOOR_OFFSET
     76  f5a2		       b0 0a		      bcs	NewThing2
     77  f5a4
     78  f5a4							; Reset to floor
     79  f5a4		       a9 48		      lda	#FLOOR_OFFSET
     80  f5a6		       85 8b		      sta	YPos
     81  f5a8		       a9 00		      lda	#0
     82  f5aa		       85 89		      sta	Speed1
     83  f5ac		       85 8a		      sta	Speed2
     84  f5ae				   NewThing2
     85  f5ae
     86  f5ae		       c9 c0		      cmp	#CEILING_OFFSET
     87  f5b0		       90 0a		      bcc	.next
     88  f5b2
     89  f5b2							; Reset to ceiling
     90  f5b2		       a9 c0		      lda	#CEILING_OFFSET
     91  f5b4		       85 8b		      sta	YPos
     92  f5b6		       a9 00		      lda	#0
     93  f5b8		       85 89		      sta	Speed1
     94  f5ba		       85 8a		      sta	Speed2
     95  f5bc				   .next
     96  f5bc		       60		      rts
     97  f5bd
     98  f5bd
     99  f5bd
    100  f5bd							; Subroutine
    101  f5bd				   SetHorizPos
    102  f5bd		       85 02		      sta	WSYNC	; start a new line
    103  f5bf		       24 00		      bit	0	; waste 3 cycles
    104  f5c1		       38		      sec		; set carry flag
    105  f5c2				   DivideLoop
    106  f5c2		       e9 0f		      sbc	#15	; subtract 15
    107  f5c4		       b0 fc		      bcs	DivideLoop	; branch until negative
    108  f5c6		       49 07		      eor	#7	; calculate fine offset
    109  f5c8		       0a		      asl
    110  f5c9		       0a		      asl
    111  f5ca		       0a		      asl
    112  f5cb		       0a		      asl
    113  f5cc		       95 10		      sta	JET_SP_RESET,x	; fix coarse position
    114  f5ce		       95 20		      sta	JET_SP_HMOVE,x	; set fine offset
    115  f5d0		       60		      rts		; return to caller
------- FILE main.s
------- FILE game_nibble.s LEVEL 2 PASS 2
      0  f5d1					      include	"game_nibble.s"
      1  f5d1							; Frame loop, including calling out to other kernels.
      2  f5d1
      3  f5d1		       00 aa	   SENTINEL   =	%010101010
      4  f5d1
      5  f5d1							; Reflected for Kernel A
      6  f5d1		       00 00	   G00	      =	%00000000
      7  f5d1		       00 60	   G01	      =	%01100000
      8  f5d1		       00 06	   G10	      =	%00000110
      9  f5d1		       00 66	   G11	      =	%01100110
     10  f5d1
     11  f5d1		       00 a9	   BC_LDA_IMM =	$a9
     12  f5d1		       00 85	   BC_STA     =	$85
     13  f5d1		       00 86	   BC_STX     =	$86
     14  f5d1		       00 84	   BC_STY     =	$84
     15  f5d1		       00 08	   BC_PHP     =	$08
     16  f5d1		       00 04	   BC_NOP     =	$04
     17  f5d1
     18  f5d1		       00 79	   NOP_REG    =	$79	; TODO is there a better reg to write to with NOP effects
     19  f5d1
     20  f5d1				   KernelA_D_W EQM	[KernelA_D - $100]
     21  f5d1				   KernelA_E_W EQM	[KernelA_E - $100]
     22  f5d1				   KernelA_G_W EQM	[KernelA_G - $100]
     23  f5d1				   KernelA_H_W EQM	[KernelA_H - $100]
     24  f5d1				   KernelA_I_W EQM	[KernelA_I - $100]
     25  f5d1				   KernelA_J_W EQM	[KernelA_J - $100]
     26  f5d1				   KernelA_K_W EQM	[KernelA_K - $100]
     27  f5d1
     28  f5d1				   KernelB_D_W EQM	[KernelB_D - $100]
     29  f5d1				   KernelB_E_W EQM	[KernelB_E - $100]
     30  f5d1				   KernelB_F_W EQM	[KernelB_F - $100]
     31  f5d1				   KernelB_G_W EQM	[KernelB_G - $100]
     32  f5d1				   KernelB_H_W EQM	[KernelB_H - $100]
     33  f5d1				   KernelB_I_W EQM	[KernelB_I - $100]
     34  f5d1				   KernelB_J_W EQM	[KernelB_J - $100]
     35  f5d1				   KernelB_K_W EQM	[KernelB_K - $100]
     36  f5d1
     37  f5d1							; Y=Gemini Sprite
     38  f5d1							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     39  f5d1							; processor flag Z is TRUE if this is RST.
     40  f5d1				   KernelA_GenReset subroutine
     41  f5d1		       c0 00		      cpy	#$00
     42  f5d3		       f0 01		      beq	.start
     43  f5d5		       60		      rts
     44  f5d6							; Current Gemini = $00
     45  f5d6				   .start
     46  f5d6		       a6 aa		      ldx	BuildKernelRST
     47  f5d8		       e0 aa		      cpx	#SENTINEL
     48  f5da		       d0 04		      bne	.set_else
     49  f5dc							; We have found the first (and only) RST on this line, set the marker var
     50  f5dc		       a2 ff		      ldx	#$ff
     51  f5de		       86 aa		      stx	BuildKernelRST
     52  f5e0				   .set_else
     53  f5e0		       a2 00		      ldx	#$00
     54  f5e2		       60		      rts
     55  f5e3
     56  f5e3							; Y=Gemini Sprite
     57  f5e3							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     58  f5e3							; processor flag Z is TRUE if this is RST.
     59  f5e3				   KernelB_GenPhp subroutine
     60  f5e3		       c0 60		      cpy	#G01
     61  f5e5		       f0 05		      beq	.start
     62  f5e7		       c0 66		      cpy	#G11
     63  f5e9		       f0 01		      beq	.start
     64  f5eb		       60		      rts
     65  f5ec							; Current Gemini = $00
     66  f5ec				   .start
     67  f5ec		       a6 aa		      ldx	BuildKernelRST
     68  f5ee		       e0 aa		      cpx	#SENTINEL
     69  f5f0		       d0 04		      bne	.set_else
     70  f5f2							; We have found the first (and only) RST on this line, set the marker var
     71  f5f2		       84 aa		      sty	BuildKernelRST
     72  f5f4
     73  f5f4							; Set Z flag
     74  f5f4		       a2 00		      ldx	#$00
     75  f5f6				   .set_else
     76  f5f6		       60		      rts
     77  f5f7
     78  f5f7							; Allocates build-time registers for a new Gemini sprite value.
     79  f5f7							; register Y = the storage opcode to write to the result
     80  f5f7							;
     81  f5f7							; BuildKernelGrp0, BuildKernelX, BuildKernelY are compared in that order.
     82  f5f7							; BuildKernelX, BuildKernelY are upgraded if not set.
     83  f5f7							; Y=Gemini Sprite
     84  f5f7				   KernelB_UpdateRegs
     85  f5f7				   KernelA_UpdateRegs subroutine
     86  f5f7
     87  f5f7							; If equal to GRP0, return nop
     88  f5f7							; FIXME GRP0 might not always be up to date (should update each entry?)
     89  f5f7							; FIXME GOTTA REVERSE THE GRAPHICS ALSO
     90  f5f7							; cpy BuildKernelGrp0
     91  f5f7							; bne .set_start
     92  f5f7							; ; TODO if this is stx + NOP value, then register doesn't have to change as
     93  f5f7							; ; often in GEM1ASWITCH
     94  f5f7							; ldy #BC_NOP
     95  f5f7							; rts
     96  f5f7
     97  f5f7		       c4 a8		      cpy	BuildKernelX
     98  f5f9		       d0 03		      bne	.op_else
     99  f5fb		       a0 86		      ldy	#BC_STX
    100  f5fd		       60		      rts
    101  f5fe				   .op_else
    102  f5fe		       c4 a9		      cpy	BuildKernelY
    103  f600		       d0 03		      bne	.op_end
    104  f602		       a0 84		      ldy	#BC_STY
    105  f604		       60		      rts
    106  f605				   .op_end
    107  f605
    108  f605				   .set_start
    109  f605		       a6 a8		      ldx	BuildKernelX
    110  f607		       e0 aa		      cpx	#SENTINEL
    111  f609		       d0 13		      bne	.set_else
    112  f60b
    113  f60b							; KA Missile opcode determination
    114  f60b				   DBG_CHECK_MISSILE_OPCODE
    115  f60b		       84 a8		      sty	BuildKernelX
    116  f60d		       66 a8		      ror	BuildKernelX	; D0
    117  f60f		       66 a8		      ror	BuildKernelX	; D1
    118  f611		       a2 86		      ldx	#BC_STX
    119  f613		       b0 02		      bcs	[. + 4]
    120  f615		       a2 84		      ldx	#BC_STY
    121  f617		       86 ad		      stx	BuildKernelMissile
    122  f619
    123  f619		       84 a8		      sty	BuildKernelX
    124  f61b		       a0 86		      ldy	#BC_STX
    125  f61d		       60		      rts
    126  f61e				   .set_else
    127  f61e		       a6 a9		      ldx	BuildKernelY
    128  f620		       e0 aa		      cpx	#SENTINEL
    129  f622		       d0 05		      bne	.set_end
    130  f624		       84 a9		      sty	BuildKernelY
    131  f626		       a0 84		      ldy	#BC_STY
    132  f628		       60		      rts
    133  f629				   .set_end
    134  f629							; Failed all
      0  f629					      ASSERT_RUNTIME	"0"
      1  f629				   .COND      SET	"0"
 ASSERT: breakif { pc== $f629  && !(  0  ) }
      2  f629					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    136  f629		       60		      rts
    137  f62a
    138  f62a
    139  f62a				   game_nibble_populate
    140  f62a		       ad 00 f1 	      lda	$f100
    141  f62d		       85 80		      sta	DebugKernelID
    142  f62f
    143  f62f		       ad 84 fd 	      lda	shard_map
    144  f632		       a0 01		      ldy	#1	; gemini counter, starting at 1
    145  f634				   gemini_builder
    146  f634		       c0 01		      cpy	#1	; TODO top two bits of shard_map
    147  f636		       d0 00		      bne	.no_vd0
    148  f638				   .no_vd0
    149  f638
    150  f638							; Nibble Kernel A
      0  f638					      NIBBLE_START_KERNEL	gem_kernel_a_1, 40
      1 U00d6 ????				      seg.U	ignoreme
    152 U00d6 ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    153 U00d8 ????	       86 a8		      stx	BuildKernelX
    154 U00da ????	       86 a9		      stx	BuildKernelY
    155 U00dc ????	       86 aa		      stx	BuildKernelRST
    156 U00de ????
    157 U00de ????						; Gemini 1A
    158 U00de ????			   .K_1A
    159 U00de ????	       a4 b4		      ldy	[DO_GEMS_A + 0]
    160 U00e0 ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U00e3 ????				      NIBBLE_IF	eq
    162 U00e3 ????						; Special: Encoding RST0
    163 U00e3 ????						; Rewrite lda RamKernelPF1 to be #immediate
    164 U00e3 ????	       a0 a9		      ldy	#BC_LDA_IMM
    165 U00e5 ????	       8c 15 f0 	      sty	[KernelA_B - $100]
    166 U00e8 ????	       a0 a0		      ldy	#%10100000
    167 U00ea ????	       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
    168 U00ed ????						; Store 1A in GRP0
    169 U00ed ????	       a4 b5		      ldy	[DO_GEMS_A + 1]
    170 U00ef ????	       84 ab		      sty	BuildKernelGrp0
    171 U00f1 ????						; Gemini 1A is RESPx
    172 U00f1 ????	       a0 11		      ldy	#EMERALD_SP_RESET
    173 U00f3 ????	       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
    174 U00f6 ????						; Turn 3-cycle NOP into 4-cycle
    175 U00f6 ????	       a0 14		      ldy	#$14	; TODO what is this
    176 U00f8 ????	       8c 19 f0 	      sty	[KernelA_D - $100]
      0 U00fb ????				      NIBBLE_ELSE
    178 U00fb ????						; Store 0A in GRP0
    179 U00fb ????	       a4 b4		      ldy	[DO_GEMS_A + 0]
    180 U00fd ????	       84 ab		      sty	BuildKernelGrp0
    181 U00ff ????
    182 U00ff ????	       a4 b5		      ldy	[DO_GEMS_A + 1]
    183 U0101 ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U0104 ????				      NIBBLE_IF	eq
    185 U0104 ????						; GEM1ASWITCH
      0 U0104 ????				      NIBBLE_WRITE	KernelA_D_W, #BC_STX, #RESP1	; RESET
      0 U0104 ????				      NIBBLE_ELSE
    188 U0104 ????						; Calculate the 1A value
    189 U0104 ????	       ac d4 f9 	      ldy	SHARD_LUT_RF1
    190 U0107 ????	       c0 01		      cpy	#1
    191 U0109 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    192 U010b ????	       a0 11		      ldy	#RESP1
    193 U010d ????	       2c		      .byte.b	$2C	; .bit (ABS)
    194 U010e ????	       a0 1c		      ldy	#GRP1
    195 U0110 ????	       84 a0		      sty	RamKernelGemini1Reg
    196 U0112 ????
    197 U0112 ????						; Set opcode
    198 U0112 ????	       ae d4 f9 	      ldx	SHARD_LUT_RF1
    199 U0115 ????	       e0 01		      cpx	#1
    200 U0117 ????	       a0 86		      ldy	#BC_STX	; Don't allocate
    201 U0119 ????	       f0 05		      .byte.b	$F0, #5	; beq +4
    202 U011b ????	       a4 b5		      ldy	[DO_GEMS_A + 1]
    203 U011d ????	       20 f7 f5 	      jsr	KernelA_UpdateRegs
    204 U0120 ????	       84 9f		      sty	RamKernelGemini1
    205 U0122 ????
      0 U0122 ????				      NIBBLE_WRITE	KernelA_D_W, RamKernelGemini1, RamKernelGemini1Reg
      0 U0122 ????				      NIBBLE_END_IF
      0 U0122 ????				      NIBBLE_END_IF
    209 U0122 ????
    210 U0122 ????						; BuildKernelX, BuildKernelY are upgraded if not set
    211 U0122 ????						; Gemini 2A
    212 U0122 ????			   .K_2A
    213 U0122 ????	       a4 b6		      ldy	[DO_GEMS_A + 2]
    214 U0124 ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U0127 ????				      NIBBLE_IF	eq
      0 U0127 ????				      NIBBLE_WRITE	KernelA_E_W + 1, #NOP_REG	; NOP
      0 U0127 ????				      NIBBLE_WRITE	KernelA_G_W + 1, #RESP1	; RESET
      0 U0127 ????				      NIBBLE_ELSE
    219 U0127 ????						; Set opcode
    220 U0127 ????	       a4 b6		      ldy	[DO_GEMS_A + 2]
    221 U0129 ????	       20 f7 f5 	      jsr	KernelA_UpdateRegs
    222 U012c ????	       84 a1		      sty	RamKernelGemini2
    223 U012e ????
    224 U012e ????						; Set opcode target
    225 U012e ????	       ac d4 f9 	      ldy	SHARD_LUT_RF1
    226 U0131 ????	       c0 02		      cpy	#2
    227 U0133 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    228 U0135 ????	       a0 11		      ldy	#RESP1
    229 U0137 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    230 U0138 ????	       a0 1c		      ldy	#GRP1
    231 U013a ????	       84 a2		      sty	RamKernelGemini2Reg
    232 U013c ????
      0 U013c ????				      NIBBLE_WRITE	KernelA_E_W + 1, #RESP1
      0 U013c ????				      NIBBLE_WRITE	KernelA_G_W, RamKernelGemini2, RamKernelGemini2Reg	; STX
      0 U013c ????				      NIBBLE_END_IF
    236 U013c ????
    237 U013c ????						; Gemini 3A
    238 U013c ????			   .K_3A
    239 U013c ????	       a4 b7		      ldy	[DO_GEMS_A + 3]
    240 U013e ????	       20 d1 f5 	      jsr	KernelA_GenReset
      0 U0141 ????				      NIBBLE_IF	eq
      0 U0141 ????				      NIBBLE_WRITE	KernelA_H_W + 1, #RESP1	; RESET
      0 U0141 ????				      NIBBLE_ELSE
    244 U0141 ????						; Set opcode
    245 U0141 ????	       a4 b7		      ldy	[DO_GEMS_A + 3]
    246 U0143 ????	       20 f7 f5 	      jsr	KernelA_UpdateRegs
    247 U0146 ????	       84 a3		      sty	RamKernelGemini3
    248 U0148 ????
    249 U0148 ????						; Set opcode target
    250 U0148 ????	       ac d4 f9 	      ldy	SHARD_LUT_RF1
    251 U014b ????	       c0 03		      cpy	#3
    252 U014d ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    253 U014f ????	       a0 11		      ldy	#RESP1
    254 U0151 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    255 U0152 ????	       a0 1c		      ldy	#GRP1
    256 U0154 ????	       84 a4		      sty	RamKernelGemini3Reg
    257 U0156 ????
      0 U0156 ????				      NIBBLE_WRITE	KernelA_H_W, RamKernelGemini3, RamKernelGemini3Reg	; STY
      0 U0156 ????				      NIBBLE_END_IF
      0 U0156 ????				      NIBBLE_END_KERNEL
      1  f638					      seg	CodeBank3
    261  f638
      0  f638					      NIBBLE_START_KERNEL	gem_kernel_a_2, 40
      1 U0156 ????				      seg.U	ignoreme
    263 U0156 ????						; VD1 default
    264 U0156 ????	       a6 b5		      ldx	[DO_GEMS_A + 1]
    265 U0158 ????	       86 ac		      stx	BuildKernelVdel1
    266 U015a ????
    267 U015a ????						; Gemini 4A
    268 U015a ????	       ae d5 f9 	      ldx	SHARD_LUT_VD1
    269 U015d ????	       e0 04		      cpx	#4
      0 U015f ????				      NIBBLE_IF	ne
      0 U015f ????				      NIBBLE_WRITE	[KernelA_I_W + 0], #BC_STA, #EMERALD_SP_RESET
      0 U015f ????				      NIBBLE_WRITE	[KernelA_J_W + 1], #BC_STA, #PF1
      0 U015f ????				      NIBBLE_WRITE	[KernelA_K_W + 1], #BC_PHP
    274 U015f ????
    275 U015f ????						; Set PHP
      0 U015f ????				      NIBBLE_WRITE	RamKernelPhpTarget, #VDELP1
    277 U015f ????
    278 U015f ????						; Update VDEL1
    279 U015f ????	       a6 b8		      ldx	[DO_GEMS_A + 4]
    280 U0161 ????	       86 ac		      stx	BuildKernelVdel1
      0 U0163 ????				      NIBBLE_ELSE
    282 U0163 ????	       a4 b8		      ldy	[DO_GEMS_A + 4]
    283 U0165 ????	       20 f7 f5 	      jsr	KernelA_UpdateRegs
    284 U0168 ????	       84 a5		      sty	RamKernelGemini4
    285 U016a ????
      0 U016a ????				      NIBBLE_WRITE	[KernelA_I_W + 0], #BC_PHP
      0 U016a ????				      NIBBLE_WRITE	[KernelA_J_W + 0], #BC_STA, #PF1
      0 U016a ????				      NIBBLE_WRITE	KernelA_K_W, RamKernelGemini4, #EMERALD_SP
    289 U016a ????
    290 U016a ????						; Set PHP
      0 U016a ????				      NIBBLE_WRITE	RamKernelPhpTarget, #RESP1
      0 U016a ????				      NIBBLE_END_IF
    293 U016a ????
    294 U016a ????						; Gemini 5A
    295 U016a ????						; TODO eventually...?
    296 U016a ????
    297 U016a ????						; Missile
    298 U016a ????	       a4 b2		      ldy	DO_MISS_A
      0 U016c ????				      NIBBLE_IF	eq	; Disabled
      0 U016c ????				      NIBBLE_WRITE	[KernelA_F - $100], #BC_NOP
      0 U016c ????				      NIBBLE_ELSE
      0 U016c ????				      NIBBLE_WRITE	[KernelA_F - $100], BuildKernelMissile
      0 U016c ????				      NIBBLE_END_IF
    304 U016c ????
    305 U016c ????						; VD1
      0 U016c ????				      NIBBLE_WRITE	[KernelA_VDEL1 - $100], BuildKernelVdel1
    307 U016c ????						; GRP0
      0 U016c ????				      NIBBLE_WRITE	[KernelA_VDEL0 - $100], BuildKernelGrp0
    309 U016c ????						; X
      0 U016c ????				      NIBBLE_WRITE	RamKernelX, BuildKernelX
    311 U016c ????						; Y
      0 U016c ????				      NIBBLE_WRITE	RamKernelY, BuildKernelY
    313 U016c ????
      0 U016c ????				      NIBBLE_WRITE	RamPSByte, #$ff
      0 U016c ????				      NIBBLE_END_KERNEL
      1  f638					      seg	CodeBank3
    316  f638
    317  f638							; Nibble Kernel B
      0  f638					      NIBBLE_START_KERNEL	gem_kernel_b, 40
      1 U016c ????				      seg.U	ignoreme
    319 U016c ????						; Php target default
    320 U016c ????	       a2 11		      ldx	#RESP1
    321 U016e ????	       86 9c		      stx	RamKernelPhpTarget
    322 U0170 ????
    323 U0170 ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    324 U0172 ????	       86 a8		      stx	BuildKernelX
    325 U0174 ????	       86 a9		      stx	BuildKernelY
    326 U0176 ????	       86 aa		      stx	BuildKernelRST
    327 U0178 ????
    328 U0178 ????						; Gemini 0B
    329 U0178 ????	       a4 ba		      ldy	[DO_GEMS_B + 0]
    330 U017a ????	       84 ab		      sty	BuildKernelGrp0
    331 U017c ????						; NIBBLE_WRITE KernelB_D_W, RamKernelGemini0
    332 U017c ????
    333 U017c ????						; Gemini 1B
    334 U017c ????	       a4 bb		      ldy	[DO_GEMS_B + 1]
    335 U017e ????	       20 f7 f5 	      jsr	KernelA_UpdateRegs
    336 U0181 ????	       84 9f		      sty	RamKernelGemini1
      0 U0183 ????				      NIBBLE_WRITE	KernelB_D_W, RamKernelGemini1
    338 U0183 ????
    339 U0183 ????						; Calculate Gemini 2B
    340 U0183 ????	       a4 bc		      ldy	[DO_GEMS_B + 2]
    341 U0185 ????	       20 f7 f5 	      jsr	KernelB_UpdateRegs
    342 U0188 ????	       84 a1		      sty	RamKernelGemini2
    343 U018a ????						; Calculate Gemini 3B
    344 U018a ????	       a4 bd		      ldy	[DO_GEMS_B + 3]
    345 U018c ????	       20 f7 f5 	      jsr	KernelB_UpdateRegs
    346 U018f ????	       84 a3		      sty	RamKernelGemini3
    347 U0191 ????
    348 U0191 ????						; Gemini 2B
    349 U0191 ????	       a4 bc		      ldy	[DO_GEMS_B + 2]
    350 U0193 ????	       20 e3 f5 	      jsr	KernelB_GenPhp
      0 U0196 ????				      NIBBLE_IF	eq
    352 U0196 ????						; Write to PHP in 2B
      0 U0196 ????				      NIBBLE_WRITE	RamKernelPhpTarget, #EMERALD_SP
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_E_W + 0], #BC_STY, #EMERALD_SP_RESET	; 2B
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_F_W + 1], #BC_PHP
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_G_W + 0], #BC_STA, #PF1
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_H_W + 0], RamKernelGemini3, #EMERALD_SP	; 3B
      0 U0196 ????				      NIBBLE_ELSE
      0 U0196 ????				      NIBBLE_WRITE	KernelB_F_W, RamKernelGemini2, #EMERALD_SP
      0 U0196 ????				      NIBBLE_END_IF
    361 U0196 ????
    362 U0196 ????						; Gemini 3B
    363 U0196 ????	       a4 bd		      ldy	[DO_GEMS_B + 3]
    364 U0198 ????	       20 e3 f5 	      jsr	KernelB_GenPhp
      0 U019b ????				      NIBBLE_IF	eq
    366 U019b ????						; Write to PHP in 3B
      0 U019b ????				      NIBBLE_WRITE	RamKernelPhpTarget, #EMERALD_SP
      0 U019b ????				      NIBBLE_WRITE	[KernelB_E_W + 0], #BC_STY, #EMERALD_SP_RESET
      0 U019b ????				      NIBBLE_WRITE	[KernelB_F_W + 1], RamKernelGemini2, #EMERALD_SP	; 2B
      0 U019b ????				      NIBBLE_WRITE	[KernelB_G_W + 1], #BC_STA, #PF1
      0 U019b ????				      NIBBLE_WRITE	[KernelB_H_W + 1], #BC_PHP	; 3B
      0 U019b ????				      NIBBLE_ELSE
      0 U019b ????				      NIBBLE_WRITE	KernelB_H_W, RamKernelGemini3, #EMERALD_SP
      0 U019b ????				      NIBBLE_END_IF
    375 U019b ????
    376 U019b ????						; Write out PHP
    377 U019b ????	       a4 aa		      ldy	BuildKernelRST
    378 U019d ????	       c0 60		      cpy	#G01
      0 U019f ????				      NIBBLE_IF	eq
      0 U019f ????				      NIBBLE_WRITE	[KernelB_C - $100], #$c5, #RamFFByte
      0 U019f ????				      NIBBLE_ELSE
      0 U019f ????				      NIBBLE_WRITE	[KernelB_C - $100], #$c5, #RamPF1Value
      0 U019f ????				      NIBBLE_END_IF
    384 U019f ????
    385 U019f ????						; Missile
    386 U019f ????						; ldy DO_MISS_B
    387 U019f ????						; NIBBLE_IF eq ; Disabled
    388 U019f ????						; NIBBLE_WRITE [KernelB_K - $100], #BC_STA
    389 U019f ????						; NIBBLE_ELSE
    390 U019f ????						;     NIBBLE_WRITE [KernelB_K - $100], BuildKernelMissile
    391 U019f ????						; NIBBLE_END_IF
    392 U019f ????
    393 U019f ????						; Gemini 4B
    394 U019f ????	       a4 be		      ldy	[DO_GEMS_B + 4]
    395 U01a1 ????	       20 f7 f5 	      jsr	KernelA_UpdateRegs
    396 U01a4 ????	       84 a5		      sty	RamKernelGemini4
      0 U01a6 ????				      NIBBLE_WRITE	KernelB_J_W, RamKernelGemini4
    398 U01a6 ????
    399 U01a6 ????						; TODO if no PHP, rewrite previous section:
    400 U01a6 ????						; NIBBLE_IF cs
    401 U01a6 ????						;     ; Write to PHP in reset command
    402 U01a6 ????						;     NIBBLE_WRITE [KernelB_E_W + 0], #BC_PHP
    403 U01a6 ????						;     NIBBLE_WRITE [KernelB_F_W + 0], #BC_STY, #EMERALD_SP ; 2B
    404 U01a6 ????						;     NIBBLE_WRITE [KernelB_G_W + 0], #BC_STA, #PF1
    405 U01a6 ????						;     NIBBLE_WRITE [KernelB_H_W + 0], #BC_STY, #EMERALD_SP ; 3B
    406 U01a6 ????						; NIBBLE_END_IF
    407 U01a6 ????
    408 U01a6 ????						; Make adjustments for sprites.
    409 U01a6 ????	       66 ab		      ror	BuildKernelGrp0
    410 U01a8 ????	       66 a8		      ror	BuildKernelX
    411 U01aa ????	       66 a9		      ror	BuildKernelY
    412 U01ac ????
    413 U01ac ????						; ; VD1
    414 U01ac ????						; NIBBLE_WRITE [KernelB_VDEL1 - $100], BuildKernelVdel1
    415 U01ac ????						; GRP0
      0 U01ac ????				      NIBBLE_WRITE	[KernelB_VDEL0 - $100], BuildKernelGrp0
    417 U01ac ????						; X
      0 U01ac ????				      NIBBLE_WRITE	RamKernelX, BuildKernelX
    419 U01ac ????						; Y
      0 U01ac ????				      NIBBLE_WRITE	RamKernelY, BuildKernelY
    421 U01ac ????
      0 U01ac ????				      NIBBLE_WRITE	RamPSByte, #$00
    423 U01ac ????
      0 U01ac ????				      NIBBLE_END_KERNEL
      1  f638					      seg	CodeBank3
    425  f638
    426  f638							; TODO do this for all rows
    427  f638				   DBG_NIBBLE_BUILD subroutine
    428  f638		       ae 00 f1 	      ldx	$f100
    429  f63b		       e0 0a		      cpx	#$a
    430  f63d		       f0 03		      beq	[. + 5]
    431  f63f		       4c 24 f7 	      jmp	.kernel_b
    432  f642				   .kernel_a
      0  f642					      NIBBLE_gem_kernel_a_1_BUILD		; TODO can this be implied
      1  f642		       a9 00		      lda	#0
      2  f644		       a2 aa		      ldx	#SENTINEL
      3  f646		       86 a8		      stx	BuildKernelX
      4  f648		       86 a9		      stx	BuildKernelY
      5  f64a		       86 aa		      stx	BuildKernelRST
      6  f64c
      7  f64c				   .K_1A
      8  f64c		       a4 b4		      ldy	[DO_GEMS_A + 0]
      9  f64e		       20 d1 f5 	      jsr	KernelA_GenReset
     10  f651				   .if_1
     11  f651		       d0 1e		      bne	.else_1
     12  f653		       38		      sec
     13  f654		       2a		      rol
     14  f655
     15  f655
     16  f655		       a0 a9		      ldy	#BC_LDA_IMM
     17  f657		       8c 15 f0 	      sty	[KernelA_B - $100]
     18  f65a		       a0 a0		      ldy	#%10100000
     19  f65c		       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
     20  f65f
     21  f65f		       a4 b5		      ldy	[DO_GEMS_A + 1]
     22  f661		       84 ab		      sty	BuildKernelGrp0
     23  f663
     24  f663		       a0 11		      ldy	#EMERALD_SP_RESET
     25  f665		       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
     26  f668
     27  f668		       a0 14		      ldy	#$14
     28  f66a		       8c 19 f0 	      sty	[KernelA_D - $100]
     29  f66d		       4c a3 f6 	      jmp	.endif_1
     30  f670
     31  f670		       2a		      rol
     32  f671
     33  f671				   .else_1
     34  f671		       18		      clc
     35  f672		       2a		      rol
     36  f673
     37  f673		       a4 b4		      ldy	[DO_GEMS_A + 0]
     38  f675		       84 ab		      sty	BuildKernelGrp0
     39  f677		       a4 b5		      ldy	[DO_GEMS_A + 1]
     40  f679		       20 d1 f5 	      jsr	KernelA_GenReset
     41  f67c				   .if_2
     42  f67c		       d0 05		      bne	.else_2
     43  f67e		       38		      sec
     44  f67f		       2a		      rol
     45  f680
     46  f680		       4c a3 f6 	      jmp	.endif_2
     47  f683
     48  f683
     49  f683				   .else_2
     50  f683		       18		      clc
     51  f684		       2a		      rol
     52  f685
     53  f685		       ac d4 f9 	      ldy	SHARD_LUT_RF1
     54  f688		       c0 01		      cpy	#1
     55  f68a		       d0 03		      .byte.b	$D0, #3
     56  f68c		       a0 11		      ldy	#RESP1
     57  f68e		       2c		      .byte.b	$2C
     58  f68f		       a0 1c		      ldy	#GRP1
     59  f691		       84 a0		      sty	RamKernelGemini1Reg
     60  f693
     61  f693		       ae d4 f9 	      ldx	SHARD_LUT_RF1
     62  f696		       e0 01		      cpx	#1
     63  f698		       a0 86		      ldy	#BC_STX
     64  f69a		       f0 05		      .byte.b	$F0, #5
     65  f69c		       a4 b5		      ldy	[DO_GEMS_A + 1]
     66  f69e		       20 f7 f5 	      jsr	KernelA_UpdateRegs
     67  f6a1		       84 9f		      sty	RamKernelGemini1
     68  f6a3
     69  f6a3
     70  f6a3				   .endif_2
     71  f6a3
     72  f6a3
     73  f6a3				   .endif_1
     74  f6a3
     75  f6a3
     76  f6a3				   .K_2A
     77  f6a3		       a4 b6		      ldy	[DO_GEMS_A + 2]
     78  f6a5		       20 d1 f5 	      jsr	KernelA_GenReset
     79  f6a8				   .if_3
     80  f6a8		       d0 05		      bne	.else_3
     81  f6aa		       38		      sec
     82  f6ab		       2a		      rol
     83  f6ac		       4c c6 f6 	      jmp	.endif_3
     84  f6af
     85  f6af
     86  f6af				   .else_3
     87  f6af		       18		      clc
     88  f6b0		       2a		      rol
     89  f6b1
     90  f6b1		       a4 b6		      ldy	[DO_GEMS_A + 2]
     91  f6b3		       20 f7 f5 	      jsr	KernelA_UpdateRegs
     92  f6b6		       84 a1		      sty	RamKernelGemini2
     93  f6b8
     94  f6b8		       ac d4 f9 	      ldy	SHARD_LUT_RF1
     95  f6bb		       c0 02		      cpy	#2
     96  f6bd		       d0 03		      .byte.b	$D0, #3
     97  f6bf		       a0 11		      ldy	#RESP1
     98  f6c1		       2c		      .byte.b	$2C
     99  f6c2		       a0 1c		      ldy	#GRP1
    100  f6c4		       84 a2		      sty	RamKernelGemini2Reg
    101  f6c6
    102  f6c6
    103  f6c6				   .endif_3
    104  f6c6
    105  f6c6				   .K_3A
    106  f6c6		       a4 b7		      ldy	[DO_GEMS_A + 3]
    107  f6c8		       20 d1 f5 	      jsr	KernelA_GenReset
    108  f6cb				   .if_4
    109  f6cb		       d0 05		      bne	.else_4
    110  f6cd		       38		      sec
    111  f6ce		       2a		      rol
    112  f6cf		       4c e9 f6 	      jmp	.endif_4
    113  f6d2
    114  f6d2
    115  f6d2				   .else_4
    116  f6d2		       18		      clc
    117  f6d3		       2a		      rol
    118  f6d4
    119  f6d4		       a4 b7		      ldy	[DO_GEMS_A + 3]
    120  f6d6		       20 f7 f5 	      jsr	KernelA_UpdateRegs
    121  f6d9		       84 a3		      sty	RamKernelGemini3
    122  f6db
    123  f6db		       ac d4 f9 	      ldy	SHARD_LUT_RF1
    124  f6de		       c0 03		      cpy	#3
    125  f6e0		       d0 03		      .byte.b	$D0, #3
    126  f6e2		       a0 11		      ldy	#RESP1
    127  f6e4		       2c		      .byte.b	$2C
    128  f6e5		       a0 1c		      ldy	#GRP1
    129  f6e7		       84 a4		      sty	RamKernelGemini3Reg
    130  f6e9
    131  f6e9
    132  f6e9				   .endif_4
    133  f6e9
    134  f6e9		       2a		      rol
    135  f6ea		       2a		      rol
    136  f6eb		       2a		      rol
    137  f6ec		       2a		      rol
    434  f6ed		       85 92		      sta	RamNibbleVar1
      0  f6ef					      NIBBLE_gem_kernel_a_2_BUILD		; TODO can this be implied
      1  f6ef		       a9 00		      lda	#0
      2  f6f1
      3  f6f1		       a6 b5		      ldx	[DO_GEMS_A + 1]
      4  f6f3		       86 ac		      stx	BuildKernelVdel1
      5  f6f5
      6  f6f5		       ae d5 f9 	      ldx	SHARD_LUT_VD1
      7  f6f8		       e0 04		      cpx	#4
      8  f6fa				   .if_1
      9  f6fa		       f0 09		      beq	.else_1
     10  f6fc		       38		      sec
     11  f6fd		       2a		      rol
     12  f6fe
     13  f6fe
     14  f6fe		       a6 b8		      ldx	[DO_GEMS_A + 4]
     15  f700		       86 ac		      stx	BuildKernelVdel1
     16  f702		       4c 0e f7 	      jmp	.endif_1
     17  f705
     18  f705
     19  f705				   .else_1
     20  f705		       18		      clc
     21  f706		       2a		      rol
     22  f707		       a4 b8		      ldy	[DO_GEMS_A + 4]
     23  f709		       20 f7 f5 	      jsr	KernelA_UpdateRegs
     24  f70c		       84 a5		      sty	RamKernelGemini4
     25  f70e
     26  f70e
     27  f70e
     28  f70e				   .endif_1
     29  f70e
     30  f70e
     31  f70e
     32  f70e		       a4 b2		      ldy	DO_MISS_A
     33  f710				   .if_2
     34  f710		       d0 05		      bne	.else_2
     35  f712		       38		      sec
     36  f713		       2a		      rol
     37  f714		       4c 19 f7 	      jmp	.endif_2
     38  f717
     39  f717
     40  f717				   .else_2
     41  f717		       18		      clc
     42  f718		       2a		      rol
     43  f719
     44  f719
     45  f719				   .endif_2
     46  f719
     47  f719
     48  f719
     49  f719
     50  f719
     51  f719		       2a		      rol
     52  f71a		       2a		      rol
     53  f71b		       2a		      rol
     54  f71c		       2a		      rol
     55  f71d		       2a		      rol
     56  f71e		       2a		      rol
    436  f71f		       85 93		      sta	RamNibbleVar2
    437  f721		       4c 88 f7 	      jmp	.next
    438  f724				   .kernel_b
      0  f724					      NIBBLE_gem_kernel_b_BUILD		; TODO can this be implied
      1  f724		       a9 00		      lda	#0
      2  f726
      3  f726		       a2 11		      ldx	#RESP1
      4  f728		       86 9c		      stx	RamKernelPhpTarget
      5  f72a		       a2 aa		      ldx	#SENTINEL
      6  f72c		       86 a8		      stx	BuildKernelX
      7  f72e		       86 a9		      stx	BuildKernelY
      8  f730		       86 aa		      stx	BuildKernelRST
      9  f732
     10  f732		       a4 ba		      ldy	[DO_GEMS_B + 0]
     11  f734		       84 ab		      sty	BuildKernelGrp0
     12  f736
     13  f736
     14  f736		       a4 bb		      ldy	[DO_GEMS_B + 1]
     15  f738		       20 f7 f5 	      jsr	KernelA_UpdateRegs
     16  f73b		       84 9f		      sty	RamKernelGemini1
     17  f73d
     18  f73d		       a4 bc		      ldy	[DO_GEMS_B + 2]
     19  f73f		       20 f7 f5 	      jsr	KernelB_UpdateRegs
     20  f742		       84 a1		      sty	RamKernelGemini2
     21  f744
     22  f744		       a4 bd		      ldy	[DO_GEMS_B + 3]
     23  f746		       20 f7 f5 	      jsr	KernelB_UpdateRegs
     24  f749		       84 a3		      sty	RamKernelGemini3
     25  f74b
     26  f74b		       a4 bc		      ldy	[DO_GEMS_B + 2]
     27  f74d		       20 e3 f5 	      jsr	KernelB_GenPhp
     28  f750				   .if_1
     29  f750		       d0 05		      bne	.else_1
     30  f752		       38		      sec
     31  f753		       2a		      rol
     32  f754
     33  f754		       4c 59 f7 	      jmp	.endif_1
     34  f757
     35  f757
     36  f757				   .else_1
     37  f757		       18		      clc
     38  f758		       2a		      rol
     39  f759
     40  f759
     41  f759				   .endif_1
     42  f759
     43  f759		       a4 bd		      ldy	[DO_GEMS_B + 3]
     44  f75b		       20 e3 f5 	      jsr	KernelB_GenPhp
     45  f75e				   .if_2
     46  f75e		       d0 05		      bne	.else_2
     47  f760		       38		      sec
     48  f761		       2a		      rol
     49  f762
     50  f762		       4c 67 f7 	      jmp	.endif_2
     51  f765
     52  f765
     53  f765				   .else_2
     54  f765		       18		      clc
     55  f766		       2a		      rol
     56  f767
     57  f767
     58  f767				   .endif_2
     59  f767
     60  f767		       a4 aa		      ldy	BuildKernelRST
     61  f769		       c0 60		      cpy	#G01
     62  f76b				   .if_3
     63  f76b		       d0 05		      bne	.else_3
     64  f76d		       38		      sec
     65  f76e		       2a		      rol
     66  f76f		       4c 74 f7 	      jmp	.endif_3
     67  f772
     68  f772
     69  f772				   .else_3
     70  f772		       18		      clc
     71  f773		       2a		      rol
     72  f774
     73  f774
     74  f774				   .endif_3
     75  f774
     76  f774
     77  f774
     78  f774
     79  f774
     80  f774
     81  f774
     82  f774
     83  f774		       a4 be		      ldy	[DO_GEMS_B + 4]
     84  f776		       20 f7 f5 	      jsr	KernelA_UpdateRegs
     85  f779		       84 a5		      sty	RamKernelGemini4
     86  f77b
     87  f77b
     88  f77b
     89  f77b
     90  f77b
     91  f77b
     92  f77b
     93  f77b
     94  f77b
     95  f77b		       66 ab		      ror	BuildKernelGrp0
     96  f77d		       66 a8		      ror	BuildKernelX
     97  f77f		       66 a9		      ror	BuildKernelY
     98  f781
     99  f781
    100  f781
    101  f781
    102  f781
    103  f781
    104  f781		       2a		      rol
    105  f782		       2a		      rol
    106  f783		       2a		      rol
    107  f784		       2a		      rol
    108  f785		       2a		      rol
    440  f786		       85 92		      sta	RamNibbleVar1
    441  f788				   .next
    442  f788
    443  f788							; TODO move this into the row kernel
    444  f788				   DBG_NIBBLE_RUN subroutine
    445  f788		       ae 00 f1 	      ldx	$f100
    446  f78b		       e0 0a		      cpx	#$a
    447  f78d		       f0 03		      beq	[. + 5]
    448  f78f		       4c 53 f8 	      jmp	.kernel_b
    449  f792				   .kernel_a
    450  f792		       a5 92		      lda	RamNibbleVar1
      0  f794					      NIBBLE_gem_kernel_a_1
      1  f794				   .if_1
      2  f794		       0a		      asl
      3  f795		       90 03		      bcc	.else_1
      4  f797		       4c b4 f7 	      jmp	.endif_1
      5  f79a				   .else_1
      6  f79a				   .if_2
      7  f79a		       0a		      asl
      8  f79b		       90 0d		      bcc	.else_2
      9  f79d		       a2 86		      ldx	#BC_STX
     10  f79f		       8e 19 f0 	      stx	[KernelA_D_W + 0]
     11  f7a2		       a2 11		      ldx	#RESP1
     12  f7a4		       8e 1a f0 	      stx	[KernelA_D_W + 1]
     13  f7a7		       4c b4 f7 	      jmp	.endif_2
     14  f7aa				   .else_2
     15  f7aa		       a6 9f		      ldx	RamKernelGemini1
     16  f7ac		       8e 19 f0 	      stx	[KernelA_D_W + 0]
     17  f7af		       a6 a0		      ldx	RamKernelGemini1Reg
     18  f7b1		       8e 1a f0 	      stx	[KernelA_D_W + 1]
     19  f7b4				   .endif_2
     20  f7b4				   .endif_1
     21  f7b4				   .if_3
     22  f7b4		       0a		      asl
     23  f7b5		       90 0d		      bcc	.else_3
     24  f7b7		       a2 79		      ldx	#NOP_REG
     25  f7b9		       8e 1c f0 	      stx	[KernelA_E_W + 1 + 0]
     26  f7bc		       a2 11		      ldx	#RESP1
     27  f7be		       8e 20 f0 	      stx	[KernelA_G_W + 1 + 0]
     28  f7c1		       4c d3 f7 	      jmp	.endif_3
     29  f7c4				   .else_3
     30  f7c4		       a2 11		      ldx	#RESP1
     31  f7c6		       8e 1c f0 	      stx	[KernelA_E_W + 1 + 0]
     32  f7c9		       a6 a1		      ldx	RamKernelGemini2
     33  f7cb		       8e 1f f0 	      stx	[KernelA_G_W + 0]
     34  f7ce		       a6 a2		      ldx	RamKernelGemini2Reg
     35  f7d0		       8e 20 f0 	      stx	[KernelA_G_W + 1]
     36  f7d3				   .endif_3
     37  f7d3				   .if_4
     38  f7d3		       0a		      asl
     39  f7d4		       90 08		      bcc	.else_4
     40  f7d6		       a2 11		      ldx	#RESP1
     41  f7d8		       8e 22 f0 	      stx	[KernelA_H_W + 1 + 0]
     42  f7db		       4c e8 f7 	      jmp	.endif_4
     43  f7de				   .else_4
     44  f7de		       a6 a3		      ldx	RamKernelGemini3
     45  f7e0		       8e 21 f0 	      stx	[KernelA_H_W + 0]
     46  f7e3		       a6 a4		      ldx	RamKernelGemini3Reg
     47  f7e5		       8e 22 f0 	      stx	[KernelA_H_W + 1]
     48  f7e8				   .endif_4
    452  f7e8		       a5 93		      lda	RamNibbleVar2
      0  f7ea					      NIBBLE_gem_kernel_a_2
      1  f7ea				   .if_1
      2  f7ea		       0a		      asl
      3  f7eb		       90 20		      bcc	.else_1
      4  f7ed		       a2 85		      ldx	#BC_STA
      5  f7ef		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
      6  f7f2		       a2 11		      ldx	#EMERALD_SP_RESET
      7  f7f4		       8e 24 f0 	      stx	[[KernelA_I_W + 0] + 1]
      8  f7f7		       a2 85		      ldx	#BC_STA
      9  f7f9		       8e 25 f0 	      stx	[[KernelA_J_W + 1] + 0]
     10  f7fc		       a2 0e		      ldx	#PF1
     11  f7fe		       8e 26 f0 	      stx	[[KernelA_J_W + 1] + 1]
     12  f801		       a2 08		      ldx	#BC_PHP
     13  f803		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
     14  f806		       a2 26		      ldx	#VDELP1
     15  f808		       86 9c		      stx	[RamKernelPhpTarget + 0]
     16  f80a		       4c 2a f8 	      jmp	.endif_1
     17  f80d				   .else_1
     18  f80d		       a2 08		      ldx	#BC_PHP
     19  f80f		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
     20  f812		       a2 85		      ldx	#BC_STA
     21  f814		       8e 24 f0 	      stx	[[KernelA_J_W + 0] + 0]
     22  f817		       a2 0e		      ldx	#PF1
     23  f819		       8e 25 f0 	      stx	[[KernelA_J_W + 0] + 1]
     24  f81c		       a6 a5		      ldx	RamKernelGemini4
     25  f81e		       8e 26 f0 	      stx	[KernelA_K_W + 0]
     26  f821		       a2 1c		      ldx	#EMERALD_SP
     27  f823		       8e 27 f0 	      stx	[KernelA_K_W + 1]
     28  f826		       a2 11		      ldx	#RESP1
     29  f828		       86 9c		      stx	[RamKernelPhpTarget + 0]
     30  f82a				   .endif_1
     31  f82a				   .if_2
     32  f82a		       0a		      asl
     33  f82b		       90 08		      bcc	.else_2
     34  f82d		       a2 04		      ldx	#BC_NOP
     35  f82f		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     36  f832		       4c 3a f8 	      jmp	.endif_2
     37  f835				   .else_2
     38  f835		       a6 ad		      ldx	BuildKernelMissile
     39  f837		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     40  f83a				   .endif_2
     41  f83a		       a6 ac		      ldx	BuildKernelVdel1
     42  f83c		       8e 2f f0 	      stx	[[KernelA_VDEL1 - $100] + 0]
     43  f83f		       a6 ab		      ldx	BuildKernelGrp0
     44  f841		       8e 07 f0 	      stx	[[KernelA_VDEL0 - $100] + 0]
     45  f844		       a6 a8		      ldx	BuildKernelX
     46  f846		       86 9d		      stx	[RamKernelX + 0]
     47  f848		       a6 a9		      ldx	BuildKernelY
     48  f84a		       86 9e		      stx	[RamKernelY + 0]
     49  f84c		       a2 ff		      ldx	#$ff
     50  f84e		       86 99		      stx	[RamPSByte + 0]
    454  f850		       4c f8 f8 	      jmp	.next
    455  f853				   .kernel_b
    456  f853		       a5 92		      lda	RamNibbleVar1
      0  f855					      NIBBLE_gem_kernel_b
      1  f855		       a6 9f		      ldx	RamKernelGemini1
      2  f857		       8e 1b f0 	      stx	[KernelB_D_W + 0]
      3  f85a				   .if_1
      4  f85a		       0a		      asl
      5  f85b		       90 2a		      bcc	.else_1
      6  f85d		       a2 1c		      ldx	#EMERALD_SP
      7  f85f		       86 9c		      stx	[RamKernelPhpTarget + 0]
      8  f861		       a2 84		      ldx	#BC_STY
      9  f863		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     10  f866		       a2 11		      ldx	#EMERALD_SP_RESET
     11  f868		       8e 1e f0 	      stx	[[KernelB_E_W + 0] + 1]
     12  f86b		       a2 08		      ldx	#BC_PHP
     13  f86d		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     14  f870		       a2 85		      ldx	#BC_STA
     15  f872		       8e 20 f0 	      stx	[[KernelB_G_W + 0] + 0]
     16  f875		       a2 0e		      ldx	#PF1
     17  f877		       8e 21 f0 	      stx	[[KernelB_G_W + 0] + 1]
     18  f87a		       a6 a3		      ldx	RamKernelGemini3
     19  f87c		       8e 22 f0 	      stx	[[KernelB_H_W + 0] + 0]
     20  f87f		       a2 1c		      ldx	#EMERALD_SP
     21  f881		       8e 23 f0 	      stx	[[KernelB_H_W + 0] + 1]
     22  f884		       4c 91 f8 	      jmp	.endif_1
     23  f887				   .else_1
     24  f887		       a6 a1		      ldx	RamKernelGemini2
     25  f889		       8e 1e f0 	      stx	[KernelB_F_W + 0]
     26  f88c		       a2 1c		      ldx	#EMERALD_SP
     27  f88e		       8e 1f f0 	      stx	[KernelB_F_W + 1]
     28  f891				   .endif_1
     29  f891				   .if_2
     30  f891		       0a		      asl
     31  f892		       90 2a		      bcc	.else_2
     32  f894		       a2 1c		      ldx	#EMERALD_SP
     33  f896		       86 9c		      stx	[RamKernelPhpTarget + 0]
     34  f898		       a2 84		      ldx	#BC_STY
     35  f89a		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     36  f89d		       a2 11		      ldx	#EMERALD_SP_RESET
     37  f89f		       8e 1e f0 	      stx	[[KernelB_E_W + 0] + 1]
     38  f8a2		       a6 a1		      ldx	RamKernelGemini2
     39  f8a4		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     40  f8a7		       a2 1c		      ldx	#EMERALD_SP
     41  f8a9		       8e 20 f0 	      stx	[[KernelB_F_W + 1] + 1]
     42  f8ac		       a2 85		      ldx	#BC_STA
     43  f8ae		       8e 21 f0 	      stx	[[KernelB_G_W + 1] + 0]
     44  f8b1		       a2 0e		      ldx	#PF1
     45  f8b3		       8e 22 f0 	      stx	[[KernelB_G_W + 1] + 1]
     46  f8b6		       a2 08		      ldx	#BC_PHP
     47  f8b8		       8e 23 f0 	      stx	[[KernelB_H_W + 1] + 0]
     48  f8bb		       4c c8 f8 	      jmp	.endif_2
     49  f8be				   .else_2
     50  f8be		       a6 a3		      ldx	RamKernelGemini3
     51  f8c0		       8e 22 f0 	      stx	[KernelB_H_W + 0]
     52  f8c3		       a2 1c		      ldx	#EMERALD_SP
     53  f8c5		       8e 23 f0 	      stx	[KernelB_H_W + 1]
     54  f8c8				   .endif_2
     55  f8c8				   .if_3
     56  f8c8		       0a		      asl
     57  f8c9		       90 0d		      bcc	.else_3
     58  f8cb		       a2 c5		      ldx	#$c5
     59  f8cd		       8e 19 f0 	      stx	[[KernelB_C - $100] + 0]
     60  f8d0		       a2 96		      ldx	#RamFFByte
     61  f8d2		       8e 1a f0 	      stx	[[KernelB_C - $100] + 1]
     62  f8d5		       4c e2 f8 	      jmp	.endif_3
     63  f8d8				   .else_3
     64  f8d8		       a2 c5		      ldx	#$c5
     65  f8da		       8e 19 f0 	      stx	[[KernelB_C - $100] + 0]
     66  f8dd		       a2 9a		      ldx	#RamPF1Value
     67  f8df		       8e 1a f0 	      stx	[[KernelB_C - $100] + 1]
     68  f8e2				   .endif_3
     69  f8e2		       a6 a5		      ldx	RamKernelGemini4
     70  f8e4		       8e 26 f0 	      stx	[KernelB_J_W + 0]
     71  f8e7		       a6 ab		      ldx	BuildKernelGrp0
     72  f8e9		       8e 07 f0 	      stx	[[KernelB_VDEL0 - $100] + 0]
     73  f8ec		       a6 a8		      ldx	BuildKernelX
     74  f8ee		       86 9d		      stx	[RamKernelX + 0]
     75  f8f0		       a6 a9		      ldx	BuildKernelY
     76  f8f2		       86 9e		      stx	[RamKernelY + 0]
     77  f8f4		       a2 00		      ldx	#$00
     78  f8f6		       86 99		      stx	[RamPSByte + 0]
    458  f8f8				   .next
    459  f8f8		       60		      rts
    460  f8f9
    461  f8f9
    462  f8f9							; Populate Gemini array from level_for_game
    463  f8f9
    464  f8f9					      mac	gemini_populate
    465  f8f9				   .TARGET    SET	{1}
    466  f8f9					      lda	RamNibbleTemp
    467  f8f9					      and	#%00000011
    468  f8f9					      tay
    469  f8f9					      lda	GEMINI_LOOKUP,y
    470  f8f9					      sta	.TARGET
    471  f8f9					      endm
    472  f8f9
    473  f8f9					      mac	gemini_populate_missile
    474  f8f9				   .TARGET    SET	{1}
    475  f8f9					      lda	RamNibbleTemp
    476  f8f9					      and	#%00000001
    477  f8f9					      sta	.TARGET
    478  f8f9					      endm
    479  f8f9
    480  f900		       00 00 00 00*	      align	256
    481  f900
    482  f900				   gemini_populate
    483  f900		       a6 b1		      ldx	level_for_game + 3
    484  f902		       86 91		      stx	RamNibbleTemp
      0  f904					      GEMINI_POPULATE	DO_GEMS_B + 5
      1  f904				   .TARGET    SET	DO_GEMS_B + 5
      2  f904		       a5 91		      lda	RamNibbleTemp
      3  f906		       29 03		      and	#%00000011
      4  f908		       a8		      tay
      5  f909		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f90c		       85 bf		      sta	.TARGET
    486  f90e		       66 91		      ror	RamNibbleTemp
    487  f910		       66 91		      ror	RamNibbleTemp
      0  f912					      GEMINI_POPULATE	DO_GEMS_A + 5
      1  f912				   .TARGET    SET	DO_GEMS_A + 5
      2  f912		       a5 91		      lda	RamNibbleTemp
      3  f914		       29 03		      and	#%00000011
      4  f916		       a8		      tay
      5  f917		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f91a		       85 b9		      sta	.TARGET
    489  f91c		       66 91		      ror	RamNibbleTemp
    490  f91e		       66 91		      ror	RamNibbleTemp
      0  f920					      GEMINI_POPULATE	DO_GEMS_B + 4
      1  f920				   .TARGET    SET	DO_GEMS_B + 4
      2  f920		       a5 91		      lda	RamNibbleTemp
      3  f922		       29 03		      and	#%00000011
      4  f924		       a8		      tay
      5  f925		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f928		       85 be		      sta	.TARGET
    492  f92a		       66 91		      ror	RamNibbleTemp
    493  f92c		       66 91		      ror	RamNibbleTemp
      0  f92e					      GEMINI_POPULATE	DO_GEMS_A + 4
      1  f92e				   .TARGET    SET	DO_GEMS_A + 4
      2  f92e		       a5 91		      lda	RamNibbleTemp
      3  f930		       29 03		      and	#%00000011
      4  f932		       a8		      tay
      5  f933		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f936		       85 b8		      sta	.TARGET
    495  f938		       66 91		      ror	RamNibbleTemp
    496  f93a		       66 91		      ror	RamNibbleTemp
    497  f93c
    498  f93c		       a6 b0		      ldx	level_for_game + 2
    499  f93e		       86 91		      stx	RamNibbleTemp
      0  f940					      GEMINI_POPULATE_MISSILE	DO_MISS_B
      1  f940				   .TARGET    SET	DO_MISS_B
      2  f940		       a5 91		      lda	RamNibbleTemp
      3  f942		       29 01		      and	#%00000001
      4  f944		       85 b3		      sta	.TARGET
    501  f946		       66 91		      ror	RamNibbleTemp
      0  f948					      GEMINI_POPULATE	DO_GEMS_B + 3
      1  f948				   .TARGET    SET	DO_GEMS_B + 3
      2  f948		       a5 91		      lda	RamNibbleTemp
      3  f94a		       29 03		      and	#%00000011
      4  f94c		       a8		      tay
      5  f94d		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f950		       85 bd		      sta	.TARGET
    503  f952		       66 91		      ror	RamNibbleTemp
    504  f954		       66 91		      ror	RamNibbleTemp
      0  f956					      GEMINI_POPULATE	DO_GEMS_A + 3
      1  f956				   .TARGET    SET	DO_GEMS_A + 3
      2  f956		       a5 91		      lda	RamNibbleTemp
      3  f958		       29 03		      and	#%00000011
      4  f95a		       a8		      tay
      5  f95b		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f95e		       85 b7		      sta	.TARGET
    506  f960		       66 91		      ror	RamNibbleTemp
    507  f962		       66 91		      ror	RamNibbleTemp
      0  f964					      GEMINI_POPULATE	DO_GEMS_B + 2
      1  f964				   .TARGET    SET	DO_GEMS_B + 2
      2  f964		       a5 91		      lda	RamNibbleTemp
      3  f966		       29 03		      and	#%00000011
      4  f968		       a8		      tay
      5  f969		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f96c		       85 bc		      sta	.TARGET
    509  f96e		       66 91		      ror	RamNibbleTemp
    510  f970		       66 91		      ror	RamNibbleTemp
    511  f972
    512  f972		       66 91		      ror	RamNibbleTemp
    513  f974		       a6 af		      ldx	level_for_game + 1
    514  f976		       86 91		      stx	RamNibbleTemp
    515  f978		       26 91		      rol	RamNibbleTemp
      0  f97a					      GEMINI_POPULATE	DO_GEMS_A + 2
      1  f97a				   .TARGET    SET	DO_GEMS_A + 2
      2  f97a		       a5 91		      lda	RamNibbleTemp
      3  f97c		       29 03		      and	#%00000011
      4  f97e		       a8		      tay
      5  f97f		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f982		       85 b6		      sta	.TARGET
    517  f984
    518  f984		       a6 af		      ldx	level_for_game + 1
    519  f986		       86 91		      stx	RamNibbleTemp
    520  f988		       66 91		      ror	RamNibbleTemp
      0  f98a					      GEMINI_POPULATE_MISSILE	DO_MISS_A
      1  f98a				   .TARGET    SET	DO_MISS_A
      2  f98a		       a5 91		      lda	RamNibbleTemp
      3  f98c		       29 01		      and	#%00000001
      4  f98e		       85 b2		      sta	.TARGET
    522  f990		       66 91		      ror	RamNibbleTemp
      0  f992					      GEMINI_POPULATE	DO_GEMS_B + 1
      1  f992				   .TARGET    SET	DO_GEMS_B + 1
      2  f992		       a5 91		      lda	RamNibbleTemp
      3  f994		       29 03		      and	#%00000011
      4  f996		       a8		      tay
      5  f997		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f99a		       85 bb		      sta	.TARGET
    524  f99c		       66 91		      ror	RamNibbleTemp
    525  f99e		       66 91		      ror	RamNibbleTemp
      0  f9a0					      GEMINI_POPULATE	DO_GEMS_A + 1
      1  f9a0				   .TARGET    SET	DO_GEMS_A + 1
      2  f9a0		       a5 91		      lda	RamNibbleTemp
      3  f9a2		       29 03		      and	#%00000011
      4  f9a4		       a8		      tay
      5  f9a5		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f9a8		       85 b5		      sta	.TARGET
    527  f9aa		       66 91		      ror	RamNibbleTemp
    528  f9ac		       66 91		      ror	RamNibbleTemp
      0  f9ae					      GEMINI_POPULATE	DO_GEMS_B + 0
      1  f9ae				   .TARGET    SET	DO_GEMS_B + 0
      2  f9ae		       a5 91		      lda	RamNibbleTemp
      3  f9b0		       29 03		      and	#%00000011
      4  f9b2		       a8		      tay
      5  f9b3		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f9b6		       85 ba		      sta	.TARGET
    530  f9b8		       66 91		      ror	RamNibbleTemp
    531  f9ba		       66 91		      ror	RamNibbleTemp
    532  f9bc
    533  f9bc		       a6 ae		      ldx	level_for_game + 0
    534  f9be		       86 91		      stx	RamNibbleTemp
      0  f9c0					      GEMINI_POPULATE	DO_GEMS_A + 0
      1  f9c0				   .TARGET    SET	DO_GEMS_A + 0
      2  f9c0		       a5 91		      lda	RamNibbleTemp
      3  f9c2		       29 03		      and	#%00000011
      4  f9c4		       a8		      tay
      5  f9c5		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f9c8		       85 b4		      sta	.TARGET
    536  f9ca		       66 91		      ror	RamNibbleTemp
    537  f9cc		       66 91		      ror	RamNibbleTemp
    538  f9ce
    539  f9ce		       60		      rts
    540  f9cf				   gemini_populate_end
    541  f9cf
    542  f9d0		       00		      align	16
    543  f9d0
    544  f9d0				   GEMINI_LOOKUP
    545  f9d0		       00 60 06 66	      .byte.b	G00, G01, G10, G11
    546  f9d4
    547  f9d4				   SHARD_LUT_RF1
    548  f9d4		       00		      .byte.b	#0
    549  f9d5				   SHARD_LUT_VD1
    550  f9d5		       00		      .byte.b	#0
    551  f9d6
------- FILE main.s
------- FILE game_state.s LEVEL 2 PASS 2
      0  f9d6					      include	"game_state.s"
      1  f9d6							; Perform a left rotation on the 32 bit number at
      2  f9d6							; location VLA and store the result at location
      3  f9d6							; RES. If VLA and RES are the same then the
      4  f9d6							; operation is applied directly to the memory,
      5  f9d6							; otherwise it is done in the accumulator.
      6  f9d6							;
      7  f9d6							; On exit: A = ??, X & Y are unchanged.
      8  f9d6
      9  f9d6							;http://www.obelisk.me.uk/6502/maclib.inc but reversed
     10  f9d6					      mac	_ror32
     11  f9d6				   VLA	      EQU	{1}
     12  f9d6				   RES	      EQU	{2}
     13  f9d6					      IF	VLA != RES
     14  f9d6					      LDA	VLA+0
     15  f9d6					      ROR	A
     16  f9d6					      STA	RES+0
     17  f9d6					      LDA	VLA+1
     18  f9d6					      ROR	A
     19  f9d6					      STA	RES+1
     20  f9d6					      LDA	VLA+2
     21  f9d6					      ROR	A
     22  f9d6					      STA	RES+2
     23  f9d6					      LDA	VLA+3
     24  f9d6					      ROR	A
     25  f9d6					      STA	RES+3
     26  f9d6					      ELSE
     27  f9d6					      ROR	VLA+0
     28  f9d6					      ROR	VLA+1
     29  f9d6					      ROR	VLA+2
     30  f9d6					      ROR	VLA+3
     31  f9d6					      ENDIF
     32  f9d6					      ENDM
     33  f9d6							; Add two 32 bit numbers together and store the
     34  f9d6							; result in another memory location. RES may be
     35  f9d6							; the same as either VLA or VLB.
     36  f9d6							;
     37  f9d6							; On exit: A = ??, X & Y are unchanged.
     38  f9d6
     39  f9d6				   game_state_adder
     40  f9d6		       00		      .byte.b	#$0
     41  f9d7		       00		      .byte.b	#$0
     42  f9d8		       00		      .byte.b	#$0
     43  f9d9		       10		      .byte.b	#%10000
     44  f9da
     45  f9da					      mac	_add32
     46  f9da				   .VLA       EQU	{1}
     47  f9da				   .VLB       EQU	{2}
     48  f9da				   .RES       EQU	{3}
     49  f9da					      CLC
     50  f9da					      LDA	.VLA+3
     51  f9da					      ADC	.VLB+3
     52  f9da					      STA	.RES+3
     53  f9da					      LDA	.VLA+2
     54  f9da					      ADC	.VLB+2
     55  f9da					      STA	.RES+2
     56  f9da					      LDA	.VLA+1
     57  f9da					      ADC	.VLB+1
     58  f9da					      STA	.RES+1
     59  f9da					      LDA	.VLA+0
     60  f9da					      ADC	.VLB+0
     61  f9da					      STA	.RES+0
     62  f9da					      ENDM
     63  f9da
     64  f9da				   game_state_setup
     65  f9da							; Set up the level
     66  f9da		       a9 fb		      lda	#%11111011
     67  f9dc		       85 ae		      sta	[level_for_game + 0]
     68  f9de		       a9 ff		      lda	#%11111111
     69  f9e0		       85 af		      sta	[level_for_game + 1]
     70  f9e2		       a9 ff		      lda	#%11111111
     71  f9e4		       85 b0		      sta	[level_for_game + 2]
     72  f9e6		       a9 ff		      lda	#%11111111
     73  f9e8		       85 b1		      sta	[level_for_game + 3]
     74  f9ea		       60		      rts
     75  f9eb
     76  f9f0		       00 00 00 00*	      align	16
     77  f9f0				   game_state_mask
     78  f9f0		       7f		      .byte.b	#%01111111
     79  f9f1		       bf		      .byte.b	#%10111111
     80  f9f2		       df		      .byte.b	#%11011111
     81  f9f3		       ef		      .byte.b	#%11101111
     82  f9f4		       f7		      .byte.b	#%11110111
     83  f9f5		       fb		      .byte.b	#%11111011
     84  f9f6		       fd		      .byte.b	#%11111101
     85  f9f7		       fe		      .byte.b	#%11111110
     86  f9f8
     87  f9f8				   game_state_tick subroutine
     88  f9f8		       20 da f9 	      jsr	game_state_setup
     89  f9fb
     90  f9fb							; Get index [0, 25]
     91  f9fb		       18		      clc
     92  f9fc		       a5 88		      lda	XPos
     93  f9fe		       e9 02		      sbc	#2
     94  fa00		       4a		      lsr
     95  fa01		       4a		      lsr
     96  fa02		       85 81		      sta	Temp
     97  fa04
     98  fa04							; Load bit offset
     99  fa04		       29 07		      and	#%111
    100  fa06		       a8		      tay
    101  fa07		       b9 f0 f9 	      lda	game_state_mask,y
    102  fa0a		       85 82		      sta	Temp2
    103  fa0c
    104  fa0c							; Load sprite offset
    105  fa0c		       a5 81		      lda	Temp
    106  fa0e		       4a		      lsr
    107  fa0f		       4a		      lsr
    108  fa10		       4a		      lsr
    109  fa11		       a8		      tay
    110  fa12		       a5 82		      lda	Temp2
    111  fa14		       99 ae 00 	      sta	level_for_game,y
    112  fa17		       60		      rts
    113  fa18
    114  fa18				   game_state_tick_2 subroutine
      0  fa18					      _ADD32	level_for_game, game_state_adder, level_for_game
      1  fa18		       00 ae	   .VLA       EQU	level_for_game
      2  fa18		       f9 d6	   .VLB       EQU	game_state_adder
      3  fa18		       00 ae	   .RES       EQU	level_for_game
      4  fa18		       18		      CLC
      5  fa19		       a5 b1		      LDA	.VLA+3
      6  fa1b		       6d d9 f9 	      ADC	.VLB+3
      7  fa1e		       85 b1		      STA	.RES+3
      8  fa20		       a5 b0		      LDA	.VLA+2
      9  fa22		       6d d8 f9 	      ADC	.VLB+2
     10  fa25		       85 b0		      STA	.RES+2
     11  fa27		       a5 af		      LDA	.VLA+1
     12  fa29		       6d d7 f9 	      ADC	.VLB+1
     13  fa2c		       85 af		      STA	.RES+1
     14  fa2e		       a5 ae		      LDA	.VLA+0
     15  fa30		       6d d6 f9 	      ADC	.VLB+0
     16  fa33		       85 ae		      STA	.RES+0
    116  fa35		       60		      rts
    117  fa36
    118  fa36							; game_state_tick:
    119  fa36							;     lda FrameCount
    120  fa36							;     and #%111
    121  fa36							;     bne .skiprotate
    122  fa36							;     lda level_for_game + 3
    123  fa36							;     ror
    124  fa36							; .rollall:
    125  fa36							;     _ROR32 level_for_game, level_for_game
    126  fa36
    127  fa36							;     lda #%11101111
    128  fa36							;     cmp [level_for_game + 3]
    129  fa36							;     bne .skiprotate
    130  fa36							;     jmp game_state_setup
    131  fa36							; .skiprotate:
    132  fa36							;     rts
------- FILE main.s
------- FILE kernel_border.s LEVEL 2 PASS 2
      0  fa36					      include	"kernel_border.s"
      1  fa36							; Visible Kernel
      2  fa36
      3  fa36				   KernelBorder subroutine
      4  fa36		       85 02		      sta	WSYNC	; ??? Is this needed?
      5  fa38
      6  fa38							; First HMOVE
      7  fa38		       85 2a		      sta	HMOVE
      8  fa3a
      9  fa3a							; Border top
     10  fa3a		       a9 00		      lda	#0
     11  fa3c		       85 08		      sta	COLUPF
     12  fa3e		       85 0e		      sta	PF1
     13  fa40		       85 0f		      sta	PF2
     14  fa42		       a9 02		      lda	#SIGNAL_LINE
     15  fa44		       85 09		      sta	COLUBK
     16  fa46
     17  fa46					      REPEAT	6
     18  fa46		       85 02		      sta	WSYNC
     17  fa46					      REPEND
     18  fa48		       85 02		      sta	WSYNC
     17  fa48					      REPEND
     18  fa4a		       85 02		      sta	WSYNC
     17  fa4a					      REPEND
     18  fa4c		       85 02		      sta	WSYNC
     17  fa4c					      REPEND
     18  fa4e		       85 02		      sta	WSYNC
     17  fa4e					      REPEND
     18  fa50		       85 02		      sta	WSYNC
     19  fa52					      REPEND
     20  fa52
     21  fa52		       a9 00		      lda	#0
     22  fa54		       85 09		      sta	COLUBK
     23  fa56		       85 02		      sta	WSYNC
     24  fa58
     25  fa58							; Start top border
     26  fa58				   border_top
     27  fa58							; Make the playfield solid.
     28  fa58		       a9 3f		      lda	#%00111111
     29  fa5a		       85 0e		      sta	PF1
     30  fa5c		       a9 ff		      lda	#%11111111
     31  fa5e		       85 0f		      sta	PF2
     32  fa60
     33  fa60		       a9 42		      lda	#COL_BG
     34  fa62		       a0 00		      ldy	#0
     35  fa64
     36  fa64							; X_XXXX_XX
     37  fa64							; Commented lines removed to save on space.
     38  fa64		       85 08		      sta	COLUPF
     39  fa66		       85 02		      sta	WSYNC
     40  fa68		       84 08		      sty	COLUPF
     41  fa6a		       85 02		      sta	WSYNC
     42  fa6c		       85 08		      sta	COLUPF
     43  fa6e		       85 02		      sta	WSYNC
     44  fa70							; sta COLUPF
     45  fa70		       85 02		      sta	WSYNC
     46  fa72							; sta COLUPF
     47  fa72		       85 02		      sta	WSYNC
     48  fa74		       84 08		      sty	COLUPF
     49  fa76		       85 02		      sta	WSYNC
     50  fa78		       85 08		      sta	COLUPF
     51  fa7a
     52  fa7a		       85 02		      sta	WSYNC
     53  fa7c							; sta COLUPF
     54  fa7c
     55  fa7c				   PlayArea
     56  fa7c							; PF is now the playing area
      0  fa7c					      ASSERT_RUNTIME	"_scycles == #0"
      1  fa7c				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fa7c  && !(  _scycles == #0  ) }
      2  fa7c					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  fa7c					      sleep	61
      1  fa7c				   .CYCLES    SET	61
      2  fa7c
      3  fa7c				  -	      IF	.CYCLES < 2
      4  fa7c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fa7c				  -	      ERR
      6  fa7c					      ENDIF
      7  fa7c
      8  fa7c					      IF	.CYCLES & 1
      9  fa7c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fa7c		       04 00		      nop	0
     11  fa7e				  -	      ELSE
     12  fa7e				  -	      bit	VSYNC
     13  fa7e					      ENDIF
     14  fa7e				   .CYCLES    SET	.CYCLES - 3
     15  fa7e					      ENDIF
     16  fa7e
     17  fa7e					      REPEAT	.CYCLES / 2
     18  fa7e		       ea		      nop
     17  fa7e					      REPEND
     18  fa7f		       ea		      nop
     17  fa7f					      REPEND
     18  fa80		       ea		      nop
     17  fa80					      REPEND
     18  fa81		       ea		      nop
     17  fa81					      REPEND
     18  fa82		       ea		      nop
     17  fa82					      REPEND
     18  fa83		       ea		      nop
     17  fa83					      REPEND
     18  fa84		       ea		      nop
     17  fa84					      REPEND
     18  fa85		       ea		      nop
     17  fa85					      REPEND
     18  fa86		       ea		      nop
     17  fa86					      REPEND
     18  fa87		       ea		      nop
     17  fa87					      REPEND
     18  fa88		       ea		      nop
     17  fa88					      REPEND
     18  fa89		       ea		      nop
     17  fa89					      REPEND
     18  fa8a		       ea		      nop
     17  fa8a					      REPEND
     18  fa8b		       ea		      nop
     17  fa8b					      REPEND
     18  fa8c		       ea		      nop
     17  fa8c					      REPEND
     18  fa8d		       ea		      nop
     17  fa8d					      REPEND
     18  fa8e		       ea		      nop
     17  fa8e					      REPEND
     18  fa8f		       ea		      nop
     17  fa8f					      REPEND
     18  fa90		       ea		      nop
     17  fa90					      REPEND
     18  fa91		       ea		      nop
     17  fa91					      REPEND
     18  fa92		       ea		      nop
     17  fa92					      REPEND
     18  fa93		       ea		      nop
     17  fa93					      REPEND
     18  fa94		       ea		      nop
     17  fa94					      REPEND
     18  fa95		       ea		      nop
     17  fa95					      REPEND
     18  fa96		       ea		      nop
     17  fa96					      REPEND
     18  fa97		       ea		      nop
     17  fa97					      REPEND
     18  fa98		       ea		      nop
     17  fa98					      REPEND
     18  fa99		       ea		      nop
     17  fa99					      REPEND
     18  fa9a		       ea		      nop
     19  fa9b					      REPEND
     59  fa9b		       a9 00		      lda	#%00000000
     60  fa9d		       85 0d		      sta	PF0
     61  fa9f		       a9 20		      lda	#%00100000
     62  faa1		       85 0e		      sta	PF1
     63  faa3		       a9 00		      lda	#%00000000
     64  faa5		       85 0f		      sta	PF2
      0  faa7					      ASSERT_RUNTIME	"_scycles == #0"
      1  faa7				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $faa7  && !(  _scycles == #0  ) }
      2  faa7					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  faa7					      sleep	7
      1  faa7				   .CYCLES    SET	7
      2  faa7
      3  faa7				  -	      IF	.CYCLES < 2
      4  faa7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  faa7				  -	      ERR
      6  faa7					      ENDIF
      7  faa7
      8  faa7					      IF	.CYCLES & 1
      9  faa7					      IFNCONST	NO_ILLEGAL_OPCODES
     10  faa7		       04 00		      nop	0
     11  faa9				  -	      ELSE
     12  faa9				  -	      bit	VSYNC
     13  faa9					      ENDIF
     14  faa9				   .CYCLES    SET	.CYCLES - 3
     15  faa9					      ENDIF
     16  faa9
     17  faa9					      REPEAT	.CYCLES / 2
     18  faa9		       ea		      nop
     17  faa9					      REPEND
     18  faaa		       ea		      nop
     19  faab					      REPEND
     67  faab		       4c dd fa 	      jmp	row_start
     68  faae							; enter row on cycle 10.
     69  faae
     70  faae							; reset the background for bottom of playfield
     71  faae				   border_bottom
     72  faae							;sta WSYNC
     73  faae
     74  faae							; Form the bottom of the level frame.
     75  faae		       a9 3f		      lda	#%00111111
     76  fab0		       85 0e		      sta	PF1
     77  fab2		       a9 ff		      lda	#%11111111
     78  fab4		       85 0f		      sta	PF2
     79  fab6
     80  fab6							; Clear all sprites.
     81  fab6		       a9 00		      lda	#0
     82  fab8		       85 1c		      sta	EMERALD_SP
     83  faba		       85 1b		      sta	JET_SP
     84  fabc		       85 1e		      sta	EMERALD_MI_ENABLE
     85  fabe
     86  fabe		       a9 42		      lda	#COL_BG
     87  fac0		       a0 00		      ldy	#0
     88  fac2		       85 02		      sta	WSYNC
     89  fac4
     90  fac4		       84 08		      sty	COLUPF
     91  fac6		       85 02		      sta	WSYNC
     92  fac8
     93  fac8		       85 08		      sta	COLUPF
     94  faca		       85 02		      sta	WSYNC
     95  facc
     96  facc		       85 02		      sta	WSYNC
     97  face
     98  face		       85 02		      sta	WSYNC
     99  fad0
    100  fad0		       84 08		      sty	COLUPF
    101  fad2		       85 02		      sta	WSYNC
    102  fad4
    103  fad4		       85 08		      sta	COLUPF
    104  fad6		       85 02		      sta	WSYNC
    105  fad8		       85 02		      sta	WSYNC
    106  fada		       4c 00 f5 	      jmp	FrameEnd
------- FILE main.s
------- FILE kernel_row.s LEVEL 2 PASS 2
      0  fadd					      include	"kernel_row.s"
      1  fadd							; Frame Start
      2  fadd
      3  fadd							; Macros for calculating sprite values (GRPx).
      4  fadd
      5  fadd							; mac jet_spritedata_calc
      6  fadd							;
      7  fadd							; loads the offset from Frame0 in Y, and the sprite value in A, and stores it in
      8  fadd							; GRP0.
      9  fadd					      mac	jet_spritedata_calc
     10  fadd					      dec	RamRowJetpackIndex
     11  fadd					      ldy	RamRowJetpackIndex
     12  fadd					      ldx	Frame0,Y
     13  fadd					      stx	JET_SP
     14  fadd					      endm
     15  fadd
     16  fadd				   row_start
     17  fadd
     18  fadd							; [scanline 1]
     19  fadd				   row_1
     20  fadd							; Enter after scanline starts on row "9" and wraps
      0  fadd					      ASSERT_RUNTIME	"_scycles == #10"
      1  fadd				   .COND      SET	"_scycles == #10"
 ASSERT: breakif { pc== $fadd  && !(  _scycles == #10  ) }
      2  fadd					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     22  fadd
     23  fadd							; Load sprite details
     24  fadd		       a9 0f		      lda	[#SPRITE_HEIGHT + #7]
     25  fadf		       c5 87		      cmp	SpriteEnd	; 5c
     26  fae1		       a9 00		      lda	#0	; 2c
     27  fae3							; constant 6c: if carry set, load SpriteEnd into y
     28  fae3		       b0 01		      .byte.b	$b0, $01	; 2c / 3c (taken)  : bcs +01 (skipping 1-byte bit instr)
     29  fae5		       0c		      .byte.b	$0c	; 4c / 0c		: bit (skip next two bytes)
     30  fae6		       a5 87		      lda	SpriteEnd
     31  fae8		       69 08		      adc	#8
     32  faea		       85 98		      sta	RamRowJetpackIndex
     33  faec
     34  faec							; Load sprite
     35  faec		       c6 98		      dec	RamRowJetpackIndex
     36  faee		       a4 98		      ldy	RamRowJetpackIndex
     37  faf0		       be 00 fd 	      ldx	Frame0,Y
     38  faf3		       86 1b		      stx	JET_SP
     39  faf5
     40  faf5							; TODO assert cycle is not in visible range!
     41  faf5
     42  faf5							; [[[Nibble VM.]]]
     43  faf5		       85 02		      sta	WSYNC
     44  faf7
     45  faf7							; sleep 46
     46  faf7
      0  faf7					      ASSERT_RUNTIME	"_scycles == #0"
      1  faf7				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $faf7  && !(  _scycles == #0  ) }
      2  faf7					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     48  faf7
     49  faf7							; [scanline 2]
     50  faf7				   row_2
      0  faf7					      jet_spritedata_calc
      1  faf7		       c6 98		      dec	RamRowJetpackIndex
      2  faf9		       a4 98		      ldy	RamRowJetpackIndex
      3  fafb		       be 00 fd 	      ldx	Frame0,Y
      4  fafe		       86 1b		      stx	JET_SP
      0  fb00					      sleep	5
      1  fb00				   .CYCLES    SET	5
      2  fb00
      3  fb00				  -	      IF	.CYCLES < 2
      4  fb00				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb00				  -	      ERR
      6  fb00					      ENDIF
      7  fb00
      8  fb00					      IF	.CYCLES & 1
      9  fb00					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb00		       04 00		      nop	0
     11  fb02				  -	      ELSE
     12  fb02				  -	      bit	VSYNC
     13  fb02					      ENDIF
     14  fb02				   .CYCLES    SET	.CYCLES - 3
     15  fb02					      ENDIF
     16  fb02
     17  fb02					      REPEAT	.CYCLES / 2
     18  fb02		       ea		      nop
     19  fb03					      REPEND
     53  fb03
     54  fb03							; Black out playfield
     55  fb03							; TODO This should be done with playfield pixels, not color.
     56  fb03		       a9 00		      lda	#0
     57  fb05		       85 08		      sta	COLUPF
     58  fb07
     59  fb07							; [[[Nibble VM.]]]
      0  fb07					      sleep	25
      1  fb07				   .CYCLES    SET	25
      2  fb07
      3  fb07				  -	      IF	.CYCLES < 2
      4  fb07				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb07				  -	      ERR
      6  fb07					      ENDIF
      7  fb07
      8  fb07					      IF	.CYCLES & 1
      9  fb07					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb07		       04 00		      nop	0
     11  fb09				  -	      ELSE
     12  fb09				  -	      bit	VSYNC
     13  fb09					      ENDIF
     14  fb09				   .CYCLES    SET	.CYCLES - 3
     15  fb09					      ENDIF
     16  fb09
     17  fb09					      REPEAT	.CYCLES / 2
     18  fb09		       ea		      nop
     17  fb09					      REPEND
     18  fb0a		       ea		      nop
     17  fb0a					      REPEND
     18  fb0b		       ea		      nop
     17  fb0b					      REPEND
     18  fb0c		       ea		      nop
     17  fb0c					      REPEND
     18  fb0d		       ea		      nop
     17  fb0d					      REPEND
     18  fb0e		       ea		      nop
     17  fb0e					      REPEND
     18  fb0f		       ea		      nop
     17  fb0f					      REPEND
     18  fb10		       ea		      nop
     17  fb10					      REPEND
     18  fb11		       ea		      nop
     17  fb11					      REPEND
     18  fb12		       ea		      nop
     17  fb12					      REPEND
     18  fb13		       ea		      nop
     19  fb14					      REPEND
     61  fb14
     62  fb14							; Load PF1 value
     63  fb14		       a9 3d		      lda	#%00111101
     64  fb16		       85 9a		      sta	RamPF1Value
     65  fb18
     66  fb18		       a9 04		      lda	#4
     67  fb1a		       8d 96 02 	      sta	TIM64T
     68  fb1d
     69  fb1d							; Set stack pointer for PHP use from RamKernelPhpTarget.
     70  fb1d		       a6 9c		      ldx	RamKernelPhpTarget
     71  fb1f		       ca		      dex
     72  fb20		       9a		      txs
     73  fb21
     74  fb21							; Enable playfield at end of scanline
     75  fb21		       a9 42		      lda	#COL_BG
     76  fb23		       85 08		      sta	COLUPF
     77  fb25
     78  fb25							; Set overflow flag
     79  fb25		       24 99		      bit	RamPSByte
     80  fb27
      0  fb27					      ASSERT_RUNTIME	"_scycles == #0"
      1  fb27				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fb27  && !(  _scycles == #0  ) }
      2  fb27					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     82  fb27
     83  fb27							; [scanline 3]
     84  fb27				   row_3
     85  fb27							; Current row and next two rows.
     86  fb27		       a4 98		      ldy	RamRowJetpackIndex
     87  fb29		       88		      dey
     88  fb2a		       be 00 fd 	      ldx	Frame0,Y
     89  fb2d		       86 1b		      stx	JET_SP
     90  fb2f		       88		      dey
     91  fb30		       be 00 fd 	      ldx	Frame0,Y
     92  fb33		       86 9b		      stx	RamKernelGRP0
     93  fb35		       88		      dey
     94  fb36		       be 00 fd 	      ldx	Frame0,Y
     95  fb39		       8e 03 f0 	      stx	[KernelA_GRP0 - $100]
     96  fb3c		       84 98		      sty	RamRowJetpackIndex
     97  fb3e
     98  fb3e							; Idle.
      0  fb3e					      sleep	22
      1  fb3e				   .CYCLES    SET	22
      2  fb3e
      3  fb3e				  -	      IF	.CYCLES < 2
      4  fb3e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb3e				  -	      ERR
      6  fb3e					      ENDIF
      7  fb3e
      8  fb3e				  -	      IF	.CYCLES & 1
      9  fb3e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb3e				  -	      nop	0
     11  fb3e				  -	      ELSE
     12  fb3e				  -	      bit	VSYNC
     13  fb3e				  -	      ENDIF
     14  fb3e				  -.CYCLES    SET	.CYCLES - 3
     15  fb3e					      ENDIF
     16  fb3e
     17  fb3e					      REPEAT	.CYCLES / 2
     18  fb3e		       ea		      nop
     17  fb3e					      REPEND
     18  fb3f		       ea		      nop
     17  fb3f					      REPEND
     18  fb40		       ea		      nop
     17  fb40					      REPEND
     18  fb41		       ea		      nop
     17  fb41					      REPEND
     18  fb42		       ea		      nop
     17  fb42					      REPEND
     18  fb43		       ea		      nop
     17  fb43					      REPEND
     18  fb44		       ea		      nop
     17  fb44					      REPEND
     18  fb45		       ea		      nop
     17  fb45					      REPEND
     18  fb46		       ea		      nop
     17  fb46					      REPEND
     18  fb47		       ea		      nop
     17  fb47					      REPEND
     18  fb48		       ea		      nop
     19  fb49					      REPEND
    100  fb49
    101  fb49							; Setup for kernel
    102  fb49		       38		      sec		; clear carry bit
    103  fb4a		       a6 9d		      ldx	RamKernelX
    104  fb4c		       a4 9e		      ldy	RamKernelY
    105  fb4e
    106  fb4e							; Jump immediately into scanlines 4-5 aka "kernel_gem"
    107  fb4e		       a5 ac		      lda	BuildKernelVdel1
    108  fb50		       85 1c		      sta	EMERALD_SP
    109  fb52		       a5 9b		      lda	RamKernelGRP0	; Load sprite 2 into A
    110  fb54							; [scanline 4]
    111  fb54							; [scanline 5]
      0  fb54					      ASSERT_RUNTIME	"_scycles == #73"
      1  fb54				   .COND      SET	"_scycles == #73"
 ASSERT: breakif { pc== $fb54  && !(  _scycles == #73  ) }
      2  fb54					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    113  fb54		       4c 04 f1 	      jmp	CBSRAM_KERNEL_ENTRY
    114  fb57
    115  fb57							; [scanline 6]
    116  fb57
    117  fb57							; Try to avoid page crossing in jet_spritedata_calc
    118  fb57							; TODO enforce this with ASSERT_RUNTIME instead?
    119  fb60		       00 00 00 00*	      align	16
    120  fb60
    121  fb60				   row_after_kernel
    122  fb60				   row_6
      0  fb60					      ASSERT_RUNTIME	"_scycles == #0"
      1  fb60				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fb60  && !(  _scycles == #0  ) }
      2  fb60					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    124  fb60
    125  fb60							; Cleanup from the kernel.
    126  fb60		       a9 00		      lda	#0
    127  fb62		       85 1e		      sta	EMERALD_MI_ENABLE
    128  fb64		       85 1c		      sta	EMERALD_SP
    129  fb66		       85 08		      sta	COLUPF
    130  fb68		       85 26		      sta	VDELP1
    131  fb6a
    132  fb6a		       a9 20		      lda	#%00100000
    133  fb6c		       85 0e		      sta	PF1
    134  fb6e
      0  fb6e					      jet_spritedata_calc
      1  fb6e		       c6 98		      dec	RamRowJetpackIndex
      2  fb70		       a4 98		      ldy	RamRowJetpackIndex
      3  fb72		       be 00 fd 	      ldx	Frame0,Y
      4  fb75		       86 1b		      stx	JET_SP
    136  fb77
    137  fb77							; Idle.
    138  fb77		       85 02		      sta	WSYNC
    139  fb79
    140  fb79							; [scanline 7]
    141  fb79				   row_7
      0  fb79					      jet_spritedata_calc
      1  fb79		       c6 98		      dec	RamRowJetpackIndex
      2  fb7b		       a4 98		      ldy	RamRowJetpackIndex
      3  fb7d		       be 00 fd 	      ldx	Frame0,Y
      4  fb80		       86 1b		      stx	JET_SP
      0  fb82					      sleep	5
      1  fb82				   .CYCLES    SET	5
      2  fb82
      3  fb82				  -	      IF	.CYCLES < 2
      4  fb82				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb82				  -	      ERR
      6  fb82					      ENDIF
      7  fb82
      8  fb82					      IF	.CYCLES & 1
      9  fb82					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb82		       04 00		      nop	0
     11  fb84				  -	      ELSE
     12  fb84				  -	      bit	VSYNC
     13  fb84					      ENDIF
     14  fb84				   .CYCLES    SET	.CYCLES - 3
     15  fb84					      ENDIF
     16  fb84
     17  fb84					      REPEAT	.CYCLES / 2
     18  fb84		       ea		      nop
     19  fb85					      REPEND
      0  fb85					      ASSERT_RUNTIME	"_scycles == #20"
      1  fb85				   .COND      SET	"_scycles == #20"
 ASSERT: breakif { pc== $fb85  && !(  _scycles == #20  ) }
      2  fb85					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    145  fb85
    146  fb85		       a9 42		      lda	#COL_BG
    147  fb87		       85 08		      sta	COLUPF
    148  fb89
    149  fb89							; FRAMESWITCH
    150  fb89		       a9 01		      lda	#01
    151  fb8b		       25 85		      and	FrameCount
    152  fb8d		       d0 11		      bne	loadframe2
    153  fb8f
    154  fb8f							; Perform gem loading for Kernel A.
    155  fb8f
    156  fb8f				   loadframe1
      0  fb8f					      ASSERT_RUNTIME	"_scycles == #32"
      1  fb8f				   .COND      SET	"_scycles == #32"
 ASSERT: breakif { pc== $fb8f  && !(  _scycles == #32  ) }
      2  fb8f					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    158  fb8f
    159  fb8f							; Emerald byte setting 1A
    160  fb8f							; ldx #0
    161  fb8f							; lda KERNEL_STORAGE_R,X
    162  fb8f							; sta GEM_00_W
    163  fb8f							; inx
    164  fb8f							; lda KERNEL_STORAGE_R,X
    165  fb8f							; sta GEM_04_W
    166  fb8f							; inx
    167  fb8f							; lda KERNEL_STORAGE_R,X
    168  fb8f							; sta GEM_09_W
    169  fb8f							; inx
    170  fb8f
    171  fb8f		       85 02		      sta	WSYNC
    172  fb91
    173  fb91							; [scanline 8]
      0  fb91					      jet_spritedata_calc
      1  fb91		       c6 98		      dec	RamRowJetpackIndex
      2  fb93		       a4 98		      ldy	RamRowJetpackIndex
      3  fb95		       be 00 fd 	      ldx	Frame0,Y
      4  fb98		       86 1b		      stx	JET_SP
      0  fb9a					      sleep	5
      1  fb9a				   .CYCLES    SET	5
      2  fb9a
      3  fb9a				  -	      IF	.CYCLES < 2
      4  fb9a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb9a				  -	      ERR
      6  fb9a					      ENDIF
      7  fb9a
      8  fb9a					      IF	.CYCLES & 1
      9  fb9a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb9a		       04 00		      nop	0
     11  fb9c				  -	      ELSE
     12  fb9c				  -	      bit	VSYNC
     13  fb9c					      ENDIF
     14  fb9c				   .CYCLES    SET	.CYCLES - 3
     15  fb9c					      ENDIF
     16  fb9c
     17  fb9c					      REPEAT	.CYCLES / 2
     18  fb9c		       ea		      nop
     19  fb9d					      REPEND
    176  fb9d
    177  fb9d							; Emerald byte setting 1B
    178  fb9d							; lda KERNEL_STORAGE_R,X
    179  fb9d							; sta GEM_13_W
    180  fb9d							; inx
    181  fb9d							; lda KERNEL_STORAGE_R,X
    182  fb9d							; sta GEM_17_W
    183  fb9d							; inx
    184  fb9d							; lda KERNEL_STORAGE_R,X
    185  fb9d							; sta GEM_18_W
    186  fb9d							; inx
    187  fb9d							; lda KERNEL_STORAGE_R,X
    188  fb9d							; sta GEM_22_W
    189  fb9d
    190  fb9d		       4c b1 fb 	      jmp	row_8_end
    191  fba0
    192  fba0							; Perform gem loading for Kernel B.
    193  fba0
    194  fba0				   loadframe2
      0  fba0					      ASSERT_RUNTIME	"_scycles == #33"
      1  fba0				   .COND      SET	"_scycles == #33"
 ASSERT: breakif { pc== $fba0  && !(  _scycles == #33  ) }
      2  fba0					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    196  fba0
    197  fba0							; Emerald byte setting 2A
    198  fba0							; ldx #[storage_02 - storage]
    199  fba0							; lda KERNEL_STORAGE_R,X
    200  fba0							; sta GEM_02_W
    201  fba0							; inx
    202  fba0							; lda KERNEL_STORAGE_R,X
    203  fba0							; sta GEM_06_W
    204  fba0							; inx
    205  fba0							; lda KERNEL_STORAGE_R,X
    206  fba0							; sta GEM_08_W
    207  fba0							; inx
    208  fba0
    209  fba0		       85 02		      sta	WSYNC
    210  fba2
    211  fba2							; [scanline 8]
    212  fba2				   row_8
      0  fba2					      jet_spritedata_calc
      1  fba2		       c6 98		      dec	RamRowJetpackIndex
      2  fba4		       a4 98		      ldy	RamRowJetpackIndex
      3  fba6		       be 00 fd 	      ldx	Frame0,Y
      4  fba9		       86 1b		      stx	JET_SP
      0  fbab					      sleep	5
      1  fbab				   .CYCLES    SET	5
      2  fbab
      3  fbab				  -	      IF	.CYCLES < 2
      4  fbab				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbab				  -	      ERR
      6  fbab					      ENDIF
      7  fbab
      8  fbab					      IF	.CYCLES & 1
      9  fbab					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbab		       04 00		      nop	0
     11  fbad				  -	      ELSE
     12  fbad				  -	      bit	VSYNC
     13  fbad					      ENDIF
     14  fbad				   .CYCLES    SET	.CYCLES - 3
     15  fbad					      ENDIF
     16  fbad
     17  fbad					      REPEAT	.CYCLES / 2
     18  fbad		       ea		      nop
     19  fbae					      REPEND
    215  fbae
    216  fbae							; Emerald byte setting 2B
    217  fbae							; lda KERNEL_STORAGE_R,X
    218  fbae							; sta GEM_11_W
    219  fbae							; inx
    220  fbae							; lda KERNEL_STORAGE_R,X
    221  fbae							; sta GEM_15_W
    222  fbae							; inx
    223  fbae							; lda KERNEL_STORAGE_R,X
    224  fbae							; sta GEM_20_W
    225  fbae							; inx
    226  fbae							; lda KERNEL_STORAGE_R,X
    227  fbae							; sta GEM_24_W
    228  fbae
    229  fbae		       4c b1 fb 	      jmp	row_8_end
    230  fbb1
    231  fbb1							; Common row 8 return.
    232  fbb1
    233  fbb1				   row_8_end
    234  fbb1							; Decrease SpriteEnd
    235  fbb1		       38		      sec
    236  fbb2		       a5 87		      lda	SpriteEnd
    237  fbb4		       e9 08		      sbc	#8
    238  fbb6		       85 87		      sta	SpriteEnd
    239  fbb8
    240  fbb8							; Idle.
    241  fbb8		       85 02		      sta	WSYNC
    242  fbba
    243  fbba							; [scanline 8]
    244  fbba							; Repeat loop until LoopCount < 0
    245  fbba		       c6 84		      dec	LoopCount
    246  fbbc		       f0 03		      beq	row_end
    247  fbbe		       4c dd fa 	      jmp	row_start
    248  fbc1				   row_end
    249  fbc1		       4c ae fa 	      jmp	border_bottom
------- FILE main.s
------- FILE kernel_gem.s LEVEL 2 PASS 2
      0  fbc4					      include	"kernel_gem.s"
      1  fbc4							;
      2  fbc4							; Gem Kernels
      3  fbc4							;
      4  fbc4							; Gems are displayed in alternating kernels. This chart shows
      5  fbc4							; which kernel is responsible for which gem, with missiles denoted.
      6  fbc4							;
      7  fbc4							;  1:	 |SS  SS  MSS  |SS   SS  SS  |	      kernel 1 (S = Sprite, M = missile)
      8  fbc4							;  2:	 |  SS	SS   SS|  SSM  SS  SS|	      kernel 2
      9  fbc4							;  =	 |1122112221122|1122111221122|	      kernel #
     10  fbc4							;  #	 0^	 8^	  17^	    26^       gem index
     11  fbc4							;
     12  fbc4							; The middle bar indicates where the pattern reverses.
     13  fbc4							;
     14  fbc4							; Because we can repeat a sprite multiple times, and reset the sprite
     15  fbc4							; occurance mid-line, we can render close to half of the 26 gems a line
     16  fbc4							; requires with a single sprite. By alternating sprites each frame with an...
     17  fbc4							; acceptable amount of flicker (15Hz) we can render almost all the gems on each
     18  fbc4							; line, except for two. These are instead rendered by the missile, which
     19  fbc4							; corresponds to the sprite and must have the same color and repeat pattern.
     20  fbc4
     21  fbc4							; for copying
     22  fc00		       00 00 00 00*	      align	256
     23  fc00
     24  fc00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     25  fc00							;
     26  fc00							; GEM KERNEL A
     27  fc00							;
     28  fc00
     29  fc00				   kernel_1_start subroutine
     30  fc00					      rorg	$f100
     31  fc00
     32  fc00							; Kernel Marker
     33  fc00		       0a		      .byte.b	$A
     34  fc01
     35  fc01				   KernelA_early
      0  fc01					      ASSERT_RUNTIME_KERNEL	$A, "v == #1"
      1  fc01				   .KERNEL    SET	$A
      2  fc01				   .COND      SET	"v == #1"
 ASSERT: breakif { pc== $f101  && ( *$f100 ==  $a   ) && ! (  v == #1  ) }
      3  fc01					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     37  fc01		       b8		      clv
     38  fc02
     39  fc02							; Early code to set next Player GRP0. Immediate value is overwritten
     40  fc02		       a9 ff		      lda	#$ff
     41  fc02		       f1 03	   KernelA_GRP0 =	. - 1
     42  fc04
     43  fc04				   KernelA    subroutine
      0  fc04					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #0"
      1  fc04				   .KERNEL    SET	$A
      2  fc04				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $a   ) && ! (  _scycles == #0  ) }
      3  fc04					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     45  fc04
     46  fc04							; Write Player from accumulator. When writing to the other sprite, the
     47  fc04							; TIA will copy Gemini 0A into visible sprite register
     48  fc04		       85 1b		      sta	JET_SP
     49  fc06							; Write Gemini 1A into visible sprite register
     50  fc06		       a9 66		      lda	#%01100110
     51  fc06		       f1 07	   KernelA_VDEL0 =	. - 1
     52  fc08		       85 1c		      sta	EMERALD_SP
     53  fc0a
     54  fc0a							; Register config
     55  fc0a		       a9 08		      lda	#%00001000
     56  fc0c		       85 0c		      sta	REFP1
     57  fc0e
     58  fc0e		       a9 20		      lda	#%00100000
     59  fc10		       85 0e		      sta	PF1
     60  fc12
     61  fc12							; Reset stack pointer
     62  fc12		       68		      pla
     63  fc13
     64  fc13							; 22c is critical start of precise GRP0 timing for Kernel A
      0  fc13					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #22"
      1  fc13				   .KERNEL    SET	$A
      2  fc13				   .COND      SET	"_scycles == #22"
 ASSERT: breakif { pc== $f113  && ( *$f100 ==  $a   ) && ! (  _scycles == #22  ) }
      3  fc13					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     66  fc13				   KernelA_A
     67  fc13		       85 11		      sta	EMERALD_SP_RESET	; RESPx must be strobed on cycle 25c.
     68  fc15
     69  fc15							; RST0 vvv
     70  fc15				   KernelA_B
     71  fc15		       a5 9a		      lda	RamPF1Value
     72  fc17				   KernelA_C
     73  fc17		       84 26		      sty	VDELP1	; disable delayed sprite
     74  fc19				   KernelA_D
     75  fc19							; sty EMERALD_SP ; Gemini 1A
      0  fc19					      sleep	3
      1  fc19				   .CYCLES    SET	3
      2  fc19
      3  fc19				  -	      IF	.CYCLES < 2
      4  fc19				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc19				  -	      ERR
      6  fc19					      ENDIF
      7  fc19
      8  fc19					      IF	.CYCLES & 1
      9  fc19					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc19		       04 00		      nop	0
     11  fc1b				  -	      ELSE
     12  fc1b				  -	      bit	VSYNC
     13  fc1b					      ENDIF
     14  fc1b				   .CYCLES    SET	.CYCLES - 3
     15  fc1b					      ENDIF
     16  fc1b
     17  fc1b				  -	      REPEAT	.CYCLES / 2
     18  fc1b				  -	      nop
     19  fc1b					      REPEND
     77  fc1b							; RST0 ^^^
     78  fc1b
     79  fc1b				   KernelA_E
     80  fc1b		       85 11		      sta	EMERALD_SP_RESET	; Reset "medium close" NUSIZ repetition
     81  fc1d				   KernelA_F
     82  fc1d		       86 1e		      stx	EMERALD_MI_ENABLE	; Enable the missile (if register uses the %0xx00110 pattern)
     83  fc1f				   KernelA_G
     84  fc1f		       84 1c		      sty	EMERALD_SP	; Gemini 2A
     85  fc21
     86  fc21				   KernelA_H
     87  fc21		       84 1c		      sty	EMERALD_SP	; Gemini 3A, modified for RST2 along with HMM1
     88  fc23
      0  fc23					      ASSERT_RUNTIME_KERNEL	$A, "c == #1"
      1  fc23				   .KERNEL    SET	$A
      2  fc23				   .COND      SET	"c == #1"
 ASSERT: breakif { pc== $f123  && ( *$f100 ==  $a   ) && ! (  c == #1  ) }
      3  fc23					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     90  fc23							; RST4 vvv
     91  fc23				   KernelA_I
     92  fc23		       08		      php		; Reset "medium close" NUSIZ repetition
     93  fc24				   KernelA_J		; unchanging
     94  fc24		       85 0e		      sta	PF1	; Write asymmetrical playfield register
     95  fc26				   KernelA_K
     96  fc26		       84 1c		      sty	EMERALD_SP	; Gemini 4A
     97  fc28							; RST4 ^^^
     98  fc28
     99  fc28				   KernelA_L
    100  fc28		       a5 94		      lda	RamZeroByte	; FIXME this doesn't belong here
    101  fc2a				   KernelA_M
    102  fc2a		       84 26		      sty	VDELP1	; Gemini 5A ; need a way to skip this vlaue
    103  fc2c				   KernelA_N
    104  fc2c		       85 1e		      sta	EMERALD_MI_ENABLE	; disable missile FIXME better place for this?
    105  fc2e				   KernelA_O
    106  fc2e		       a9 66		      lda	#%01100110
    107  fc2e		       f1 2f	   KernelA_VDEL1 =	. - 1
    108  fc30
    109  fc30							; End visible line
      0  fc30					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #66"
      1  fc30				   .KERNEL    SET	$A
      2  fc30				   .COND      SET	"_scycles == #66"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $a   ) && ! (  _scycles == #66  ) }
      3  fc30					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    111  fc30				   KernelA_branch
    112  fc30		       85 1c		      sta	EMERALD_SP	; set VDEL1
    113  fc32
    114  fc32							; Branch or return.
    115  fc32		       70 cd		      bvs	KernelA_early
      0  fc34					      sleep	2
      1  fc34				   .CYCLES    SET	2
      2  fc34
      3  fc34				  -	      IF	.CYCLES < 2
      4  fc34				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc34				  -	      ERR
      6  fc34					      ENDIF
      7  fc34
      8  fc34				  -	      IF	.CYCLES & 1
      9  fc34				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc34				  -	      nop	0
     11  fc34				  -	      ELSE
     12  fc34				  -	      bit	VSYNC
     13  fc34				  -	      ENDIF
     14  fc34				  -.CYCLES    SET	.CYCLES - 3
     15  fc34					      ENDIF
     16  fc34
     17  fc34					      REPEAT	.CYCLES / 2
     18  fc34		       ea		      nop
     19  fc35					      REPEND
    117  fc35		       4c 60 fb 	      jmp	row_after_kernel
    118  fc38
    119  fc38					      rend
    120  fc38				   kernel_1_end
      0  fc38					      ASSERT_SIZE	kernel_1_start, kernel_1_end, $40
      1  fc38				   .STARTA    SET	kernel_1_start
      2  fc38				   .ENDA      SET	kernel_1_end
      3  fc38				   .LEN       SET	$40
      4  fc38				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fc38				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fc38				  -	      err
      7  fc38					      endif
    122  fc38
    123  fc38							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    124  fc38							;
    125  fc38							; GEM KERNEL B
    126  fc38							;
    127  fc38
    128  fc38				   kernel_2_start subroutine
    129  fc38					      rorg	$f100
    130  fc38
    131  fc38							; Kernel Marker
    132  fc38		       0b		      .byte.b	$B
    133  fc39
    134  fc39		       b8		      clv
    135  fc3a
    136  fc3a				   KernelB_early
    137  fc3a							; Early code to set next GRP0 image. Value is overwritten
    138  fc3a		       a9 ff		      lda	#$ff
    139  fc3a		       f1 03	   KernelB_GRP0 =	. - 1
    140  fc3c
    141  fc3c				   KernelB    subroutine
      0  fc3c					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #0"
      1  fc3c				   .KERNEL    SET	$B
      2  fc3c				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $b   ) && ! (  _scycles == #0  ) }
      3  fc3c					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    143  fc3c
    144  fc3c							; Write Player from accumulator. When writing to the other sprite, the
    145  fc3c							; TIA will copy Gemini 0A into visible sprite register
    146  fc3c		       85 1b		      sta	JET_SP
    147  fc3e		       a9 aa		      lda	#%10101010
    148  fc3e		       f1 07	   KernelB_VDEL0 =	. - 1
    149  fc40							; Write Gemini 1A into delayed sprite register
    150  fc40		       85 1c		      sta	EMERALD_SP
    151  fc42
    152  fc42							; Reset stack
    153  fc42		       68		      pla
    154  fc43
    155  fc43							; 6c
    156  fc43		       a9 20		      lda	#%00100000
    157  fc45		       85 0e		      sta	PF1
    158  fc47
    159  fc47							; Register config
    160  fc47		       a9 ff		      lda	#$ff
    161  fc49		       85 1e		      sta	EMERALD_MI_ENABLE	; enable missile
    162  fc4b
    163  fc4b							; Set processor register bit for PHP sprite rendering.
      0  fc4b					      sleep	3
      1  fc4b				   .CYCLES    SET	3
      2  fc4b
      3  fc4b				  -	      IF	.CYCLES < 2
      4  fc4b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc4b				  -	      ERR
      6  fc4b					      ENDIF
      7  fc4b
      8  fc4b					      IF	.CYCLES & 1
      9  fc4b					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc4b		       04 00		      nop	0
     11  fc4d				  -	      ELSE
     12  fc4d				  -	      bit	VSYNC
     13  fc4d					      ENDIF
     14  fc4d				   .CYCLES    SET	.CYCLES - 3
     15  fc4d					      ENDIF
     16  fc4d
     17  fc4d				  -	      REPEAT	.CYCLES / 2
     18  fc4d				  -	      nop
     19  fc4d					      REPEND
    165  fc4d
    166  fc4d							; 25c is critical start of precise GRP0 timing for Kernel B
      0  fc4d					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #25"
      1  fc4d				   .KERNEL    SET	$B
      2  fc4d				   .COND      SET	"_scycles == #25"
 ASSERT: breakif { pc== $f115  && ( *$f100 ==  $b   ) && ! (  _scycles == #25  ) }
      3  fc4d					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    168  fc4d				   KernelB_A
    169  fc4d		       85 11		      sta	EMERALD_SP_RESET
    170  fc4f				   KernelB_B
    171  fc4f		       a5 9a		      lda	RamPF1Value
    172  fc51				   KernelB_C
    173  fc51		       c5 9a		      cmp	RamPF1Value
    174  fc53				   KernelB_D
    175  fc53		       86 1c		      stx	EMERALD_SP	; Gemini 1B
    176  fc55
    177  fc55							; below has one php load (could just be RESET)
    178  fc55				   KernelB_E
    179  fc55		       08		      php
    180  fc56				   KernelB_F
    181  fc56		       84 1c		      sty	EMERALD_SP	; Gemini 2B
    182  fc58				   KernelB_G
    183  fc58		       85 0e		      sta	PF1
    184  fc5a				   KernelB_H
    185  fc5a		       84 1c		      sty	EMERALD_SP	; Gemini 3B; TODO write php instead fixed
    186  fc5c							; above has one PHP load
    187  fc5c
    188  fc5c				   KernelB_I
    189  fc5c		       85 11		      sta	EMERALD_SP_RESET
    190  fc5e				   KernelB_J
    191  fc5e		       84 1c		      sty	EMERALD_SP	; Gemini 4B
    192  fc60				   KernelB_K
    193  fc60		       85 1e		      sta	EMERALD_MI_ENABLE	; FIXME this can't rely on sta
    194  fc62				   KernelB_L
    195  fc62		       86 1c		      stx	EMERALD_SP	; Gemini 5B
    196  fc64
    197  fc64				   KernelB_M
      0  fc64					      sleep	3
      1  fc64				   .CYCLES    SET	3
      2  fc64
      3  fc64				  -	      IF	.CYCLES < 2
      4  fc64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc64				  -	      ERR
      6  fc64					      ENDIF
      7  fc64
      8  fc64					      IF	.CYCLES & 1
      9  fc64					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc64		       04 00		      nop	0
     11  fc66				  -	      ELSE
     12  fc66				  -	      bit	VSYNC
     13  fc66					      ENDIF
     14  fc66				   .CYCLES    SET	.CYCLES - 3
     15  fc66					      ENDIF
     16  fc66
     17  fc66				  -	      REPEAT	.CYCLES / 2
     18  fc66				  -	      nop
     19  fc66					      REPEND
    199  fc66				   KernelB_N
      0  fc66					      sleep	3
      1  fc66				   .CYCLES    SET	3
      2  fc66
      3  fc66				  -	      IF	.CYCLES < 2
      4  fc66				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fc66				  -	      ERR
      6  fc66					      ENDIF
      7  fc66
      8  fc66					      IF	.CYCLES & 1
      9  fc66					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fc66		       04 00		      nop	0
     11  fc68				  -	      ELSE
     12  fc68				  -	      bit	VSYNC
     13  fc68					      ENDIF
     14  fc68				   .CYCLES    SET	.CYCLES - 3
     15  fc68					      ENDIF
     16  fc68
     17  fc68				  -	      REPEAT	.CYCLES / 2
     18  fc68				  -	      nop
     19  fc68					      REPEND
    201  fc68
    202  fc68							; End visible line
      0  fc68					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #67"
      1  fc68				   .KERNEL    SET	$B
      2  fc68				   .COND      SET	"_scycles == #67"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $b   ) && ! (  _scycles == #67  ) }
      3  fc68					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    204  fc68
    205  fc68				   KernelB_branch
    206  fc68		       ad 84 02 	      lda	INTIM
    207  fc6b		       d0 cd		      bne	KernelB_early
    208  fc6d		       4c 60 fb 	      jmp	row_after_kernel
    209  fc70
    210  fc70					      rend
    211  fc70				   kernel_2_end
      0  fc70					      ASSERT_SIZE	kernel_2_start, kernel_2_end, $40
      1  fc70				   .STARTA    SET	kernel_2_start
      2  fc70				   .ENDA      SET	kernel_2_end
      3  fc70				   .LEN       SET	$40
      4  fc70				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fc70				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fc70				  -	      err
      7  fc70					      endif
------- FILE main.s
------- FILE data_sprites.s LEVEL 2 PASS 2
      0  fc70					      include	"data_sprites.s"
      1  fc70
      2  fd00		       00 00 00 00*	      align	256
      3  fd00
      4  fd00				   Frame0
      5  fd00							; 8 buffer
      6  fd00		       00		      .byte.b	#%00000000
      7  fd01		       00		      .byte.b	#%00000000
      8  fd02		       00		      .byte.b	#%00000000
      9  fd03		       00		      .byte.b	#%00000000
     10  fd04		       00		      .byte.b	#%00000000
     11  fd05		       00		      .byte.b	#%00000000
     12  fd06		       00		      .byte.b	#%00000000
     13  fd07		       00		      .byte.b	#%00000000
     14  fd08
     15  fd08							; 8 rows
     16  fd08		       60		      .byte.b	#%01100000
     17  fd09		       60		      .byte.b	#%01100000
     18  fd0a		       60		      .byte.b	#%01100000
     19  fd0b		       c0		      .byte.b	#%11000000
     20  fd0c		       c0		      .byte.b	#%11000000
     21  fd0d		       f0		      .byte.b	#%11110000
     22  fd0e		       c0		      .byte.b	#%11000000
     23  fd0f		       c0		      .byte.b	#%11000000
     24  fd10
     25  fd10							; 8 buffer
     26  fd10		       00		      .byte.b	#%00000000
     27  fd11		       00		      .byte.b	#%00000000
     28  fd12		       00		      .byte.b	#%00000000
     29  fd13		       00		      .byte.b	#%00000000
     30  fd14		       00		      .byte.b	#%00000000
     31  fd15		       00		      .byte.b	#%00000000
     32  fd16		       00		      .byte.b	#%00000000
     33  fd17		       00		      .byte.b	#%00000000
------- FILE main.s
------- FILE data_levels.s LEVEL 2 PASS 2
      0  fd18					      include	"data_levels.s"
      1  fd18					      align	8
      2  fd18							; first bit of byte 2 & 3 are unused for simplicity
      3  fd18
      4  fd18				   level_00
      5  fd18		       f0 1f 1f 0f	      .byte.b	%11110000, %00011111, %00011111, %00001111
      6  fd1c
      7  fd1c				   level_01
      8  fd1c		       0a 1e 00 00	      .byte.b	%1010, %0011110, %0000000, %00000000
      9  fd20		       05 1e 00 00	      .byte.b	%0101, %0011110, %0000000, %00000000
     10  fd24		       02 47 40 00	      .byte.b	%0010, %1000111, %1000000, %00000000
     11  fd28		       01 27 40 00	      .byte.b	%0001, %0100111, %1000000, %00000000
     12  fd2c		       00 57 7c 00	      .byte.b	%0000, %1010111, %1111100, %00000000
     13  fd30		       00 28 3c 00	      .byte.b	%0000, %0101000, %0111100, %00000000
     14  fd34		       00 14 3c 00	      .byte.b	%0000, %0010100, %0111100, %00000000
     15  fd38		       00 0a 3c 00	      .byte.b	%0000, %0001010, %0111100, %00000000
     16  fd3c		       00 05 3c 00	      .byte.b	%0000, %0000101, %0111100, %00000000
     17  fd40		       00 02 43 c0	      .byte.b	%0000, %0000010, %1000011, %11000000
     18  fd44		       00 01 23 c0	      .byte.b	%0000, %0000001, %0100011, %11000000
     19  fd48		       00 00 53 c0	      .byte.b	%0000, %0000000, %1010011, %11000000
     20  fd4c		       00 00 2b c0	      .byte.b	%0000, %0000000, %0101011, %11000000
     21  fd50		       00 00 14 3c	      .byte.b	%0000, %0000000, %0010100, %00111100
     22  fd54		       00 00 0a 3c	      .byte.b	%0000, %0000000, %0001010, %00111100
     23  fd58		       00 00 05 3c	      .byte.b	%0000, %0000000, %0000101, %00111100
     24  fd5c		       00 00 02 bc	      .byte.b	%0000, %0000000, %0000010, %10111100
     25  fd60		       0c 00 01 43	      .byte.b	%1100, %0000000, %0000001, %01000011
     26  fd64		       0c 00 00 a3	      .byte.b	%1100, %0000000, %0000000, %10100011
     27  fd68		       0c 00 00 53	      .byte.b	%1100, %0000000, %0000000, %01010011
     28  fd6c		       0c 00 00 2b	      .byte.b	%1100, %0000000, %0000000, %00101011
     29  fd70		       03 60 00 14	      .byte.b	%0011, %1100000, %0000000, %00010100
     30  fd74		       03 60 00 0a	      .byte.b	%0011, %1100000, %0000000, %00001010
     31  fd78		       03 60 00 05	      .byte.b	%0011, %1100000, %0000000, %00000101
     32  fd7c		       0b 60 00 02	      .byte.b	%1011, %1100000, %0000000, %00000010
     33  fd80		       04 1e 00 01	      .byte.b	%0100, %0011110, %0000000, %00000001
     34  fd84				   level_01_end
     35  fd84
     36  fd84
     37  fd84				   shard_map
     38  fd84		       40		      .byte.b	%01000000	; [1, 0, 0]
     39  fd85				   shard_map_end
------- FILE main.s
    129  fd85
    130  fffc					      org	$fffc
    131  fffc		       09 f2		      .word.w	Start
    132  fffe		       09 f2		      .word.w	Start
