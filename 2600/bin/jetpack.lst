------- FILE main.s LEVEL 1 PASS 2
      1  fffe					      processor	6502
      2  10000 ????
      3  10000 ????						; Nibble null methods
      4  10000 ????				       mac	nibble_start_kernel
      5  10000 ????				       seg.U	ignoreme	; comment out rest of code
      6  10000 ????				       endm
      7  10000 ????				       mac	nibble_if
      8  10000 ????				       endm
      9  10000 ????				       mac	nibble_write
     10  10000 ????				       endm
     11  10000 ????				       mac	nibble_write_opcode
     12  10000 ????				       endm
     13  10000 ????				       mac	nibble_else
     14  10000 ????				       endm
     15  10000 ????				       mac	nibble_end_if
     16  10000 ????				       endm
     17  10000 ????				       mac	nibble_end_kernel
     18  10000 ????				       seg	CodeBank3
     19  10000 ????				       endm
     20  10000 ????
     21  10000 ????
     22  10000 ????						; Perform a left rotation on the 32 bit number at
     23  10000 ????						; location VLA and store the result at location
     24  10000 ????						; RES. If VLA and RES are the same then the
     25  10000 ????						; operation is applied directly to the memory,
     26  10000 ????						; otherwise it is done in the accumulator.
     27  10000 ????						;
     28  10000 ????						; On exit: A = ??, X & Y are unchanged.
     29  10000 ????
     30  10000 ????						;http://www.obelisk.me.uk/6502/maclib.inc but reversed
     31  10000 ????				       mac	_ror32
     32  10000 ????			    VLA        EQU	{1}
     33  10000 ????			    RES        EQU	{2}
     34  10000 ????				       IF	VLA != RES
     35  10000 ????				       LDA	VLA+0
     36  10000 ????				       ROR	A
     37  10000 ????				       STA	RES+0
     38  10000 ????				       LDA	VLA+1
     39  10000 ????				       ROR	A
     40  10000 ????				       STA	RES+1
     41  10000 ????				       LDA	VLA+2
     42  10000 ????				       ROR	A
     43  10000 ????				       STA	RES+2
     44  10000 ????				       LDA	VLA+3
     45  10000 ????				       ROR	A
     46  10000 ????				       STA	RES+3
     47  10000 ????				       ELSE
     48  10000 ????				       ROR	VLA+0
     49  10000 ????				       ROR	VLA+1
     50  10000 ????				       ROR	VLA+2
     51  10000 ????				       ROR	VLA+3
     52  10000 ????				       ENDIF
     53  10000 ????				       ENDM
     54  10000 ????
     55  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     56  10000 ????				       mac	assert_runtime
     57  10000 ????			    .COND      SET	{1}
     58  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     59  10000 ????				       endm
     60  10000 ????
     61  10000 ????
     62  10000 ????						; Dynamic, runtime (Stella) assertions for "make debug"
     63  10000 ????				       mac	assert_runtime_kernel
     64  10000 ????			    .KERNEL    SET	{1}
     65  10000 ????			    .COND      SET	{2}
     66  10000 ????				       echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     67  10000 ????				       endm
     68  10000 ????
     69  10000 ????						; Static assertions for size
     70  10000 ????				       mac	assert_size
     71  10000 ????			    .STARTA    SET	{1}
     72  10000 ????			    .ENDA      SET	{2}
     73  10000 ????			    .LEN       SET	{3}
     74  10000 ????				       if	[[.ENDA - .STARTA] >= .LEN]
     75  10000 ????				       echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
     76  10000 ????				       err
     77  10000 ????				       endif
     78  10000 ????				       endm
     79  10000 ????				       mac	assert_size_exact
     80  10000 ????			    .STARTA    SET	{1}
     81  10000 ????			    .ENDA      SET	{2}
     82  10000 ????			    .LEN       SET	{3}
     83  10000 ????				       if	[[.ENDA - .STARTA] != .LEN]
     84  10000 ????				       echo	""
     85  10000 ????				       echo	"Error: Violated size limit", [.ENDA - .STARTA], "vs", .LEN
     86  10000 ????				       err
     87  10000 ????				       endif
     88  10000 ????				       endm
     89  10000 ????
     90  10000 ????						; Global headers
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE main.s
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????
    163  0000 ????						; EOF
------- FILE main.s
------- FILE xmacro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"xmacro.h"
      1  0000 ????
      2  0000 ????						;-------------------------------------------------------
      3  0000 ????						; Usage: TIMER_SETUP lines
      4  0000 ????						; where lines is the number of scanlines to skip (> 2).
      5  0000 ????						; The timer will be set so that it expires before this number
      6  0000 ????						; of scanlines. A WSYNC will be done first.
      7  0000 ????
      8  0000 ????				      MAC	timer_setup
      9  0000 ????			   .lines     SET	{1}
     10  0000 ????				      lda	#(((.lines)*76-14)/64)
     11  0000 ????				      sta	WSYNC
     12  0000 ????				      sta	TIM64T
     13  0000 ????				      ENDM
     14  0000 ????
     15  0000 ????						;-------------------------------------------------------
     16  0000 ????						; Use with TIMER_SETUP to wait for timer to complete.
     17  0000 ????						; You may want to do a WSYNC afterwards, since the timer
     18  0000 ????						; is not accurate to the beginning/end of a scanline.
     19  0000 ????
     20  0000 ????				      MAC	timer_wait
     21  0000 ????			   .waittimer
     22  0000 ????				      lda	INTIM
     23  0000 ????				      bne	.waittimer
     24  0000 ????				      sta	WSYNC
     25  0000 ????				      ENDM
     26  0000 ????
------- FILE main.s
     94  0000 ????
     95  0000 ????						; RAM and constants
------- FILE game_define.s LEVEL 2 PASS 2
      0  0000 ????				      include	"game_define.s"
      1 U0000 ????				      seg.u	Defines
      2 U0000 ????
      3 U0000 ????	       00 10	   ROW_COUNT  =	16
      4 U0000 ????	       00 02	   SIGNAL_LINE =	$02
      5 U0000 ????	       00 07	   FrameSkip  =	%111	; Tick (every 8 frames)
      6 U0000 ????
      7 U0000 ????						; RAM+ memory map
      8 U0000 ????
      9 U0000 ????	       f0 00	   CBSRAM_KERNEL_WRITE =	$f000
     10 U0000 ????	       f1 00	   CBSRAM_KERNEL_READ =	$f100
     11 U0000 ????	       f1 04	   CBSRAM_KERNEL_ENTRY =	[CBSRAM_KERNEL_READ + 4]
     12 U0000 ????
     13 U0000 ????	       f0 40	   RAMP_STORAGE_W =	$f040	; is this just max(frame_1_end, frame_2_end) ?
     14 U0000 ????	       f1 40	   RAMP_STORAGE_R =	$f140
     15 U0000 ????
     16 U0000 ????
     17 U0000 ????						; NUSIZ values
     18 U0000 ????
     19 U0000 ????	       00 13	   THREE_COPIES =	%00010011
     20 U0000 ????
     21 U0000 ????
     22 U0000 ????						; Colors
     23 U0000 ????
     24 U0000 ????	       00 42	   COL_BG     =	$42
     25 U0000 ????	       00 cc	   COL_EMERALD =	$CC
     26 U0000 ????	       00 cc	   COL_EMERALD_2 =	$CC
     27 U0000 ????
     28 U0000 ????
     29 U0000 ????						; HMOVE values for missiles
     30 U0000 ????
     31 U0000 ????	       00 1c	   KERNEL_A_MISSILE_SLEEP =	28
     32 U0000 ????	       00 00	   KERNEL_A_MISSILE_HMOVE =	$00
     33 U0000 ????
     34 U0000 ????	       00 33	   KERNEL_B_MISSILE_SLEEP =	51
     35 U0000 ????	       00 10	   KERNEL_B_MISSILE_HMOVE =	$10
     36 U0000 ????
     37 U0000 ????						; Missile values when 2A=RST
     38 U0000 ????						; KERNEL_B_MISSILE_SLEEP equ 46
     39 U0000 ????						; KERNEL_B_MISSILE_HMOVE equ $20
     40 U0000 ????
     41 U0000 ????
     42 U0000 ????						; Sprite details
     43 U0000 ????
     44 U0000 ????	       00 07	   EMERALD_SP_COLOR =	COLUP1
     45 U0000 ????	       00 1c	   EMERALD_SP =	GRP1
     46 U0000 ????	       00 1e	   EMERALD_MI_ENABLE =	ENAM1
     47 U0000 ????	       00 11	   EMERALD_SP_RESET =	RESP1
     48 U0000 ????	       00 13	   EMERALD_MI_RESET =	RESM1
     49 U0000 ????	       00 21	   EMERALD_SP_HMOVE =	HMP1
     50 U0000 ????	       00 23	   EMERALD_MI_HMOVE =	HMM1
     51 U0000 ????	       00 05	   EMERALD_COPIES =	NUSIZ1
     52 U0000 ????
     53 U0000 ????	       00 1b	   JET_SP     =	GRP0
     54 U0000 ????	       00 10	   JET_SP_RESET =	RESP0
     55 U0000 ????	       00 20	   JET_SP_HMOVE =	HMP0
     56 U0000 ????	       00 06	   JET_SP_COLOR =	COLUP0
     57 U0000 ????
     58 U0000 ????
     59 U0000 ????						; Game dimensionsn
     60 U0000 ????
     61 U0000 ????						; Spriteend is HEIGHT_OFFSET - YPos
     62 U0000 ????	       00 08	   SPRITE_HEIGHT =	8
     63 U0000 ????	       00 c8	   HEIGHT_OFFSET =	200
     64 U0000 ????
     65 U0000 ????						; Compared with YPos
     66 U0000 ????	       00 48	   FLOOR_OFFSET =	72
     67 U0000 ????	       00 c0	   CEILING_OFFSET =	192
     68 U0000 ????
     69 U0000 ????						; Starting player position
     70 U0000 ????	       00 48	   YPosStart  =	72
     71 U0000 ????	       00 58	   XPosStart  =	88
     72 U0000 ????
     73 U0000 ????						; Top left corner
     74 U0000 ????						; YPosStart equ 190
     75 U0000 ????						; XPosStart equ 28
------- FILE main.s
------- FILE game_vars.s LEVEL 2 PASS 2
      0 U0000 ????				      include	"game_vars.s"
      1 U00be ????				      seg.u	Variables
      2 U00be ????
      3 U0080					      org	$80
      4 U0080
      5 U0080		       00	   DebugKernelID byte.b		; which kernel are we running this frame? (for debugging)
      6 U0081
      7 U0081		       00	   Temp       byte.b
      8 U0082
      9 U0082							; Counters
     10 U0082		       00	   RowCount   byte.b
     11 U0083		       00	   LoopCount  byte.b
     12 U0084		       00	   FrameCount byte.b
     13 U0085
     14 U0085		       00	   YP1	      byte.b
     15 U0086		       00	   SpriteEnd  byte.b
     16 U0087		       00	   XPos       byte.b		; X position of player sprite
     17 U0088
     18 U0088
     19 U0088		       00	   Speed1     byte.b
     20 U0089		       00	   Speed2     byte.b
     21 U008a
     22 U008a		       00	   YPos       byte.b		; Y position of player sprite
     23 U008b		       00	   YPos2      byte.b
     24 U008c
     25 U008c		       00	   GEM_02_TARGET byte.b
     26 U008d
     27 U008d		       00	   JMP_ADDR   byte.b
     28 U008e		       00	   JMP_ADDR_2 byte.b
     29 U008f
     30 U008f		       00	   ROW_DEMO_INDEX byte.b
     31 U0090
     32 U0090		       00	   RamNibbleTemp byte.b
     33 U0091		       00	   RamNibbleVar1 byte.b
     34 U0092		       00	   RamNibbleVar2 byte.b
     35 U0093		       00	   RamZeroByte byte.b
     36 U0094		       00	   RamLowerSixByte byte.b
     37 U0095		       00	   RamFFByte  byte.b
     38 U0096		       00	   RamStackBkp byte.b
     39 U0097
     40 U0097		       00	   RamRowJetpackIndex byte.b		; sprite counter
     41 U0098
     42 U0098							; Kernel support
     43 U0098		       00	   RamPF1Value byte.b
     44 U0099		       00	   RamKernelGRP0 byte.b		; temp
     45 U009a		       00	   RamKernelPhpTarget byte.b
     46 U009b		       00	   RamKernelX byte.b
     47 U009c		       00	   RamKernelY byte.b
     48 U009d		       00	   RamKernelGemini1 byte.b
     49 U009e		       00	   RamKernelGemini1Reg byte.b
     50 U009f		       00	   RamKernelGemini2 byte.b
     51 U00a0		       00	   RamKernelGemini2Reg byte.b
     52 U00a1		       00	   RamKernelGemini3 byte.b
     53 U00a2		       00	   RamKernelGemini3Reg byte.b
     54 U00a3		       00	   RamKernelGemini4 byte.b
     55 U00a4		       00	   RamKernelGemini4Reg byte.b
     56 U00a5		       00	   RamKernelGemini5 byte.b
     57 U00a6
     58 U00a6		       00	   BuildKernelX byte.b
     59 U00a7		       00	   BuildKernelY byte.b
     60 U00a8		       00	   BuildKernelRST byte.b
     61 U00a9		       00	   BuildKernelGrp0 byte.b
     62 U00aa		       00	   BuildKernelVdel1 byte.b
     63 U00ab		       00	   BuildKernelMissile byte.b
     64 U00ac
     65 U00ac		       00	   level_for_game byte.b
     66 U00ad		       00		      byte.b
     67 U00ae		       00		      byte.b
     68 U00af		       00		      byte.b
     69 U00b0
     70 U00b0		       00	   DO_MISS_A  byte.b
     71 U00b1		       00	   DO_MISS_B  byte.b
     72 U00b2		       00	   DO_GEMS_A  byte.b
     73 U00b3		       00		      byte.b
     74 U00b4		       00		      byte.b
     75 U00b5		       00		      byte.b
     76 U00b6		       00		      byte.b
     77 U00b7		       00		      byte.b
     78 U00b8		       00	   DO_GEMS_B  byte.b
     79 U00b9		       00		      byte.b
     80 U00ba		       00		      byte.b
     81 U00bb		       00		      byte.b
     82 U00bc		       00		      byte.b
     83 U00bd		       00		      byte.b
------- FILE main.s
     98 U00be
     99 U00be							; Bank 1
    100  e000 ????				      seg	CodeBank1
    101  d000					      org	$D000
    102  d000					      rorg	$F000
    103  d000		       00	   BANK1      byte.b
    104  d200					      org	$d200
    105  d200					      rorg	$d200
    106  d200				   Bank1Start
    107  d200		       ad fa ff 	      lda	$fffa
    108  d203		       ea		      nop
    109  d204		       ea		      nop
    110  d205		       ea		      nop
    111  d206
    112  dffc					      org	$dffc
    113  dffc					      rorg	$fffc
    114  dffc		       00 d2		      .word.w	Bank1Start
    115  dffe		       00 d2		      .word.w	Bank1Start
    116  e000
    117  e000							; Bank 2
    118  f000 ????				      seg	CodeBank2
    119  e000					      org	$E000
    120  e000					      rorg	$F000
    121  e000		       00	   BANK2      byte.b
    122  e200					      org	$e200
    123  e200					      rorg	$f200
    124  e200				   Bank2Start
    125  e200		       ad fa ff 	      lda	$fffa
    126  e203		       ea		      nop
    127  e204		       ea		      nop
    128  e205		       ea		      nop
    129  e206
    130  effc					      org	$effc
    131  effc					      rorg	$fffc
    132  effc		       00 f2		      .word.w	Bank2Start
    133  effe		       00 f2		      .word.w	Bank2Start
    134  f000
    135  f000							; Bank 3
    136  10000 ????				       seg	CodeBank3
    137  f000					      org	$F000
    138  f000					      rorg	$F000
    139  f000		       00	   BANK3      byte.b
    140  f200					      org	$f200
    141  f200					      rorg	$f200
    142  f200				   Bank3Start
    143  f200		       ad fa ff 	      lda	$fffa
    144  f203		       ea		      nop
    145  f204		       ea		      nop
    146  f205		       ea		      nop
    147  f206		       4c 09 f2 	      jmp	Start
    148  f209
    149  f209							; Bank 3 source code
------- FILE game_init.s LEVEL 2 PASS 2
      0  f209					      include	"game_init.s"
      1  f209							; Game Initialization after power on or reset
      2  f209
      3  f209				   IFTRACKER  SET	1
      4  f209
      5  f209				   IFTRACKER  SET	2
      6  f209
      7  f209				   Start
      0  f209					      CLEAN_START
      1  f209		       78		      sei
      2  f20a		       d8		      cld
      3  f20b
      4  f20b		       a2 00		      ldx	#0
      5  f20d		       8a		      txa
      6  f20e		       a8		      tay
      7  f20f		       ca	   .CLEAR_STACK dex
      8  f210		       9a		      txs
      9  f211		       48		      pha
     10  f212		       d0 fb		      bne	.CLEAR_STACK
     11  f214
      9  f214
     10  f214							; Disable interrupt flag in processor status (it's useless anyway)
     11  f214		       58		      cli
     12  f215
     13  f215				   InitSetup
     14  f215		       a9 00		      lda	#0
     15  f217		       85 84		      sta	FrameCount
     16  f219
     17  f219							; P0 has three copies
     18  f219		       a9 13		      lda	#%00010011
     19  f21b		       85 05		      sta	EMERALD_COPIES
     20  f21d
     21  f21d		       a9 00		      lda	#$00
     22  f21f		       85 09		      sta	COLUBK
     23  f221		       a9 01		      lda	#%00000001
     24  f223		       85 0a		      sta	CTRLPF	; reflect playfield
     25  f225
     26  f225							; Disable VDEL
     27  f225		       a9 00		      lda	#0
     28  f227		       85 25		      sta	VDELP0
     29  f229		       85 26		      sta	VDELP1
     30  f22b
     31  f22b							; Player 0
     32  f22b		       a2 cc		      ldx	#COL_EMERALD
     33  f22d		       86 07		      stx	EMERALD_SP_COLOR
     34  f22f
     35  f22f							; Player 1
     36  f22f		       a9 0f		      lda	#$0f
     37  f231		       85 06		      sta	JET_SP_COLOR
     38  f233		       a9 00		      lda	#$00
     39  f235		       85 1b		      sta	JET_SP
     40  f237
     41  f237							; Positions
     42  f237		       a9 48		      lda	#YPosStart
     43  f239		       85 8a		      sta	YPos
     44  f23b		       a9 58		      lda	#XPosStart
     45  f23d		       85 87		      sta	XPos
     46  f23f		       a9 00		      lda	#0
     47  f241		       85 88		      sta	Speed1
     48  f243		       85 89		      sta	Speed2
     49  f245		       85 8b		      sta	YPos2
     50  f247
     51  f247		       a9 00		      lda	#0
     52  f249		       85 8f		      sta	ROW_DEMO_INDEX
     53  f24b
     54  f24b							; Store 0 into RamZeroByte
     55  f24b		       a9 00		      lda	#0
     56  f24d		       85 93		      sta	RamZeroByte
     57  f24f		       a9 3f		      lda	#%00111111
     58  f251		       85 94		      sta	RamLowerSixByte
     59  f253		       a9 ff		      lda	#$ff
     60  f255		       85 95		      sta	RamFFByte
     61  f257
     62  f257							; Setup level.
     63  f257		       20 58 fa 	      jsr	game_state_setup
     64  f25a
     65  f25a							; Start with vertical sync (to reset frame)
     66  f25a		       4c 5b f4 	      jmp	VerticalSync
------- FILE main.s
------- FILE kernel_loader.s LEVEL 2 PASS 2
      0  f25d					      include	"kernel_loader.s"
      1  f25d							; Copies the gem kernels to RAM
      2  f25d
      3  f25d							; Copy Kernel A to CBSRAM
      4  f25d				   LoadKernelA subroutine
      5  f25d		       a0 37		      ldy	#(kernel_1_end - kernel_1_start)-1
      6  f25f				   .loop
      7  f25f		       b9 00 fd 	      lda	kernel_1_start,Y
      8  f262		       99 00 10 	      sta	$1000,Y
      9  f265		       88		      dey
     10  f266		       d0 f7		      bne	.loop
     11  f268		       ad 00 fd 	      lda	kernel_1_start
     12  f26b		       8d 00 10 	      sta	$1000
     13  f26e		       60		      rts
     14  f26f
     15  f26f							; Copy Kernel B to CBSRAM
     16  f26f				   LoadKernelB subroutine
     17  f26f		       a0 37		      ldy	#(kernel_2_end - kernel_2_start)-1
     18  f271				   .loop
     19  f271		       b9 38 fd 	      lda	kernel_2_start,Y
     20  f274		       99 00 10 	      sta	$1000,Y
     21  f277		       88		      dey
     22  f278		       d0 f7		      bne	.loop
     23  f27a		       ad 38 fd 	      lda	kernel_2_start
     24  f27d		       8d 00 10 	      sta	$1000
     25  f280		       60		      rts
------- FILE main.s
------- FILE nibble.s LEVEL 2 PASS 2
      0  f281					      include	"nibble.s"
      1  f281
      2  f281					      MAC	nibble_gem_kernel_a_1_build
      3  f281					      lda	#0
      4  f281					      ldx	#SENTINEL
      5  f281					      stx	BuildKernelX
      6  f281					      stx	BuildKernelY
      7  f281					      stx	BuildKernelRST
      8  f281							; Gemini 1A
      9  f281				   .K_1A
     10  f281					      ldy	[DO_GEMS_A + 0]
     11  f281					      jsr	KernelA_GenReset
     12  f281				   .if_1
     13  f281					      bne	.else_1
     14  f281					      sec
     15  f281					      rol
     16  f281							; Special: Encoding RST0
     17  f281							; Rewrite lda RamKernelPF1 to be #immediate
     18  f281					      ldy	#BC_LDA_IMM
     19  f281					      sty	[KernelA_B - $100]
     20  f281					      ldy	#%10100000
     21  f281					      sty	[KernelA_B - $100 + 1]
     22  f281							; Store 1A in GRP0
     23  f281					      ldy	[DO_GEMS_A + 1]
     24  f281					      sty	BuildKernelGrp0
     25  f281							; Gemini 1A is RESPx
     26  f281					      ldy	#EMERALD_SP_RESET
     27  f281					      sty	[KernelA_C - $100 + 1]
     28  f281							; Turn 3-cycle NOP into 4-cycle
     29  f281					      ldy	#$14
     30  f281					      sty	[KernelA_D - $100]
     31  f281					      jmp	.endif_1
     32  f281							; [BIT DEPTH] #1 If-End @ 1
     33  f281					      rol
     34  f281
     35  f281				   .else_1
     36  f281					      clc
     37  f281					      rol
     38  f281							; Store 0A in GRP0
     39  f281					      ldy	[DO_GEMS_A + 0]
     40  f281					      sty	BuildKernelGrp0
     41  f281					      ldy	[DO_GEMS_A + 1]
     42  f281					      jsr	KernelA_GenReset
     43  f281				   .if_2
     44  f281					      bne	.else_2
     45  f281					      sec
     46  f281					      rol
     47  f281							; GEM1ASWITCH
     48  f281					      jmp	.endif_2
     49  f281							; [BIT DEPTH] #2 If-End @ 2
     50  f281
     51  f281				   .else_2
     52  f281					      clc
     53  f281					      rol
     54  f281							; Calculate the 1A value
     55  f281					      ldy	SHARD_LUT_RF1
     56  f281					      cpy	#1
     57  f281					      .byte	$D0, #3
     58  f281					      ldy	#RESP1
     59  f281					      .byte	$2C
     60  f281					      ldy	#GRP1
     61  f281					      sty	RamKernelGemini1Reg
     62  f281							; Set opcode
     63  f281					      ldx	SHARD_LUT_RF1
     64  f281					      cpx	#1
     65  f281					      ldy	#BC_STX
     66  f281					      .byte	$F0, #5
     67  f281					      ldy	[DO_GEMS_A + 1]
     68  f281					      jsr	KernelA_UpdateRegs
     69  f281					      sty	RamKernelGemini1
     70  f281							; [BIT DEPTH] #2 *If-End @ 2
     71  f281							; [BIT DEPTH] #2 Else-End @ 2
     72  f281				   .endif_2
     73  f281							; [BIT DEPTH] #1 *If-End @ 1
     74  f281							; [BIT DEPTH] #1 Else-End @ 2
     75  f281				   .endif_1
     76  f281							; BuildKernelX, BuildKernelY are upgraded if not set
     77  f281							; Gemini 2A
     78  f281					      ldy	[DO_GEMS_A + 2]
     79  f281					      jsr	KernelA_GenReset
     80  f281				   .if_3
     81  f281					      bne	.else_3
     82  f281					      sec
     83  f281					      rol
     84  f281					      jmp	.endif_3
     85  f281							; [BIT DEPTH] #3 If-End @ 3
     86  f281
     87  f281				   .else_3
     88  f281					      clc
     89  f281					      rol
     90  f281							; Set opcode
     91  f281					      ldy	[DO_GEMS_A + 2]
     92  f281					      jsr	KernelA_UpdateRegs
     93  f281					      sty	RamKernelGemini2
     94  f281							; Set opcode target
     95  f281					      ldy	SHARD_LUT_RF1
     96  f281					      cpy	#2
     97  f281					      .byte	$D0, #3
     98  f281					      ldy	#RESP1
     99  f281					      .byte	$2C
    100  f281					      ldy	#GRP1
    101  f281					      sty	RamKernelGemini2Reg
    102  f281							; [BIT DEPTH] #3 *If-End @ 3
    103  f281							; [BIT DEPTH] #3 Else-End @ 3
    104  f281				   .endif_3
    105  f281							; Gemini 3A
    106  f281					      ldy	[DO_GEMS_A + 3]
    107  f281					      jsr	KernelA_GenReset
    108  f281				   .if_4
    109  f281					      bne	.else_4
    110  f281					      sec
    111  f281					      rol
    112  f281					      jmp	.endif_4
    113  f281							; [BIT DEPTH] #4 If-End @ 4
    114  f281
    115  f281				   .else_4
    116  f281					      clc
    117  f281					      rol
    118  f281							; Set opcode
    119  f281					      ldy	[DO_GEMS_A + 3]
    120  f281					      jsr	KernelA_UpdateRegs
    121  f281					      sty	RamKernelGemini3
    122  f281							; Set opcode target
    123  f281					      ldy	SHARD_LUT_RF1
    124  f281					      cpy	#3
    125  f281					      .byte	$D0, #3
    126  f281					      ldy	#RESP1
    127  f281					      .byte	$2C
    128  f281					      ldy	#GRP1
    129  f281					      sty	RamKernelGemini3Reg
    130  f281							; [BIT DEPTH] #4 *If-End @ 4
    131  f281							; [BIT DEPTH] #4 Else-End @ 4
    132  f281				   .endif_4
    133  f281							; [BIT DEPTH] Final: 4 (out of 8 bits)
    134  f281					      rol
    135  f281					      rol
    136  f281					      rol
    137  f281					      rol
    138  f281					      ENDM
    139  f281
    140  f281					      MAC	nibble_gem_kernel_a_2_build
    141  f281					      lda	#0
    142  f281							; VD1 default
    143  f281					      ldx	[DO_GEMS_A + 1]
    144  f281					      stx	BuildKernelVdel1
    145  f281							; Gemini 4A
    146  f281					      ldx	SHARD_LUT_VD1
    147  f281					      cpx	#4
    148  f281				   .if_1
    149  f281					      beq	.else_1
    150  f281					      sec
    151  f281					      rol
    152  f281							; Set PHP
    153  f281							; Update VDEL1
    154  f281					      ldx	[DO_GEMS_A + 4]
    155  f281					      stx	BuildKernelVdel1
    156  f281					      jmp	.endif_1
    157  f281							; [BIT DEPTH] #1 If-End @ 1
    158  f281
    159  f281				   .else_1
    160  f281					      clc
    161  f281					      rol
    162  f281					      ldy	[DO_GEMS_A + 4]
    163  f281					      jsr	KernelA_UpdateRegs
    164  f281					      sty	RamKernelGemini4
    165  f281							; Set PHP
    166  f281							; [BIT DEPTH] #1 *If-End @ 1
    167  f281							; [BIT DEPTH] #1 Else-End @ 1
    168  f281				   .endif_1
    169  f281							; Misisle
    170  f281					      ldy	DO_MISS_A
    171  f281				   .if_2
    172  f281					      bne	.else_2
    173  f281					      sec
    174  f281					      rol
    175  f281					      jmp	.endif_2
    176  f281							; [BIT DEPTH] #2 If-End @ 2
    177  f281
    178  f281				   .else_2
    179  f281					      clc
    180  f281					      rol
    181  f281							; [BIT DEPTH] #2 *If-End @ 2
    182  f281							; [BIT DEPTH] #2 Else-End @ 2
    183  f281				   .endif_2
    184  f281							; VD1
    185  f281							; GRP0
    186  f281							; X
    187  f281							; Y
    188  f281							; Gemini 5A
    189  f281							; TODO eventually...?
    190  f281							; [BIT DEPTH] Final: 2 (out of 8 bits)
    191  f281					      rol
    192  f281					      rol
    193  f281					      rol
    194  f281					      rol
    195  f281					      rol
    196  f281					      rol
    197  f281					      ENDM
    198  f281
    199  f281					      MAC	nibble_gem_kernel_b_build
    200  f281					      lda	#0
    201  f281							; Php target default
    202  f281					      ldx	#RESP1
    203  f281					      stx	RamKernelPhpTarget
    204  f281					      ldx	#SENTINEL
    205  f281					      stx	BuildKernelX
    206  f281					      stx	BuildKernelY
    207  f281					      stx	BuildKernelRST
    208  f281							; Gemini 0B
    209  f281					      ldy	[DO_GEMS_B + 0]
    210  f281					      sty	BuildKernelGrp0
    211  f281							; NIBBLE_WRITE KernelB_D_W, RamKernelGemini0
    212  f281							; Gemini 1B
    213  f281					      ldy	[DO_GEMS_B + 1]
    214  f281					      jsr	KernelA_UpdateRegs
    215  f281					      sty	RamKernelGemini1
    216  f281							; Calculate Gemini 2B
    217  f281					      ldy	[DO_GEMS_B + 2]
    218  f281					      jsr	KernelB_UpdateRegs
    219  f281					      sty	RamKernelGemini2
    220  f281							; Calculate Gemini 3B
    221  f281					      ldy	[DO_GEMS_B + 3]
    222  f281					      jsr	KernelB_UpdateRegs
    223  f281					      sty	RamKernelGemini3
    224  f281							; Gemini 2B
    225  f281				   .K_2B
    226  f281					      ldy	[DO_GEMS_B + 2]
    227  f281					      jsr	KernelB_GenPhp
    228  f281				   .if_1
    229  f281					      bne	.else_1
    230  f281					      sec
    231  f281					      rol
    232  f281							; Write to PHP in 2B
    233  f281					      cpy	G11
    234  f281				   .if_2
    235  f281					      beq	.else_2
    236  f281					      sec
    237  f281					      rol
    238  f281					      jmp	.endif_2
    239  f281							; [BIT DEPTH] #2 If-End @ 2
    240  f281
    241  f281				   .else_2
    242  f281					      clc
    243  f281					      rol
    244  f281							; [BIT DEPTH] #2 *If-End @ 2
    245  f281							; [BIT DEPTH] #2 Else-End @ 2
    246  f281				   .endif_2
    247  f281					      jmp	.endif_1
    248  f281							; [BIT DEPTH] #1 If-End @ 2
    249  f281
    250  f281				   .else_1
    251  f281					      clc
    252  f281					      rol
    253  f281							; [BIT DEPTH] #1 *If-End @ 2
    254  f281							; [BIT DEPTH] #1 Else-End @ 1
    255  f281					      rol
    256  f281				   .endif_1
    257  f281							; Gemini 3B
    258  f281					      ldy	[DO_GEMS_B + 3]
    259  f281					      jsr	KernelB_GenPhp
    260  f281				   .if_3
    261  f281					      beq	.else_3
    262  f281					      sec
    263  f281					      rol
    264  f281							; Write to PHP in 3B
    265  f281							; TODO compare this in the outside by checking KernelB_GenPhp value
    266  f281					      cpy	G11
    267  f281				   .if_4
    268  f281					      bne	.else_4
    269  f281					      sec
    270  f281					      rol
    271  f281					      jmp	.endif_4
    272  f281							; [BIT DEPTH] #4 If-End @ 4
    273  f281
    274  f281				   .else_4
    275  f281					      clc
    276  f281					      rol
    277  f281							; [BIT DEPTH] #4 *If-End @ 4
    278  f281							; [BIT DEPTH] #4 Else-End @ 4
    279  f281				   .endif_4
    280  f281					      jmp	.endif_3
    281  f281							; [BIT DEPTH] #3 If-End @ 4
    282  f281
    283  f281				   .else_3
    284  f281					      clc
    285  f281					      rol
    286  f281							; FIXME this was broken, enable this!
    287  f281							; NIBBLE_WRITE KernelA_H_W, RamKernelGemini3, #EMERALD_SP
    288  f281							; [BIT DEPTH] #3 *If-End @ 4
    289  f281							; [BIT DEPTH] #3 Else-End @ 3
    290  f281					      rol
    291  f281				   .endif_3
    292  f281							; Gemini 4B
    293  f281					      ldy	[DO_GEMS_B + 4]
    294  f281					      jsr	KernelA_UpdateRegs
    295  f281				   .K_4B
    296  f281					      sty	RamKernelGemini4
    297  f281							; TODO if no PHP, rewrite previous section:
    298  f281							; NIBBLE_IF cs
    299  f281							;
    300  f281							;     NIBBLE_WRITE [KernelB_E_W + 0], #BC_PHP
    301  f281							;     NIBBLE_WRITE [KernelB_F_W + 0], #BC_STY, #EMERALD_SP
    302  f281							;     NIBBLE_WRITE [KernelB_G_W + 0], #BC_STA, #PF1
    303  f281							;     NIBBLE_WRITE [KernelB_H_W + 0], #BC_STY, #EMERALD_SP
    304  f281							; NIBBLE_END_IF
    305  f281							; Make adjustments for sprites.
    306  f281					      ror	BuildKernelGrp0
    307  f281					      ror	BuildKernelX
    308  f281					      ror	BuildKernelY
    309  f281							;
    310  f281							; NIBBLE_WRITE [KernelB_VDEL1 - $100], BuildKernelVdel1
    311  f281							; GRP0
    312  f281							; X
    313  f281							; Y
    314  f281							; [BIT DEPTH] Final: 4 (out of 8 bits)
    315  f281					      rol
    316  f281					      rol
    317  f281					      rol
    318  f281					      rol
    319  f281					      ENDM
    320  f281
    321  f281
    322  f281					      MAC	nibble_gem_kernel_a_1
    323  f281				   .if_1
    324  f281					      asl
    325  f281					      bcc	.else_1
    326  f281					      jmp	.endif_1
    327  f281				   .else_1
    328  f281				   .if_2
    329  f281					      asl
    330  f281					      bcc	.else_2
    331  f281					      ldx	#BC_STX
    332  f281					      stx	[KernelA_D_W + 0]
    333  f281					      ldx	#RESP1
    334  f281					      stx	[KernelA_D_W + 1]
    335  f281					      jmp	.endif_2
    336  f281				   .else_2
    337  f281					      ldx	RamKernelGemini1
    338  f281					      stx	[KernelA_D_W + 0]
    339  f281					      ldx	RamKernelGemini1Reg
    340  f281					      stx	[KernelA_D_W + 1]
    341  f281				   .endif_2
    342  f281				   .endif_1
    343  f281				   .if_3
    344  f281					      asl
    345  f281					      bcc	.else_3
    346  f281					      ldx	#NOP_REG
    347  f281					      stx	[KernelA_E_W + 1 + 0]
    348  f281					      ldx	#RESP1
    349  f281					      stx	[KernelA_G_W + 1 + 0]
    350  f281					      jmp	.endif_3
    351  f281				   .else_3
    352  f281					      ldx	#RESP1
    353  f281					      stx	[KernelA_E_W + 1 + 0]
    354  f281					      ldx	RamKernelGemini2
    355  f281					      stx	[KernelA_G_W + 0]
    356  f281					      ldx	RamKernelGemini2Reg
    357  f281					      stx	[KernelA_G_W + 1]
    358  f281				   .endif_3
    359  f281				   .if_4
    360  f281					      asl
    361  f281					      bcc	.else_4
    362  f281					      ldx	#RESP1
    363  f281					      stx	[KernelA_H_W + 1 + 0]
    364  f281					      jmp	.endif_4
    365  f281				   .else_4
    366  f281					      ldx	RamKernelGemini3
    367  f281					      stx	[KernelA_H_W + 0]
    368  f281					      ldx	RamKernelGemini3Reg
    369  f281					      stx	[KernelA_H_W + 1]
    370  f281				   .endif_4
    371  f281					      ENDM
    372  f281
    373  f281					      MAC	nibble_gem_kernel_a_2
    374  f281				   .if_1
    375  f281					      asl
    376  f281					      bcc	.else_1
    377  f281					      ldx	#BC_STA
    378  f281					      stx	[[KernelA_I_W + 0] + 0]
    379  f281					      ldx	#EMERALD_SP_RESET
    380  f281					      stx	[[KernelA_I_W + 0] + 1]
    381  f281					      ldx	#BC_STA
    382  f281					      stx	[[KernelA_J_W + 1] + 0]
    383  f281					      ldx	#PF1
    384  f281					      stx	[[KernelA_J_W + 1] + 1]
    385  f281					      ldx	#BC_PHP
    386  f281					      stx	[[KernelA_K_W + 1] + 0]
    387  f281					      ldx	#VDELP1
    388  f281					      stx	[RamKernelPhpTarget + 0]
    389  f281					      jmp	.endif_1
    390  f281				   .else_1
    391  f281					      ldx	#BC_PHP
    392  f281					      stx	[[KernelA_I_W + 0] + 0]
    393  f281					      ldx	#BC_STA
    394  f281					      stx	[[KernelA_J_W + 0] + 0]
    395  f281					      ldx	#PF1
    396  f281					      stx	[[KernelA_J_W + 0] + 1]
    397  f281					      ldx	RamKernelGemini4
    398  f281					      stx	[KernelA_K_W + 0]
    399  f281					      ldx	#EMERALD_SP
    400  f281					      stx	[KernelA_K_W + 1]
    401  f281					      ldx	#RESP1
    402  f281					      stx	[RamKernelPhpTarget + 0]
    403  f281				   .endif_1
    404  f281				   .if_2
    405  f281					      asl
    406  f281					      bcc	.else_2
    407  f281					      ldx	#BC_NOP
    408  f281					      stx	[[KernelA_F - $100] + 0]
    409  f281					      jmp	.endif_2
    410  f281				   .else_2
    411  f281					      ldx	BuildKernelMissile
    412  f281					      stx	[[KernelA_F - $100] + 0]
    413  f281				   .endif_2
    414  f281					      ldx	BuildKernelVdel1
    415  f281					      stx	[[KernelA_VDEL1 - $100] + 0]
    416  f281					      ldx	BuildKernelGrp0
    417  f281					      stx	[[KernelA_VDEL0 - $100] + 0]
    418  f281					      ldx	BuildKernelX
    419  f281					      stx	[RamKernelX + 0]
    420  f281					      ldx	BuildKernelY
    421  f281					      stx	[RamKernelY + 0]
    422  f281					      ENDM
    423  f281
    424  f281					      MAC	nibble_gem_kernel_b
    425  f281					      ldx	RamKernelGemini1
    426  f281					      stx	[KernelB_D_W + 0]
    427  f281				   .if_1
    428  f281					      asl
    429  f281					      bcc	.else_1
    430  f281					      ldx	#EMERALD_SP
    431  f281					      stx	[RamKernelPhpTarget + 0]
    432  f281					      ldx	#BC_STY
    433  f281					      stx	[[KernelB_E_W + 0] + 0]
    434  f281					      ldx	#EMERALD_SP_RESET
    435  f281					      stx	[[KernelB_E_W + 0] + 1]
    436  f281					      ldx	#BC_PHP
    437  f281					      stx	[[KernelB_F_W + 1] + 0]
    438  f281					      ldx	#BC_STA
    439  f281					      stx	[[KernelB_G_W + 0] + 0]
    440  f281					      ldx	#PF1
    441  f281					      stx	[[KernelB_G_W + 0] + 1]
    442  f281					      ldx	RamKernelGemini3
    443  f281					      stx	[[KernelB_H_W + 0] + 0]
    444  f281					      ldx	#EMERALD_SP
    445  f281					      stx	[[KernelB_H_W + 0] + 1]
    446  f281				   .if_2
    447  f281					      asl
    448  f281					      bcc	.else_2
    449  f281					      ldx	#$38
    450  f281					      stx	[[KernelB_P11_C - $100] + 0]
    451  f281					      ldx	#RamZeroByte
    452  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    453  f281					      jmp	.endif_2
    454  f281				   .else_2
    455  f281					      ldx	#$18
    456  f281					      stx	[[KernelB_P11_C - $100] + 0]
    457  f281					      ldx	#RamLowerSixByte
    458  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    459  f281				   .endif_2
    460  f281					      jmp	.endif_1
    461  f281				   .else_1
    462  f281					      ldx	RamKernelGemini2
    463  f281					      stx	[KernelB_F_W + 0]
    464  f281					      ldx	#EMERALD_SP
    465  f281					      stx	[KernelB_F_W + 1]
    466  f281				   .endif_1
    467  f281				   .if_3
    468  f281					      asl
    469  f281					      bcc	.else_3
    470  f281					      ldx	#EMERALD_SP
    471  f281					      stx	[RamKernelPhpTarget + 0]
    472  f281					      ldx	#BC_STY
    473  f281					      stx	[[KernelB_E_W + 0] + 0]
    474  f281					      ldx	#EMERALD_SP_RESET
    475  f281					      stx	[[KernelB_E_W + 0] + 1]
    476  f281					      ldx	RamKernelGemini2
    477  f281					      stx	[[KernelB_F_W + 1] + 0]
    478  f281					      ldx	#EMERALD_SP
    479  f281					      stx	[[KernelB_F_W + 1] + 1]
    480  f281					      ldx	#BC_STA
    481  f281					      stx	[[KernelB_G_W + 1] + 0]
    482  f281					      ldx	#PF1
    483  f281					      stx	[[KernelB_G_W + 1] + 1]
    484  f281					      ldx	#BC_PHP
    485  f281					      stx	[[KernelB_H_W + 1] + 0]
    486  f281				   .if_4
    487  f281					      asl
    488  f281					      bcc	.else_4
    489  f281					      ldx	#$38
    490  f281					      stx	[[KernelB_P11_C - $100] + 0]
    491  f281					      ldx	#RamZeroByte
    492  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    493  f281					      jmp	.endif_4
    494  f281				   .else_4
    495  f281					      ldx	#$18
    496  f281					      stx	[[KernelB_P11_C - $100] + 0]
    497  f281					      ldx	#RamLowerSixByte
    498  f281					      stx	[[KernelB_B + 1 - $100] + 0]
    499  f281				   .endif_4
    500  f281					      jmp	.endif_3
    501  f281				   .else_3
    502  f281				   .endif_3
    503  f281					      ldx	RamKernelGemini4
    504  f281					      stx	[KernelB_J_W + 0]
    505  f281					      ldx	BuildKernelGrp0
    506  f281					      stx	[[KernelB_VDEL0 - $100] + 0]
    507  f281					      ldx	BuildKernelX
    508  f281					      stx	[RamKernelX + 0]
    509  f281					      ldx	BuildKernelY
    510  f281					      stx	[RamKernelY + 0]
    511  f281					      ENDM
    512  f281
    513  f281
------- FILE main.s
------- FILE nibble_shard.s LEVEL 2 PASS 2
      0  f281					      include	"nibble_shard.s"
      1  f281							; conflict: 11011000 #%0011 #%1000
      2  f281							; conflict: 11011001 #%0011 #%1000
      3  f281							; conflict: 11011010 #%0011 #%1000
      4  f281							; conflict: 11011011 #%0011 #%1000
      5  f281							; conflict: 11100100 #%1000 #%0011
      6  f281							; conflict: 11100101 #%1000 #%0011
      7  f281							; conflict: 11100110 #%1000 #%0011
      8  f281							; conflict: 11100111 #%1000 #%0011
      9  f281							; conflict: 01111000 #%1000 #%0001
     10  f281							; conflict: 01111001 #%1000 #%0001
     11  f281							; conflict: 01111010 #%1000 #%0001
     12  f281							; conflict: 01111011 #%1000 #%0001
     13  f281							; conflict: 10110100 #%1000 #%0001
     14  f281							; conflict: 10110101 #%1000 #%0001
     15  f281							; conflict: 10110110 #%1000 #%0001
     16  f281							; conflict: 10110111 #%1000 #%0001
     17  f300		       00 00 00 00*	      align	256
     18  f300		       00	   .shard_0   .byte.b	#0
     19  f301		       00	   .shard_1   .byte.b	#0
     20  f302		       00	   .shard_2   .byte.b	#0
     21  f303		       00	   .shard_3   .byte.b	#0
     22  f304		       00	   .shard_4   .byte.b	#0
     23  f305		       00	   .shard_5   .byte.b	#0
     24  f306		       00	   .shard_6   .byte.b	#0
     25  f307		       00	   .shard_7   .byte.b	#0
     26  f308		       00	   .shard_8   .byte.b	#0
     27  f309		       00	   .shard_9   .byte.b	#0
     28  f30a		       00	   .shard_10  .byte.b	#0
     29  f30b		       00	   .shard_11  .byte.b	#0
     30  f30c		       00	   .shard_12  .byte.b	#0
     31  f30d		       00	   .shard_13  .byte.b	#0
     32  f30e		       00	   .shard_14  .byte.b	#0
     33  f30f		       00	   .shard_15  .byte.b	#0
     34  f310		       00	   .shard_16  .byte.b	#0
     35  f311		       00	   .shard_17  .byte.b	#0
     36  f312		       00	   .shard_18  .byte.b	#0
     37  f313		       00	   .shard_19  .byte.b	#0
     38  f314		       00	   .shard_20  .byte.b	#0
     39  f315		       00	   .shard_21  .byte.b	#0
     40  f316		       00	   .shard_22  .byte.b	#0
     41  f317		       00	   .shard_23  .byte.b	#0
     42  f318		       00	   .shard_24  .byte.b	#0
     43  f319		       00	   .shard_25  .byte.b	#0
     44  f31a		       00	   .shard_26  .byte.b	#0
     45  f31b		       00	   .shard_27  .byte.b	#0
     46  f31c		       00	   .shard_28  .byte.b	#0
     47  f31d		       00	   .shard_29  .byte.b	#0
     48  f31e		       00	   .shard_30  .byte.b	#0
     49  f31f		       00	   .shard_31  .byte.b	#0
     50  f320		       00	   .shard_32  .byte.b	#0
     51  f321		       00	   .shard_33  .byte.b	#0
     52  f322		       00	   .shard_34  .byte.b	#0
     53  f323		       00	   .shard_35  .byte.b	#0
     54  f324		       00	   .shard_36  .byte.b	#0
     55  f325		       00	   .shard_37  .byte.b	#0
     56  f326		       00	   .shard_38  .byte.b	#0
     57  f327		       00	   .shard_39  .byte.b	#0
     58  f328		       00	   .shard_40  .byte.b	#0
     59  f329		       00	   .shard_41  .byte.b	#0
     60  f32a		       00	   .shard_42  .byte.b	#0
     61  f32b		       00	   .shard_43  .byte.b	#0
     62  f32c		       00	   .shard_44  .byte.b	#0
     63  f32d		       00	   .shard_45  .byte.b	#0
     64  f32e		       00	   .shard_46  .byte.b	#0
     65  f32f		       00	   .shard_47  .byte.b	#0
     66  f330		       00	   .shard_48  .byte.b	#0
     67  f331		       00	   .shard_49  .byte.b	#0
     68  f332		       00	   .shard_50  .byte.b	#0
     69  f333		       00	   .shard_51  .byte.b	#0
     70  f334		       00	   .shard_52  .byte.b	#0
     71  f335		       00	   .shard_53  .byte.b	#0
     72  f336		       00	   .shard_54  .byte.b	#0
     73  f337		       00	   .shard_55  .byte.b	#0
     74  f338		       00	   .shard_56  .byte.b	#0
     75  f339		       00	   .shard_57  .byte.b	#0
     76  f33a		       00	   .shard_58  .byte.b	#0
     77  f33b		       00	   .shard_59  .byte.b	#0
     78  f33c		       00	   .shard_60  .byte.b	#0
     79  f33d		       00	   .shard_61  .byte.b	#0
     80  f33e		       00	   .shard_62  .byte.b	#0
     81  f33f		       00	   .shard_63  .byte.b	#0
     82  f340		       00	   .shard_64  .byte.b	#0
     83  f341		       00	   .shard_65  .byte.b	#0
     84  f342		       00	   .shard_66  .byte.b	#0
     85  f343		       00	   .shard_67  .byte.b	#0
     86  f344		       00	   .shard_68  .byte.b	#0
     87  f345		       00	   .shard_69  .byte.b	#0
     88  f346		       00	   .shard_70  .byte.b	#0
     89  f347		       00	   .shard_71  .byte.b	#0
     90  f348		       00	   .shard_72  .byte.b	#0
     91  f349		       00	   .shard_73  .byte.b	#0
     92  f34a		       00	   .shard_74  .byte.b	#0
     93  f34b		       00	   .shard_75  .byte.b	#0
     94  f34c		       00	   .shard_76  .byte.b	#0
     95  f34d		       00	   .shard_77  .byte.b	#0
     96  f34e		       00	   .shard_78  .byte.b	#0
     97  f34f		       00	   .shard_79  .byte.b	#0
     98  f350		       00	   .shard_80  .byte.b	#0
     99  f351		       00	   .shard_81  .byte.b	#0
    100  f352		       00	   .shard_82  .byte.b	#0
    101  f353		       00	   .shard_83  .byte.b	#0
    102  f354		       00	   .shard_84  .byte.b	#0
    103  f355		       00	   .shard_85  .byte.b	#0
    104  f356		       00	   .shard_86  .byte.b	#0
    105  f357		       00	   .shard_87  .byte.b	#0
    106  f358		       00	   .shard_88  .byte.b	#0
    107  f359		       00	   .shard_89  .byte.b	#0
    108  f35a		       00	   .shard_90  .byte.b	#0
    109  f35b		       00	   .shard_91  .byte.b	#0
    110  f35c		       00	   .shard_92  .byte.b	#0
    111  f35d		       00	   .shard_93  .byte.b	#0
    112  f35e		       00	   .shard_94  .byte.b	#0
    113  f35f		       00	   .shard_95  .byte.b	#0
    114  f360		       00	   .shard_96  .byte.b	#0
    115  f361		       00	   .shard_97  .byte.b	#0
    116  f362		       00	   .shard_98  .byte.b	#0
    117  f363		       00	   .shard_99  .byte.b	#0
    118  f364		       00	   .shard_100 .byte.b	#0
    119  f365		       00	   .shard_101 .byte.b	#0
    120  f366		       00	   .shard_102 .byte.b	#0
    121  f367		       00	   .shard_103 .byte.b	#0
    122  f368		       00	   .shard_104 .byte.b	#0
    123  f369		       00	   .shard_105 .byte.b	#0
    124  f36a		       00	   .shard_106 .byte.b	#0
    125  f36b		       00	   .shard_107 .byte.b	#0
    126  f36c		       02	   .shard_108 .byte.b	#%0010
    127  f36d		       02	   .shard_109 .byte.b	#%0010
    128  f36e		       02	   .shard_110 .byte.b	#%0010
    129  f36f		       02	   .shard_111 .byte.b	#%0010
    130  f370		       00	   .shard_112 .byte.b	#0
    131  f371		       00	   .shard_113 .byte.b	#0
    132  f372		       00	   .shard_114 .byte.b	#0
    133  f373		       00	   .shard_115 .byte.b	#0
    134  f374		       00	   .shard_116 .byte.b	#0
    135  f375		       00	   .shard_117 .byte.b	#0
    136  f376		       00	   .shard_118 .byte.b	#0
    137  f377		       00	   .shard_119 .byte.b	#0
    138  f378		       08	   .shard_120 .byte.b	#%1000
    139  f379		       08	   .shard_121 .byte.b	#%1000
    140  f37a		       08	   .shard_122 .byte.b	#%1000
    141  f37b		       08	   .shard_123 .byte.b	#%1000
    142  f37c		       00	   .shard_124 .byte.b	#0
    143  f37d		       00	   .shard_125 .byte.b	#0
    144  f37e		       00	   .shard_126 .byte.b	#0
    145  f37f		       00	   .shard_127 .byte.b	#0
    146  f380		       00	   .shard_128 .byte.b	#0
    147  f381		       00	   .shard_129 .byte.b	#0
    148  f382		       00	   .shard_130 .byte.b	#0
    149  f383		       00	   .shard_131 .byte.b	#0
    150  f384		       00	   .shard_132 .byte.b	#0
    151  f385		       00	   .shard_133 .byte.b	#0
    152  f386		       00	   .shard_134 .byte.b	#0
    153  f387		       00	   .shard_135 .byte.b	#0
    154  f388		       00	   .shard_136 .byte.b	#0
    155  f389		       00	   .shard_137 .byte.b	#0
    156  f38a		       00	   .shard_138 .byte.b	#0
    157  f38b		       00	   .shard_139 .byte.b	#0
    158  f38c		       00	   .shard_140 .byte.b	#0
    159  f38d		       00	   .shard_141 .byte.b	#0
    160  f38e		       00	   .shard_142 .byte.b	#0
    161  f38f		       00	   .shard_143 .byte.b	#0
    162  f390		       00	   .shard_144 .byte.b	#0
    163  f391		       00	   .shard_145 .byte.b	#0
    164  f392		       00	   .shard_146 .byte.b	#0
    165  f393		       00	   .shard_147 .byte.b	#0
    166  f394		       00	   .shard_148 .byte.b	#0
    167  f395		       00	   .shard_149 .byte.b	#0
    168  f396		       00	   .shard_150 .byte.b	#0
    169  f397		       00	   .shard_151 .byte.b	#0
    170  f398		       00	   .shard_152 .byte.b	#0
    171  f399		       00	   .shard_153 .byte.b	#0
    172  f39a		       00	   .shard_154 .byte.b	#0
    173  f39b		       00	   .shard_155 .byte.b	#0
    174  f39c		       02	   .shard_156 .byte.b	#%0010
    175  f39d		       02	   .shard_157 .byte.b	#%0010
    176  f39e		       02	   .shard_158 .byte.b	#%0010
    177  f39f		       02	   .shard_159 .byte.b	#%0010
    178  f3a0		       00	   .shard_160 .byte.b	#0
    179  f3a1		       00	   .shard_161 .byte.b	#0
    180  f3a2		       00	   .shard_162 .byte.b	#0
    181  f3a3		       00	   .shard_163 .byte.b	#0
    182  f3a4		       00	   .shard_164 .byte.b	#0
    183  f3a5		       00	   .shard_165 .byte.b	#0
    184  f3a6		       00	   .shard_166 .byte.b	#0
    185  f3a7		       00	   .shard_167 .byte.b	#0
    186  f3a8		       00	   .shard_168 .byte.b	#0
    187  f3a9		       00	   .shard_169 .byte.b	#0
    188  f3aa		       00	   .shard_170 .byte.b	#0
    189  f3ab		       00	   .shard_171 .byte.b	#0
    190  f3ac		       00	   .shard_172 .byte.b	#0
    191  f3ad		       00	   .shard_173 .byte.b	#0
    192  f3ae		       00	   .shard_174 .byte.b	#0
    193  f3af		       00	   .shard_175 .byte.b	#0
    194  f3b0		       00	   .shard_176 .byte.b	#0
    195  f3b1		       00	   .shard_177 .byte.b	#0
    196  f3b2		       00	   .shard_178 .byte.b	#0
    197  f3b3		       00	   .shard_179 .byte.b	#0
    198  f3b4		       08	   .shard_180 .byte.b	#%1000
    199  f3b5		       08	   .shard_181 .byte.b	#%1000
    200  f3b6		       08	   .shard_182 .byte.b	#%1000
    201  f3b7		       08	   .shard_183 .byte.b	#%1000
    202  f3b8		       00	   .shard_184 .byte.b	#0
    203  f3b9		       00	   .shard_185 .byte.b	#0
    204  f3ba		       00	   .shard_186 .byte.b	#0
    205  f3bb		       00	   .shard_187 .byte.b	#0
    206  f3bc		       00	   .shard_188 .byte.b	#0
    207  f3bd		       00	   .shard_189 .byte.b	#0
    208  f3be		       00	   .shard_190 .byte.b	#0
    209  f3bf		       00	   .shard_191 .byte.b	#0
    210  f3c0		       00	   .shard_192 .byte.b	#0
    211  f3c1		       00	   .shard_193 .byte.b	#0
    212  f3c2		       00	   .shard_194 .byte.b	#0
    213  f3c3		       00	   .shard_195 .byte.b	#0
    214  f3c4		       00	   .shard_196 .byte.b	#0
    215  f3c5		       00	   .shard_197 .byte.b	#0
    216  f3c6		       00	   .shard_198 .byte.b	#0
    217  f3c7		       00	   .shard_199 .byte.b	#0
    218  f3c8		       00	   .shard_200 .byte.b	#0
    219  f3c9		       00	   .shard_201 .byte.b	#0
    220  f3ca		       00	   .shard_202 .byte.b	#0
    221  f3cb		       00	   .shard_203 .byte.b	#0
    222  f3cc		       00	   .shard_204 .byte.b	#0
    223  f3cd		       00	   .shard_205 .byte.b	#0
    224  f3ce		       00	   .shard_206 .byte.b	#0
    225  f3cf		       00	   .shard_207 .byte.b	#0
    226  f3d0		       00	   .shard_208 .byte.b	#0
    227  f3d1		       00	   .shard_209 .byte.b	#0
    228  f3d2		       00	   .shard_210 .byte.b	#0
    229  f3d3		       00	   .shard_211 .byte.b	#0
    230  f3d4		       00	   .shard_212 .byte.b	#0
    231  f3d5		       00	   .shard_213 .byte.b	#0
    232  f3d6		       00	   .shard_214 .byte.b	#0
    233  f3d7		       00	   .shard_215 .byte.b	#0
    234  f3d8		       03	   .shard_216 .byte.b	#%0011
    235  f3d9		       03	   .shard_217 .byte.b	#%0011
    236  f3da		       03	   .shard_218 .byte.b	#%0011
    237  f3db		       03	   .shard_219 .byte.b	#%0011
    238  f3dc		       00	   .shard_220 .byte.b	#0
    239  f3dd		       00	   .shard_221 .byte.b	#0
    240  f3de		       00	   .shard_222 .byte.b	#0
    241  f3df		       00	   .shard_223 .byte.b	#0
    242  f3e0		       00	   .shard_224 .byte.b	#0
    243  f3e1		       00	   .shard_225 .byte.b	#0
    244  f3e2		       00	   .shard_226 .byte.b	#0
    245  f3e3		       00	   .shard_227 .byte.b	#0
    246  f3e4		       08	   .shard_228 .byte.b	#%1000
    247  f3e5		       08	   .shard_229 .byte.b	#%1000
    248  f3e6		       08	   .shard_230 .byte.b	#%1000
    249  f3e7		       08	   .shard_231 .byte.b	#%1000
    250  f3e8		       00	   .shard_232 .byte.b	#0
    251  f3e9		       00	   .shard_233 .byte.b	#0
    252  f3ea		       00	   .shard_234 .byte.b	#0
    253  f3eb		       00	   .shard_235 .byte.b	#0
    254  f3ec		       00	   .shard_236 .byte.b	#0
    255  f3ed		       00	   .shard_237 .byte.b	#0
    256  f3ee		       00	   .shard_238 .byte.b	#0
    257  f3ef		       00	   .shard_239 .byte.b	#0
    258  f3f0		       00	   .shard_240 .byte.b	#0
    259  f3f1		       00	   .shard_241 .byte.b	#0
    260  f3f2		       00	   .shard_242 .byte.b	#0
    261  f3f3		       00	   .shard_243 .byte.b	#0
    262  f3f4		       00	   .shard_244 .byte.b	#0
    263  f3f5		       00	   .shard_245 .byte.b	#0
    264  f3f6		       00	   .shard_246 .byte.b	#0
    265  f3f7		       00	   .shard_247 .byte.b	#0
    266  f3f8		       00	   .shard_248 .byte.b	#0
    267  f3f9		       00	   .shard_249 .byte.b	#0
    268  f3fa		       00	   .shard_250 .byte.b	#0
    269  f3fb		       00	   .shard_251 .byte.b	#0
    270  f3fc		       00	   .shard_252 .byte.b	#0
    271  f3fd		       00	   .shard_253 .byte.b	#0
    272  f3fe		       00	   .shard_254 .byte.b	#0
    273  f3ff		       00	   .shard_255 .byte.b	#0
------- FILE main.s
------- FILE game_frame.s LEVEL 2 PASS 2
      0  f400					      include	"game_frame.s"
      1  f400							; Frame loop, including calling out to other kernels.
      2  f400
      3  f400		       00 aa	   SENTINEL   =	%010101010
      4  f400
      5  f400							; Reflected for Kernel A
      6  f400		       00 00	   G00	      =	%00000000
      7  f400		       00 60	   G01	      =	%01100000
      8  f400		       00 06	   G10	      =	%00000110
      9  f400		       00 66	   G11	      =	%01100110
     10  f400
     11  f400							; Y=Gemini Sprite
     12  f400							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     13  f400							; processor flag Z is TRUE if this is RST.
     14  f400				   KernelA_GenReset subroutine
     15  f400		       c0 00		      cpy	#$00
     16  f402		       f0 01		      beq	.start
     17  f404		       60		      rts
     18  f405							; Current Gemini = $00
     19  f405				   .start
     20  f405		       a6 a8		      ldx	BuildKernelRST
     21  f407		       e0 aa		      cpx	#SENTINEL
     22  f409		       d0 04		      bne	.set_else
     23  f40b							; We have found the first (and only) RST on this line, set the marker var
     24  f40b		       a2 ff		      ldx	#$ff
     25  f40d		       86 a8		      stx	BuildKernelRST
     26  f40f				   .set_else
     27  f40f		       a2 00		      ldx	#$00
     28  f411		       60		      rts
     29  f412
     30  f412							; Y=Gemini Sprite
     31  f412							; See if the current Gemini is g00. Allocate an RST to this Gemini if so
     32  f412							; processor flag Z is TRUE if this is RST.
     33  f412				   KernelB_GenPhp subroutine
     34  f412		       c0 60		      cpy	#G01
     35  f414		       f0 05		      beq	.start
     36  f416		       c0 66		      cpy	#G11
     37  f418		       f0 01		      beq	.start
     38  f41a		       60		      rts
     39  f41b							; Current Gemini = $00
     40  f41b				   .start
     41  f41b		       a6 a8		      ldx	BuildKernelRST
     42  f41d		       e0 aa		      cpx	#SENTINEL
     43  f41f		       d0 06		      bne	.set_else
     44  f421							; We have found the first (and only) RST on this line, set the marker var
     45  f421		       a2 ff		      ldx	#$ff
     46  f423		       86 a8		      stx	BuildKernelRST
     47  f425		       a2 00		      ldx	#$00
     48  f427				   .set_else
     49  f427		       60		      rts
     50  f428
     51  f428							; Allocates build-time registers for a new Gemini sprite value.
     52  f428							; register Y = the storage opcode to write to the result
     53  f428							;
     54  f428							; BuildKernelGrp0, BuildKernelX, BuildKernelY are compared in that order.
     55  f428							; BuildKernelX, BuildKernelY are upgraded if not set.
     56  f428							; Y=Gemini Sprite
     57  f428				   KernelB_UpdateRegs
     58  f428				   KernelA_UpdateRegs subroutine
     59  f428
     60  f428							; If equal to GRP0, return nop
     61  f428							; FIXME GRP0 might not always be up to date (should update each entry?)
     62  f428							; FIXME GOTTA REVERSE THE GRAPHICS ALSO
     63  f428							; cpy BuildKernelGrp0
     64  f428							; bne .set_start
     65  f428							; ; TODO if this is stx + NOP value, then register doesn't have to change as
     66  f428							; ; often in GEM1ASWITCH
     67  f428							; ldy #BC_NOP
     68  f428							; rts
     69  f428
     70  f428		       c4 a6		      cpy	BuildKernelX
     71  f42a		       d0 03		      bne	.op_else
     72  f42c		       a0 86		      ldy	#BC_STX
     73  f42e		       60		      rts
     74  f42f				   .op_else
     75  f42f		       c4 a7		      cpy	BuildKernelY
     76  f431		       d0 03		      bne	.op_end
     77  f433		       a0 84		      ldy	#BC_STY
     78  f435		       60		      rts
     79  f436				   .op_end
     80  f436
     81  f436				   .set_start
     82  f436		       a6 a6		      ldx	BuildKernelX
     83  f438		       e0 aa		      cpx	#SENTINEL
     84  f43a		       d0 13		      bne	.set_else
     85  f43c
     86  f43c							; KA Missile opcode determination
     87  f43c				   DBG_CHECK_MISSILE_OPCODE
     88  f43c		       84 a6		      sty	BuildKernelX
     89  f43e		       66 a6		      ror	BuildKernelX	; D0
     90  f440		       66 a6		      ror	BuildKernelX	; D1
     91  f442		       a2 86		      ldx	#BC_STX
     92  f444		       b0 02		      bcs	[. + 4]
     93  f446		       a2 84		      ldx	#BC_STY
     94  f448		       86 ab		      stx	BuildKernelMissile
     95  f44a
     96  f44a		       84 a6		      sty	BuildKernelX
     97  f44c		       a0 86		      ldy	#BC_STX
     98  f44e		       60		      rts
     99  f44f				   .set_else
    100  f44f		       a6 a7		      ldx	BuildKernelY
    101  f451		       e0 aa		      cpx	#SENTINEL
    102  f453		       d0 05		      bne	.set_end
    103  f455		       84 a7		      sty	BuildKernelY
    104  f457		       a0 84		      ldy	#BC_STY
    105  f459		       60		      rts
    106  f45a				   .set_end
    107  f45a							; Failed all
      0  f45a					      ASSERT_RUNTIME	"0"
      1  f45a				   .COND      SET	"0"
 ASSERT: breakif { pc== $f45a  && !(  0  ) }
      2  f45a					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    109  f45a		       60		      rts
    110  f45b
    111  f45b							; Vertical Sync
    112  f45b				   VerticalSync subroutine
      0  f45b					      VERTICAL_SYNC
      1  f45b		       a9 0e		      lda	#%1110
      2  f45d		       85 02	   .VSLP1     sta	WSYNC
      3  f45f		       85 00		      sta	VSYNC
      4  f461		       4a		      lsr
      5  f462		       d0 f9		      bne	.VSLP1
    114  f464
    115  f464				   FrameStart subroutine
    116  f464							; FIXME we can't skip this: ASSERT_RUNTIME "_scan == #0"
    117  f464
    118  f464				   VerticalBlank subroutine
      0  f464					      TIMER_SETUP	37
      1  f464				   .lines     SET	37
      2  f464		       a9 2b		      lda	#(((.lines)*76-14)/64)
      3  f466		       85 02		      sta	WSYNC
      4  f468		       8d 96 02 	      sta	TIM64T
    120  f46b
    121  f46b							; Scanline counter
    122  f46b		       a9 10		      lda	#ROW_COUNT
    123  f46d		       85 83		      sta	LoopCount
    124  f46f
    125  f46f							; Frame counter
    126  f46f		       e6 84		      inc	FrameCount
    127  f471
    128  f471							; Skip every 8 frames for increasing demo index
    129  f471		       a5 84		      lda	FrameCount
    130  f473		       29 07		      and	#FrameSkip
    131  f475		       c9 07		      cmp	#FrameSkip
    132  f477		       d0 0d		      bne	.next_next_thing
    133  f479
    134  f479		       18		      clc
    135  f47a		       a5 8f		      lda	ROW_DEMO_INDEX
    136  f47c		       69 04		      adc	#4
    137  f47e		       c9 68		      cmp	#[level_01_end - level_01]
    138  f480		       90 02		      bcc	.next_thing_local
    139  f482		       a9 00		      lda	#0
    140  f484				   .next_thing_local
    141  f484		       85 8f		      sta	ROW_DEMO_INDEX
    142  f486				   .next_next_thing
    143  f486		       85 02		      sta	WSYNC
    144  f488
    145  f488							; Positioning
      0  f488					      SLEEP	40
      1  f488				   .CYCLES    SET	40
      2  f488
      3  f488				  -	      IF	.CYCLES < 2
      4  f488				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f488				  -	      ERR
      6  f488					      ENDIF
      7  f488
      8  f488				  -	      IF	.CYCLES & 1
      9  f488				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f488				  -	      nop	0
     11  f488				  -	      ELSE
     12  f488				  -	      bit	VSYNC
     13  f488				  -	      ENDIF
     14  f488				  -.CYCLES    SET	.CYCLES - 3
     15  f488					      ENDIF
     16  f488
     17  f488					      REPEAT	.CYCLES / 2
     18  f488		       ea		      nop
     17  f488					      REPEND
     18  f489		       ea		      nop
     17  f489					      REPEND
     18  f48a		       ea		      nop
     17  f48a					      REPEND
     18  f48b		       ea		      nop
     17  f48b					      REPEND
     18  f48c		       ea		      nop
     17  f48c					      REPEND
     18  f48d		       ea		      nop
     17  f48d					      REPEND
     18  f48e		       ea		      nop
     17  f48e					      REPEND
     18  f48f		       ea		      nop
     17  f48f					      REPEND
     18  f490		       ea		      nop
     17  f490					      REPEND
     18  f491		       ea		      nop
     17  f491					      REPEND
     18  f492		       ea		      nop
     17  f492					      REPEND
     18  f493		       ea		      nop
     17  f493					      REPEND
     18  f494		       ea		      nop
     17  f494					      REPEND
     18  f495		       ea		      nop
     17  f495					      REPEND
     18  f496		       ea		      nop
     17  f496					      REPEND
     18  f497		       ea		      nop
     17  f497					      REPEND
     18  f498		       ea		      nop
     17  f498					      REPEND
     18  f499		       ea		      nop
     17  f499					      REPEND
     18  f49a		       ea		      nop
     17  f49a					      REPEND
     18  f49b		       ea		      nop
     19  f49c					      REPEND
    147  f49c		       85 11		      sta	EMERALD_SP_RESET	; position 1st player
    148  f49e		       85 02		      sta	WSYNC
    149  f4a0
    150  f4a0							; Misc
    151  f4a0		       a9 00		      lda	#00
    152  f4a2		       85 1e		      sta	EMERALD_MI_ENABLE
    153  f4a4
    154  f4a4							; Assign dervied SpriteEnd value
    155  f4a4		       18		      clc
    156  f4a5		       a9 c8		      lda	#HEIGHT_OFFSET
    157  f4a7		       e5 8a		      sbc	YPos
    158  f4a9		       85 86		      sta	SpriteEnd
    159  f4ab
    160  f4ab							; Player 1
    161  f4ab		       a5 87		      lda	XPos
    162  f4ad		       a2 00		      ldx	#0
    163  f4af		       20 44 fa 	      jsr	SetHorizPos
    164  f4b2
    165  f4b2							; Extract 26-bit string to full Gemini profile
    166  f4b2		       20 00 f9 	      jsr	gemini_populate
    167  f4b5
    168  f4b5				   frame_setup subroutine
    169  f4b5							; Kernel A or B
    170  f4b5		       a9 01		      lda	#01
    171  f4b7		       25 84		      and	FrameCount
    172  f4b9		       d0 24		      bne	frame_setup_kernel_b
    173  f4bb
    174  f4bb				   frame_setup_kernel_a subroutine
    175  f4bb							; Load kernel into CBSRAM
    176  f4bb		       20 5d f2 	      jsr	LoadKernelA
    177  f4be
    178  f4be							; Move missile
    179  f4be		       85 02		      sta	WSYNC
      0  f4c0					      sleep	KERNEL_A_MISSILE_SLEEP
      1  f4c0				   .CYCLES    SET	KERNEL_A_MISSILE_SLEEP
      2  f4c0
      3  f4c0				  -	      IF	.CYCLES < 2
      4  f4c0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f4c0				  -	      ERR
      6  f4c0					      ENDIF
      7  f4c0
      8  f4c0				  -	      IF	.CYCLES & 1
      9  f4c0				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f4c0				  -	      nop	0
     11  f4c0				  -	      ELSE
     12  f4c0				  -	      bit	VSYNC
     13  f4c0				  -	      ENDIF
     14  f4c0				  -.CYCLES    SET	.CYCLES - 3
     15  f4c0					      ENDIF
     16  f4c0
     17  f4c0					      REPEAT	.CYCLES / 2
     18  f4c0		       ea		      nop
     17  f4c0					      REPEND
     18  f4c1		       ea		      nop
     17  f4c1					      REPEND
     18  f4c2		       ea		      nop
     17  f4c2					      REPEND
     18  f4c3		       ea		      nop
     17  f4c3					      REPEND
     18  f4c4		       ea		      nop
     17  f4c4					      REPEND
     18  f4c5		       ea		      nop
     17  f4c5					      REPEND
     18  f4c6		       ea		      nop
     17  f4c6					      REPEND
     18  f4c7		       ea		      nop
     17  f4c7					      REPEND
     18  f4c8		       ea		      nop
     17  f4c8					      REPEND
     18  f4c9		       ea		      nop
     17  f4c9					      REPEND
     18  f4ca		       ea		      nop
     17  f4ca					      REPEND
     18  f4cb		       ea		      nop
     17  f4cb					      REPEND
     18  f4cc		       ea		      nop
     17  f4cc					      REPEND
     18  f4cd		       ea		      nop
     19  f4ce					      REPEND
    181  f4ce		       85 13		      sta	EMERALD_MI_RESET
    182  f4d0		       a9 00		      lda	#KERNEL_A_MISSILE_HMOVE
    183  f4d2		       85 23		      sta	EMERALD_MI_HMOVE
    184  f4d4
    185  f4d4							; DEBUG: Set per-kernel color
    186  f4d4		       a2 cc		      ldx	#COL_EMERALD
    187  f4d6		       86 07		      stx	EMERALD_SP_COLOR
    188  f4d8
    189  f4d8							; Set reflection for Jetpack.
    190  f4d8		       a9 ff		      lda	#%11111111
    191  f4da		       85 0c		      sta	REFP1
    192  f4dc
    193  f4dc		       4c 0c f5 	      jmp	frame_setup_complete
    194  f4df
    195  f4df				   frame_setup_kernel_b subroutine
    196  f4df							; Load kernel into CBSRAM
    197  f4df		       20 6f f2 	      jsr	LoadKernelB
    198  f4e2
    199  f4e2							; Move missile
    200  f4e2		       85 02		      sta	WSYNC
      0  f4e4					      sleep	KERNEL_B_MISSILE_SLEEP
      1  f4e4				   .CYCLES    SET	KERNEL_B_MISSILE_SLEEP
      2  f4e4
      3  f4e4				  -	      IF	.CYCLES < 2
      4  f4e4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f4e4				  -	      ERR
      6  f4e4					      ENDIF
      7  f4e4
      8  f4e4					      IF	.CYCLES & 1
      9  f4e4					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f4e4		       04 00		      nop	0
     11  f4e6				  -	      ELSE
     12  f4e6				  -	      bit	VSYNC
     13  f4e6					      ENDIF
     14  f4e6				   .CYCLES    SET	.CYCLES - 3
     15  f4e6					      ENDIF
     16  f4e6
     17  f4e6					      REPEAT	.CYCLES / 2
     18  f4e6		       ea		      nop
     17  f4e6					      REPEND
     18  f4e7		       ea		      nop
     17  f4e7					      REPEND
     18  f4e8		       ea		      nop
     17  f4e8					      REPEND
     18  f4e9		       ea		      nop
     17  f4e9					      REPEND
     18  f4ea		       ea		      nop
     17  f4ea					      REPEND
     18  f4eb		       ea		      nop
     17  f4eb					      REPEND
     18  f4ec		       ea		      nop
     17  f4ec					      REPEND
     18  f4ed		       ea		      nop
     17  f4ed					      REPEND
     18  f4ee		       ea		      nop
     17  f4ee					      REPEND
     18  f4ef		       ea		      nop
     17  f4ef					      REPEND
     18  f4f0		       ea		      nop
     17  f4f0					      REPEND
     18  f4f1		       ea		      nop
     17  f4f1					      REPEND
     18  f4f2		       ea		      nop
     17  f4f2					      REPEND
     18  f4f3		       ea		      nop
     17  f4f3					      REPEND
     18  f4f4		       ea		      nop
     17  f4f4					      REPEND
     18  f4f5		       ea		      nop
     17  f4f5					      REPEND
     18  f4f6		       ea		      nop
     17  f4f6					      REPEND
     18  f4f7		       ea		      nop
     17  f4f7					      REPEND
     18  f4f8		       ea		      nop
     17  f4f8					      REPEND
     18  f4f9		       ea		      nop
     17  f4f9					      REPEND
     18  f4fa		       ea		      nop
     17  f4fa					      REPEND
     18  f4fb		       ea		      nop
     17  f4fb					      REPEND
     18  f4fc		       ea		      nop
     17  f4fc					      REPEND
     18  f4fd		       ea		      nop
     19  f4fe					      REPEND
    202  f4fe		       85 13		      sta	EMERALD_MI_RESET
    203  f500		       a9 10		      lda	#KERNEL_B_MISSILE_HMOVE
    204  f502		       85 23		      sta	EMERALD_MI_HMOVE
    205  f504
    206  f504							; DEBUG: Set per-kernel color
    207  f504		       a2 e4		      ldx	#$e4
    208  f506							; ldx #COL_EMERALD
    209  f506		       86 07		      stx	EMERALD_SP_COLOR
    210  f508
    211  f508							; Disable reflection for Jetpack.
    212  f508		       a9 ff		      lda	#%11111111
    213  f50a		       85 0c		      sta	REFP1
    214  f50c
    215  f50c				   frame_setup_complete
    216  f50c		       ad 00 f1 	      lda	$f100
    217  f50f		       85 80		      sta	DebugKernelID
    218  f511
    219  f511		       ad 84 fe 	      lda	shard_map
    220  f514		       a0 01		      ldy	#1	; gemini counter, starting at 1
    221  f516				   gemini_builder
    222  f516		       c0 01		      cpy	#1	; TODO top two bits of shard_map
    223  f518		       d0 00		      bne	.no_vd0
    224  f51a				   .no_vd0
    225  f51a
    226  f51a
    227  f51a				   nibble_precompile_gem_kernel
    228  f51a				   DBG_NIBBLE
    229  f51a		       00 a9	   BC_LDA_IMM =	$a9
    230  f51a		       00 85	   BC_STA     =	$85
    231  f51a		       00 86	   BC_STX     =	$86
    232  f51a		       00 84	   BC_STY     =	$84
    233  f51a		       00 08	   BC_PHP     =	$08
    234  f51a		       00 04	   BC_NOP     =	$04
    235  f51a
    236  f51a		       00 79	   NOP_REG    =	$79	; TODO is there a better reg to write to with NOP effects
    237  f51a
    238  f51a				   KernelA_D_W EQM	[KernelA_D - $100]
    239  f51a				   KernelA_E_W EQM	[KernelA_E - $100]
    240  f51a				   KernelA_G_W EQM	[KernelA_G - $100]
    241  f51a				   KernelA_H_W EQM	[KernelA_H - $100]
    242  f51a				   KernelA_I_W EQM	[KernelA_I - $100]
    243  f51a				   KernelA_J_W EQM	[KernelA_J - $100]
    244  f51a				   KernelA_K_W EQM	[KernelA_K - $100]
    245  f51a
    246  f51a				   KernelB_D_W EQM	[KernelB_D - $100]
    247  f51a				   KernelB_E_W EQM	[KernelB_E - $100]
    248  f51a				   KernelB_F_W EQM	[KernelB_F - $100]
    249  f51a				   KernelB_G_W EQM	[KernelB_G - $100]
    250  f51a				   KernelB_H_W EQM	[KernelB_H - $100]
    251  f51a				   KernelB_I_W EQM	[KernelB_I - $100]
    252  f51a				   KernelB_J_W EQM	[KernelB_J - $100]
    253  f51a				   KernelB_K_W EQM	[KernelB_K - $100]
    254  f51a
    255  f51a							; Nibble Kernel A
      0  f51a					      NIBBLE_START_KERNEL	gem_kernel_a_1, 40
      1 U00d6 ????				      seg.U	ignoreme
    257 U00d6 ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    258 U00d8 ????	       86 a6		      stx	BuildKernelX
    259 U00da ????	       86 a7		      stx	BuildKernelY
    260 U00dc ????	       86 a8		      stx	BuildKernelRST
    261 U00de ????
    262 U00de ????						; Gemini 1A
    263 U00de ????			   .K_1A
    264 U00de ????	       a4 b2		      ldy	[DO_GEMS_A + 0]
    265 U00e0 ????	       20 00 f4 	      jsr	KernelA_GenReset
      0 U00e3 ????				      NIBBLE_IF	eq
    267 U00e3 ????						; Special: Encoding RST0
    268 U00e3 ????						; Rewrite lda RamKernelPF1 to be #immediate
    269 U00e3 ????	       a0 a9		      ldy	#BC_LDA_IMM
    270 U00e5 ????	       8c 15 f0 	      sty	[KernelA_B - $100]
    271 U00e8 ????	       a0 a0		      ldy	#%10100000
    272 U00ea ????	       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
    273 U00ed ????						; Store 1A in GRP0
    274 U00ed ????	       a4 b3		      ldy	[DO_GEMS_A + 1]
    275 U00ef ????	       84 a9		      sty	BuildKernelGrp0
    276 U00f1 ????						; Gemini 1A is RESPx
    277 U00f1 ????	       a0 11		      ldy	#EMERALD_SP_RESET
    278 U00f3 ????	       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
    279 U00f6 ????						; Turn 3-cycle NOP into 4-cycle
    280 U00f6 ????	       a0 14		      ldy	#$14	; TODO what is this
    281 U00f8 ????	       8c 19 f0 	      sty	[KernelA_D - $100]
      0 U00fb ????				      NIBBLE_ELSE
    283 U00fb ????						; Store 0A in GRP0
    284 U00fb ????	       a4 b2		      ldy	[DO_GEMS_A + 0]
    285 U00fd ????	       84 a9		      sty	BuildKernelGrp0
    286 U00ff ????
    287 U00ff ????	       a4 b3		      ldy	[DO_GEMS_A + 1]
    288 U0101 ????	       20 00 f4 	      jsr	KernelA_GenReset
      0 U0104 ????				      NIBBLE_IF	eq
    290 U0104 ????						; GEM1ASWITCH
      0 U0104 ????				      NIBBLE_WRITE	KernelA_D_W, #BC_STX, #RESP1	; RESET
      0 U0104 ????				      NIBBLE_ELSE
    293 U0104 ????						; Calculate the 1A value
    294 U0104 ????	       ac d4 f9 	      ldy	SHARD_LUT_RF1
    295 U0107 ????	       c0 01		      cpy	#1
    296 U0109 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    297 U010b ????	       a0 11		      ldy	#RESP1
    298 U010d ????	       2c		      .byte.b	$2C	; .bit (ABS)
    299 U010e ????	       a0 1c		      ldy	#GRP1
    300 U0110 ????	       84 9e		      sty	RamKernelGemini1Reg
    301 U0112 ????
    302 U0112 ????						; Set opcode
    303 U0112 ????	       ae d4 f9 	      ldx	SHARD_LUT_RF1
    304 U0115 ????	       e0 01		      cpx	#1
    305 U0117 ????	       a0 86		      ldy	#BC_STX	; Don't allocate
    306 U0119 ????	       f0 05		      .byte.b	$F0, #5	; beq +4
    307 U011b ????	       a4 b3		      ldy	[DO_GEMS_A + 1]
    308 U011d ????	       20 28 f4 	      jsr	KernelA_UpdateRegs
    309 U0120 ????	       84 9d		      sty	RamKernelGemini1
    310 U0122 ????
      0 U0122 ????				      NIBBLE_WRITE	KernelA_D_W, RamKernelGemini1, RamKernelGemini1Reg
      0 U0122 ????				      NIBBLE_END_IF
      0 U0122 ????				      NIBBLE_END_IF
    314 U0122 ????
    315 U0122 ????						; BuildKernelX, BuildKernelY are upgraded if not set
    316 U0122 ????						; Gemini 2A
    317 U0122 ????	       a4 b4		      ldy	[DO_GEMS_A + 2]
    318 U0124 ????	       20 00 f4 	      jsr	KernelA_GenReset
      0 U0127 ????				      NIBBLE_IF	eq
      0 U0127 ????				      NIBBLE_WRITE	KernelA_E_W + 1, #NOP_REG	; NOP
      0 U0127 ????				      NIBBLE_WRITE	KernelA_G_W + 1, #RESP1	; RESET
      0 U0127 ????				      NIBBLE_ELSE
    323 U0127 ????						; Set opcode
    324 U0127 ????	       a4 b4		      ldy	[DO_GEMS_A + 2]
    325 U0129 ????	       20 28 f4 	      jsr	KernelA_UpdateRegs
    326 U012c ????	       84 9f		      sty	RamKernelGemini2
    327 U012e ????
    328 U012e ????						; Set opcode target
    329 U012e ????	       ac d4 f9 	      ldy	SHARD_LUT_RF1
    330 U0131 ????	       c0 02		      cpy	#2
    331 U0133 ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    332 U0135 ????	       a0 11		      ldy	#RESP1
    333 U0137 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    334 U0138 ????	       a0 1c		      ldy	#GRP1
    335 U013a ????	       84 a0		      sty	RamKernelGemini2Reg
    336 U013c ????
      0 U013c ????				      NIBBLE_WRITE	KernelA_E_W + 1, #RESP1
      0 U013c ????				      NIBBLE_WRITE	KernelA_G_W, RamKernelGemini2, RamKernelGemini2Reg	; STX
      0 U013c ????				      NIBBLE_END_IF
    340 U013c ????
    341 U013c ????						; Gemini 3A
    342 U013c ????	       a4 b5		      ldy	[DO_GEMS_A + 3]
    343 U013e ????	       20 00 f4 	      jsr	KernelA_GenReset
      0 U0141 ????				      NIBBLE_IF	eq
      0 U0141 ????				      NIBBLE_WRITE	KernelA_H_W + 1, #RESP1	; RESET
      0 U0141 ????				      NIBBLE_ELSE
    347 U0141 ????						; Set opcode
    348 U0141 ????	       a4 b5		      ldy	[DO_GEMS_A + 3]
    349 U0143 ????	       20 28 f4 	      jsr	KernelA_UpdateRegs
    350 U0146 ????	       84 a1		      sty	RamKernelGemini3
    351 U0148 ????
    352 U0148 ????						; Set opcode target
    353 U0148 ????	       ac d4 f9 	      ldy	SHARD_LUT_RF1
    354 U014b ????	       c0 03		      cpy	#3
    355 U014d ????	       d0 03		      .byte.b	$D0, #3	; bne +3
    356 U014f ????	       a0 11		      ldy	#RESP1
    357 U0151 ????	       2c		      .byte.b	$2C	; .bit (ABS)
    358 U0152 ????	       a0 1c		      ldy	#GRP1
    359 U0154 ????	       84 a2		      sty	RamKernelGemini3Reg
    360 U0156 ????
      0 U0156 ????				      NIBBLE_WRITE	KernelA_H_W, RamKernelGemini3, RamKernelGemini3Reg	; STY
      0 U0156 ????				      NIBBLE_END_IF
      0 U0156 ????				      NIBBLE_END_KERNEL
      1  f51a					      seg	CodeBank3
    364  f51a
      0  f51a					      NIBBLE_START_KERNEL	gem_kernel_a_2, 40
      1 U0156 ????				      seg.U	ignoreme
    366 U0156 ????						; VD1 default
    367 U0156 ????	       a6 b3		      ldx	[DO_GEMS_A + 1]
    368 U0158 ????	       86 aa		      stx	BuildKernelVdel1
    369 U015a ????
    370 U015a ????						; Gemini 4A
    371 U015a ????	       ae d5 f9 	      ldx	SHARD_LUT_VD1
    372 U015d ????	       e0 04		      cpx	#4
      0 U015f ????				      NIBBLE_IF	ne
      0 U015f ????				      NIBBLE_WRITE	[KernelA_I_W + 0], #BC_STA, #EMERALD_SP_RESET
      0 U015f ????				      NIBBLE_WRITE	[KernelA_J_W + 1], #BC_STA, #PF1
      0 U015f ????				      NIBBLE_WRITE	[KernelA_K_W + 1], #BC_PHP
    377 U015f ????
    378 U015f ????						; Set PHP
      0 U015f ????				      NIBBLE_WRITE	RamKernelPhpTarget, #VDELP1
    380 U015f ????
    381 U015f ????						; Update VDEL1
    382 U015f ????	       a6 b6		      ldx	[DO_GEMS_A + 4]
    383 U0161 ????	       86 aa		      stx	BuildKernelVdel1
      0 U0163 ????				      NIBBLE_ELSE
    385 U0163 ????	       a4 b6		      ldy	[DO_GEMS_A + 4]
    386 U0165 ????	       20 28 f4 	      jsr	KernelA_UpdateRegs
    387 U0168 ????	       84 a3		      sty	RamKernelGemini4
    388 U016a ????
      0 U016a ????				      NIBBLE_WRITE	[KernelA_I_W + 0], #BC_PHP
      0 U016a ????				      NIBBLE_WRITE	[KernelA_J_W + 0], #BC_STA, #PF1
      0 U016a ????				      NIBBLE_WRITE	KernelA_K_W, RamKernelGemini4, #EMERALD_SP
    392 U016a ????
    393 U016a ????						; Set PHP
      0 U016a ????				      NIBBLE_WRITE	RamKernelPhpTarget, #RESP1
      0 U016a ????				      NIBBLE_END_IF
    396 U016a ????
    397 U016a ????						; Misisle
    398 U016a ????	       a4 b0		      ldy	DO_MISS_A
      0 U016c ????				      NIBBLE_IF	eq	; Disabled
      0 U016c ????				      NIBBLE_WRITE	[KernelA_F - $100], #BC_NOP
      0 U016c ????				      NIBBLE_ELSE
      0 U016c ????				      NIBBLE_WRITE	[KernelA_F - $100], BuildKernelMissile
      0 U016c ????				      NIBBLE_END_IF
    404 U016c ????
    405 U016c ????						; VD1
      0 U016c ????				      NIBBLE_WRITE	[KernelA_VDEL1 - $100], BuildKernelVdel1
    407 U016c ????						; GRP0
      0 U016c ????				      NIBBLE_WRITE	[KernelA_VDEL0 - $100], BuildKernelGrp0
    409 U016c ????						; X
      0 U016c ????				      NIBBLE_WRITE	RamKernelX, BuildKernelX
    411 U016c ????						; Y
      0 U016c ????				      NIBBLE_WRITE	RamKernelY, BuildKernelY
    413 U016c ????
    414 U016c ????						; Gemini 5A
    415 U016c ????						; TODO eventually...?
      0 U016c ????				      NIBBLE_END_KERNEL
      1  f51a					      seg	CodeBank3
    417  f51a
    418  f51a							; Nibble Kernel B
      0  f51a					      NIBBLE_START_KERNEL	gem_kernel_b, 40
      1 U016c ????				      seg.U	ignoreme
    420 U016c ????						; Php target default
    421 U016c ????	       a2 11		      ldx	#RESP1
    422 U016e ????	       86 9a		      stx	RamKernelPhpTarget
    423 U0170 ????
    424 U0170 ????	       a2 aa		      ldx	#SENTINEL	; sentinel
    425 U0172 ????	       86 a6		      stx	BuildKernelX
    426 U0174 ????	       86 a7		      stx	BuildKernelY
    427 U0176 ????	       86 a8		      stx	BuildKernelRST
    428 U0178 ????
    429 U0178 ????						; Gemini 0B
    430 U0178 ????	       a4 b8		      ldy	[DO_GEMS_B + 0]
    431 U017a ????	       84 a9		      sty	BuildKernelGrp0
    432 U017c ????						; NIBBLE_WRITE KernelB_D_W, RamKernelGemini0
    433 U017c ????
    434 U017c ????						; Gemini 1B
    435 U017c ????	       a4 b9		      ldy	[DO_GEMS_B + 1]
    436 U017e ????	       20 28 f4 	      jsr	KernelA_UpdateRegs
    437 U0181 ????	       84 9d		      sty	RamKernelGemini1
      0 U0183 ????				      NIBBLE_WRITE	KernelB_D_W, RamKernelGemini1
    439 U0183 ????
    440 U0183 ????						; Calculate Gemini 2B
    441 U0183 ????	       a4 ba		      ldy	[DO_GEMS_B + 2]
    442 U0185 ????	       20 28 f4 	      jsr	KernelB_UpdateRegs
    443 U0188 ????	       84 9f		      sty	RamKernelGemini2
    444 U018a ????						; Calculate Gemini 3B
    445 U018a ????	       a4 bb		      ldy	[DO_GEMS_B + 3]
    446 U018c ????	       20 28 f4 	      jsr	KernelB_UpdateRegs
    447 U018f ????	       84 a1		      sty	RamKernelGemini3
    448 U0191 ????
    449 U0191 ????						; Gemini 2B
    450 U0191 ????			   .K_2B
    451 U0191 ????	       a4 ba		      ldy	[DO_GEMS_B + 2]
    452 U0193 ????	       20 12 f4 	      jsr	KernelB_GenPhp
      0 U0196 ????				      NIBBLE_IF	eq
    454 U0196 ????						; Write to PHP in 2B
      0 U0196 ????				      NIBBLE_WRITE	RamKernelPhpTarget, #EMERALD_SP
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_E_W + 0], #BC_STY, #EMERALD_SP_RESET	; 2B
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_F_W + 1], #BC_PHP
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_G_W + 0], #BC_STA, #PF1
      0 U0196 ????				      NIBBLE_WRITE	[KernelB_H_W + 0], RamKernelGemini3, #EMERALD_SP	; 3B
    460 U0196 ????
    461 U0196 ????	       c4 66		      cpy	G11
      0 U0198 ????				      NIBBLE_IF	ne
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$38	; sec
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamZeroByte
      0 U0198 ????				      NIBBLE_ELSE
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$18	; clc
      0 U0198 ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamLowerSixByte
      0 U0198 ????				      NIBBLE_END_IF
      0 U0198 ????				      NIBBLE_ELSE
      0 U0198 ????				      NIBBLE_WRITE	KernelB_F_W, RamKernelGemini2, #EMERALD_SP
      0 U0198 ????				      NIBBLE_END_IF
    472 U0198 ????
    473 U0198 ????						; Gemini 3B
    474 U0198 ????	       a4 bb		      ldy	[DO_GEMS_B + 3]
    475 U019a ????	       20 12 f4 	      jsr	KernelB_GenPhp
      0 U019d ????				      NIBBLE_IF	ne
    477 U019d ????						; Write to PHP in 3B
      0 U019d ????				      NIBBLE_WRITE	RamKernelPhpTarget, #EMERALD_SP
      0 U019d ????				      NIBBLE_WRITE	[KernelB_E_W + 0], #BC_STY, #EMERALD_SP_RESET
      0 U019d ????				      NIBBLE_WRITE	[KernelB_F_W + 1], RamKernelGemini2, #EMERALD_SP	; 2B
      0 U019d ????				      NIBBLE_WRITE	[KernelB_G_W + 1], #BC_STA, #PF1
      0 U019d ????				      NIBBLE_WRITE	[KernelB_H_W + 1], #BC_PHP	; 3B
    483 U019d ????
    484 U019d ????						; TODO compare this in the outside by checking KernelB_GenPhp value
    485 U019d ????	       c4 66		      cpy	G11
      0 U019f ????				      NIBBLE_IF	eq
      0 U019f ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$38	; sec
      0 U019f ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamZeroByte
      0 U019f ????				      NIBBLE_ELSE
      0 U019f ????				      NIBBLE_WRITE	[KernelB_P11_C - $100], #$18	; clc
      0 U019f ????				      NIBBLE_WRITE	[KernelB_B + 1 - $100], #RamLowerSixByte
      0 U019f ????				      NIBBLE_END_IF
      0 U019f ????				      NIBBLE_ELSE
    494 U019f ????						; FIXME this was broken, enable this!
    495 U019f ????						; NIBBLE_WRITE KernelA_H_W, RamKernelGemini3, #EMERALD_SP
      0 U019f ????				      NIBBLE_END_IF
    497 U019f ????
    498 U019f ????						; Gemini 4B
    499 U019f ????	       a4 bc		      ldy	[DO_GEMS_B + 4]
    500 U01a1 ????	       20 28 f4 	      jsr	KernelA_UpdateRegs
    501 U01a4 ????			   .K_4B
    502 U01a4 ????	       84 a3		      sty	RamKernelGemini4
      0 U01a6 ????				      NIBBLE_WRITE	KernelB_J_W, RamKernelGemini4
    504 U01a6 ????
    505 U01a6 ????						; TODO if no PHP, rewrite previous section:
    506 U01a6 ????						; NIBBLE_IF cs
    507 U01a6 ????						;     ; Write to PHP in reset command
    508 U01a6 ????						;     NIBBLE_WRITE [KernelB_E_W + 0], #BC_PHP
    509 U01a6 ????						;     NIBBLE_WRITE [KernelB_F_W + 0], #BC_STY, #EMERALD_SP ; 2B
    510 U01a6 ????						;     NIBBLE_WRITE [KernelB_G_W + 0], #BC_STA, #PF1
    511 U01a6 ????						;     NIBBLE_WRITE [KernelB_H_W + 0], #BC_STY, #EMERALD_SP ; 3B
    512 U01a6 ????						; NIBBLE_END_IF
    513 U01a6 ????
    514 U01a6 ????						; Make adjustments for sprites.
    515 U01a6 ????	       66 a9		      ror	BuildKernelGrp0
    516 U01a8 ????	       66 a6		      ror	BuildKernelX
    517 U01aa ????	       66 a7		      ror	BuildKernelY
    518 U01ac ????
    519 U01ac ????						; ; VD1
    520 U01ac ????						; NIBBLE_WRITE [KernelB_VDEL1 - $100], BuildKernelVdel1
    521 U01ac ????						; GRP0
      0 U01ac ????				      NIBBLE_WRITE	[KernelB_VDEL0 - $100], BuildKernelGrp0
    523 U01ac ????						; X
      0 U01ac ????				      NIBBLE_WRITE	RamKernelX, BuildKernelX
    525 U01ac ????						; Y
      0 U01ac ????				      NIBBLE_WRITE	RamKernelY, BuildKernelY
    527 U01ac ????
      0 U01ac ????				      NIBBLE_END_KERNEL
      1  f51a					      seg	CodeBank3
    529  f51a
    530  f51a							; TODO do this for all rows
    531  f51a				   DBG_NIBBLE_BUILD subroutine
    532  f51a		       ae 00 f1 	      ldx	$f100
    533  f51d		       e0 0a		      cpx	#$a
    534  f51f		       f0 03		      beq	[. + 5]
    535  f521		       4c 06 f6 	      jmp	.kernel_b
    536  f524				   .kernel_a
      0  f524					      NIBBLE_gem_kernel_a_1_BUILD		; TODO can this be implied
      1  f524		       a9 00		      lda	#0
      2  f526		       a2 aa		      ldx	#SENTINEL
      3  f528		       86 a6		      stx	BuildKernelX
      4  f52a		       86 a7		      stx	BuildKernelY
      5  f52c		       86 a8		      stx	BuildKernelRST
      6  f52e
      7  f52e				   .K_1A
      8  f52e		       a4 b2		      ldy	[DO_GEMS_A + 0]
      9  f530		       20 00 f4 	      jsr	KernelA_GenReset
     10  f533				   .if_1
     11  f533		       d0 1e		      bne	.else_1
     12  f535		       38		      sec
     13  f536		       2a		      rol
     14  f537
     15  f537
     16  f537		       a0 a9		      ldy	#BC_LDA_IMM
     17  f539		       8c 15 f0 	      sty	[KernelA_B - $100]
     18  f53c		       a0 a0		      ldy	#%10100000
     19  f53e		       8c 16 f0 	      sty	[KernelA_B - $100 + 1]
     20  f541
     21  f541		       a4 b3		      ldy	[DO_GEMS_A + 1]
     22  f543		       84 a9		      sty	BuildKernelGrp0
     23  f545
     24  f545		       a0 11		      ldy	#EMERALD_SP_RESET
     25  f547		       8c 18 f0 	      sty	[KernelA_C - $100 + 1]
     26  f54a
     27  f54a		       a0 14		      ldy	#$14
     28  f54c		       8c 19 f0 	      sty	[KernelA_D - $100]
     29  f54f		       4c 85 f5 	      jmp	.endif_1
     30  f552
     31  f552		       2a		      rol
     32  f553
     33  f553				   .else_1
     34  f553		       18		      clc
     35  f554		       2a		      rol
     36  f555
     37  f555		       a4 b2		      ldy	[DO_GEMS_A + 0]
     38  f557		       84 a9		      sty	BuildKernelGrp0
     39  f559		       a4 b3		      ldy	[DO_GEMS_A + 1]
     40  f55b		       20 00 f4 	      jsr	KernelA_GenReset
     41  f55e				   .if_2
     42  f55e		       d0 05		      bne	.else_2
     43  f560		       38		      sec
     44  f561		       2a		      rol
     45  f562
     46  f562		       4c 85 f5 	      jmp	.endif_2
     47  f565
     48  f565
     49  f565				   .else_2
     50  f565		       18		      clc
     51  f566		       2a		      rol
     52  f567
     53  f567		       ac d4 f9 	      ldy	SHARD_LUT_RF1
     54  f56a		       c0 01		      cpy	#1
     55  f56c		       d0 03		      .byte.b	$D0, #3
     56  f56e		       a0 11		      ldy	#RESP1
     57  f570		       2c		      .byte.b	$2C
     58  f571		       a0 1c		      ldy	#GRP1
     59  f573		       84 9e		      sty	RamKernelGemini1Reg
     60  f575
     61  f575		       ae d4 f9 	      ldx	SHARD_LUT_RF1
     62  f578		       e0 01		      cpx	#1
     63  f57a		       a0 86		      ldy	#BC_STX
     64  f57c		       f0 05		      .byte.b	$F0, #5
     65  f57e		       a4 b3		      ldy	[DO_GEMS_A + 1]
     66  f580		       20 28 f4 	      jsr	KernelA_UpdateRegs
     67  f583		       84 9d		      sty	RamKernelGemini1
     68  f585
     69  f585
     70  f585				   .endif_2
     71  f585
     72  f585
     73  f585				   .endif_1
     74  f585
     75  f585
     76  f585		       a4 b4		      ldy	[DO_GEMS_A + 2]
     77  f587		       20 00 f4 	      jsr	KernelA_GenReset
     78  f58a				   .if_3
     79  f58a		       d0 05		      bne	.else_3
     80  f58c		       38		      sec
     81  f58d		       2a		      rol
     82  f58e		       4c a8 f5 	      jmp	.endif_3
     83  f591
     84  f591
     85  f591				   .else_3
     86  f591		       18		      clc
     87  f592		       2a		      rol
     88  f593
     89  f593		       a4 b4		      ldy	[DO_GEMS_A + 2]
     90  f595		       20 28 f4 	      jsr	KernelA_UpdateRegs
     91  f598		       84 9f		      sty	RamKernelGemini2
     92  f59a
     93  f59a		       ac d4 f9 	      ldy	SHARD_LUT_RF1
     94  f59d		       c0 02		      cpy	#2
     95  f59f		       d0 03		      .byte.b	$D0, #3
     96  f5a1		       a0 11		      ldy	#RESP1
     97  f5a3		       2c		      .byte.b	$2C
     98  f5a4		       a0 1c		      ldy	#GRP1
     99  f5a6		       84 a0		      sty	RamKernelGemini2Reg
    100  f5a8
    101  f5a8
    102  f5a8				   .endif_3
    103  f5a8
    104  f5a8		       a4 b5		      ldy	[DO_GEMS_A + 3]
    105  f5aa		       20 00 f4 	      jsr	KernelA_GenReset
    106  f5ad				   .if_4
    107  f5ad		       d0 05		      bne	.else_4
    108  f5af		       38		      sec
    109  f5b0		       2a		      rol
    110  f5b1		       4c cb f5 	      jmp	.endif_4
    111  f5b4
    112  f5b4
    113  f5b4				   .else_4
    114  f5b4		       18		      clc
    115  f5b5		       2a		      rol
    116  f5b6
    117  f5b6		       a4 b5		      ldy	[DO_GEMS_A + 3]
    118  f5b8		       20 28 f4 	      jsr	KernelA_UpdateRegs
    119  f5bb		       84 a1		      sty	RamKernelGemini3
    120  f5bd
    121  f5bd		       ac d4 f9 	      ldy	SHARD_LUT_RF1
    122  f5c0		       c0 03		      cpy	#3
    123  f5c2		       d0 03		      .byte.b	$D0, #3
    124  f5c4		       a0 11		      ldy	#RESP1
    125  f5c6		       2c		      .byte.b	$2C
    126  f5c7		       a0 1c		      ldy	#GRP1
    127  f5c9		       84 a2		      sty	RamKernelGemini3Reg
    128  f5cb
    129  f5cb
    130  f5cb				   .endif_4
    131  f5cb
    132  f5cb		       2a		      rol
    133  f5cc		       2a		      rol
    134  f5cd		       2a		      rol
    135  f5ce		       2a		      rol
    538  f5cf		       85 91		      sta	RamNibbleVar1
      0  f5d1					      NIBBLE_gem_kernel_a_2_BUILD		; TODO can this be implied
      1  f5d1		       a9 00		      lda	#0
      2  f5d3
      3  f5d3		       a6 b3		      ldx	[DO_GEMS_A + 1]
      4  f5d5		       86 aa		      stx	BuildKernelVdel1
      5  f5d7
      6  f5d7		       ae d5 f9 	      ldx	SHARD_LUT_VD1
      7  f5da		       e0 04		      cpx	#4
      8  f5dc				   .if_1
      9  f5dc		       f0 09		      beq	.else_1
     10  f5de		       38		      sec
     11  f5df		       2a		      rol
     12  f5e0
     13  f5e0
     14  f5e0		       a6 b6		      ldx	[DO_GEMS_A + 4]
     15  f5e2		       86 aa		      stx	BuildKernelVdel1
     16  f5e4		       4c f0 f5 	      jmp	.endif_1
     17  f5e7
     18  f5e7
     19  f5e7				   .else_1
     20  f5e7		       18		      clc
     21  f5e8		       2a		      rol
     22  f5e9		       a4 b6		      ldy	[DO_GEMS_A + 4]
     23  f5eb		       20 28 f4 	      jsr	KernelA_UpdateRegs
     24  f5ee		       84 a3		      sty	RamKernelGemini4
     25  f5f0
     26  f5f0
     27  f5f0
     28  f5f0				   .endif_1
     29  f5f0
     30  f5f0		       a4 b0		      ldy	DO_MISS_A
     31  f5f2				   .if_2
     32  f5f2		       d0 05		      bne	.else_2
     33  f5f4		       38		      sec
     34  f5f5		       2a		      rol
     35  f5f6		       4c fb f5 	      jmp	.endif_2
     36  f5f9
     37  f5f9
     38  f5f9				   .else_2
     39  f5f9		       18		      clc
     40  f5fa		       2a		      rol
     41  f5fb
     42  f5fb
     43  f5fb				   .endif_2
     44  f5fb
     45  f5fb
     46  f5fb
     47  f5fb
     48  f5fb
     49  f5fb
     50  f5fb
     51  f5fb		       2a		      rol
     52  f5fc		       2a		      rol
     53  f5fd		       2a		      rol
     54  f5fe		       2a		      rol
     55  f5ff		       2a		      rol
     56  f600		       2a		      rol
    540  f601		       85 92		      sta	RamNibbleVar2
    541  f603		       4c 74 f6 	      jmp	.next
    542  f606				   .kernel_b
      0  f606					      NIBBLE_gem_kernel_b_BUILD		; TODO can this be implied
      1  f606		       a9 00		      lda	#0
      2  f608
      3  f608		       a2 11		      ldx	#RESP1
      4  f60a		       86 9a		      stx	RamKernelPhpTarget
      5  f60c		       a2 aa		      ldx	#SENTINEL
      6  f60e		       86 a6		      stx	BuildKernelX
      7  f610		       86 a7		      stx	BuildKernelY
      8  f612		       86 a8		      stx	BuildKernelRST
      9  f614
     10  f614		       a4 b8		      ldy	[DO_GEMS_B + 0]
     11  f616		       84 a9		      sty	BuildKernelGrp0
     12  f618
     13  f618
     14  f618		       a4 b9		      ldy	[DO_GEMS_B + 1]
     15  f61a		       20 28 f4 	      jsr	KernelA_UpdateRegs
     16  f61d		       84 9d		      sty	RamKernelGemini1
     17  f61f
     18  f61f		       a4 ba		      ldy	[DO_GEMS_B + 2]
     19  f621		       20 28 f4 	      jsr	KernelB_UpdateRegs
     20  f624		       84 9f		      sty	RamKernelGemini2
     21  f626
     22  f626		       a4 bb		      ldy	[DO_GEMS_B + 3]
     23  f628		       20 28 f4 	      jsr	KernelB_UpdateRegs
     24  f62b		       84 a1		      sty	RamKernelGemini3
     25  f62d
     26  f62d				   .K_2B
     27  f62d		       a4 ba		      ldy	[DO_GEMS_B + 2]
     28  f62f		       20 12 f4 	      jsr	KernelB_GenPhp
     29  f632				   .if_1
     30  f632		       d0 10		      bne	.else_1
     31  f634		       38		      sec
     32  f635		       2a		      rol
     33  f636
     34  f636		       c4 66		      cpy	G11
     35  f638				   .if_2
     36  f638		       f0 05		      beq	.else_2
     37  f63a		       38		      sec
     38  f63b		       2a		      rol
     39  f63c		       4c 41 f6 	      jmp	.endif_2
     40  f63f
     41  f63f
     42  f63f				   .else_2
     43  f63f		       18		      clc
     44  f640		       2a		      rol
     45  f641
     46  f641
     47  f641				   .endif_2
     48  f641		       4c 47 f6 	      jmp	.endif_1
     49  f644
     50  f644
     51  f644				   .else_1
     52  f644		       18		      clc
     53  f645		       2a		      rol
     54  f646
     55  f646
     56  f646		       2a		      rol
     57  f647				   .endif_1
     58  f647
     59  f647		       a4 bb		      ldy	[DO_GEMS_B + 3]
     60  f649		       20 12 f4 	      jsr	KernelB_GenPhp
     61  f64c				   .if_3
     62  f64c		       f0 10		      beq	.else_3
     63  f64e		       38		      sec
     64  f64f		       2a		      rol
     65  f650
     66  f650
     67  f650		       c4 66		      cpy	G11
     68  f652				   .if_4
     69  f652		       d0 05		      bne	.else_4
     70  f654		       38		      sec
     71  f655		       2a		      rol
     72  f656		       4c 5b f6 	      jmp	.endif_4
     73  f659
     74  f659
     75  f659				   .else_4
     76  f659		       18		      clc
     77  f65a		       2a		      rol
     78  f65b
     79  f65b
     80  f65b				   .endif_4
     81  f65b		       4c 61 f6 	      jmp	.endif_3
     82  f65e
     83  f65e
     84  f65e				   .else_3
     85  f65e		       18		      clc
     86  f65f		       2a		      rol
     87  f660
     88  f660
     89  f660
     90  f660
     91  f660		       2a		      rol
     92  f661				   .endif_3
     93  f661
     94  f661		       a4 bc		      ldy	[DO_GEMS_B + 4]
     95  f663		       20 28 f4 	      jsr	KernelA_UpdateRegs
     96  f666				   .K_4B
     97  f666		       84 a3		      sty	RamKernelGemini4
     98  f668
     99  f668
    100  f668
    101  f668
    102  f668
    103  f668
    104  f668
    105  f668
    106  f668
    107  f668		       66 a9		      ror	BuildKernelGrp0
    108  f66a		       66 a6		      ror	BuildKernelX
    109  f66c		       66 a7		      ror	BuildKernelY
    110  f66e
    111  f66e
    112  f66e
    113  f66e
    114  f66e
    115  f66e
    116  f66e		       2a		      rol
    117  f66f		       2a		      rol
    118  f670		       2a		      rol
    119  f671		       2a		      rol
    544  f672		       85 91		      sta	RamNibbleVar1
    545  f674				   .next
    546  f674
    547  f674							; TODO move this into the row kernel
    548  f674				   DBG_NIBBLE_RUN subroutine
    549  f674		       ae 00 f1 	      ldx	$f100
    550  f677		       e0 0a		      cpx	#$a
    551  f679		       f0 03		      beq	[. + 5]
    552  f67b		       4c 3b f7 	      jmp	.kernel_b
    553  f67e				   .kernel_a
    554  f67e		       a5 91		      lda	RamNibbleVar1
      0  f680					      NIBBLE_gem_kernel_a_1
      1  f680				   .if_1
      2  f680		       0a		      asl
      3  f681		       90 03		      bcc	.else_1
      4  f683		       4c a0 f6 	      jmp	.endif_1
      5  f686				   .else_1
      6  f686				   .if_2
      7  f686		       0a		      asl
      8  f687		       90 0d		      bcc	.else_2
      9  f689		       a2 86		      ldx	#BC_STX
     10  f68b		       8e 19 f0 	      stx	[KernelA_D_W + 0]
     11  f68e		       a2 11		      ldx	#RESP1
     12  f690		       8e 1a f0 	      stx	[KernelA_D_W + 1]
     13  f693		       4c a0 f6 	      jmp	.endif_2
     14  f696				   .else_2
     15  f696		       a6 9d		      ldx	RamKernelGemini1
     16  f698		       8e 19 f0 	      stx	[KernelA_D_W + 0]
     17  f69b		       a6 9e		      ldx	RamKernelGemini1Reg
     18  f69d		       8e 1a f0 	      stx	[KernelA_D_W + 1]
     19  f6a0				   .endif_2
     20  f6a0				   .endif_1
     21  f6a0				   .if_3
     22  f6a0		       0a		      asl
     23  f6a1		       90 0d		      bcc	.else_3
     24  f6a3		       a2 79		      ldx	#NOP_REG
     25  f6a5		       8e 1c f0 	      stx	[KernelA_E_W + 1 + 0]
     26  f6a8		       a2 11		      ldx	#RESP1
     27  f6aa		       8e 20 f0 	      stx	[KernelA_G_W + 1 + 0]
     28  f6ad		       4c bf f6 	      jmp	.endif_3
     29  f6b0				   .else_3
     30  f6b0		       a2 11		      ldx	#RESP1
     31  f6b2		       8e 1c f0 	      stx	[KernelA_E_W + 1 + 0]
     32  f6b5		       a6 9f		      ldx	RamKernelGemini2
     33  f6b7		       8e 1f f0 	      stx	[KernelA_G_W + 0]
     34  f6ba		       a6 a0		      ldx	RamKernelGemini2Reg
     35  f6bc		       8e 20 f0 	      stx	[KernelA_G_W + 1]
     36  f6bf				   .endif_3
     37  f6bf				   .if_4
     38  f6bf		       0a		      asl
     39  f6c0		       90 08		      bcc	.else_4
     40  f6c2		       a2 11		      ldx	#RESP1
     41  f6c4		       8e 22 f0 	      stx	[KernelA_H_W + 1 + 0]
     42  f6c7		       4c d4 f6 	      jmp	.endif_4
     43  f6ca				   .else_4
     44  f6ca		       a6 a1		      ldx	RamKernelGemini3
     45  f6cc		       8e 21 f0 	      stx	[KernelA_H_W + 0]
     46  f6cf		       a6 a2		      ldx	RamKernelGemini3Reg
     47  f6d1		       8e 22 f0 	      stx	[KernelA_H_W + 1]
     48  f6d4				   .endif_4
    556  f6d4		       a5 92		      lda	RamNibbleVar2
      0  f6d6					      NIBBLE_gem_kernel_a_2
      1  f6d6				   .if_1
      2  f6d6		       0a		      asl
      3  f6d7		       90 20		      bcc	.else_1
      4  f6d9		       a2 85		      ldx	#BC_STA
      5  f6db		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
      6  f6de		       a2 11		      ldx	#EMERALD_SP_RESET
      7  f6e0		       8e 24 f0 	      stx	[[KernelA_I_W + 0] + 1]
      8  f6e3		       a2 85		      ldx	#BC_STA
      9  f6e5		       8e 25 f0 	      stx	[[KernelA_J_W + 1] + 0]
     10  f6e8		       a2 0e		      ldx	#PF1
     11  f6ea		       8e 26 f0 	      stx	[[KernelA_J_W + 1] + 1]
     12  f6ed		       a2 08		      ldx	#BC_PHP
     13  f6ef		       8e 27 f0 	      stx	[[KernelA_K_W + 1] + 0]
     14  f6f2		       a2 26		      ldx	#VDELP1
     15  f6f4		       86 9a		      stx	[RamKernelPhpTarget + 0]
     16  f6f6		       4c 16 f7 	      jmp	.endif_1
     17  f6f9				   .else_1
     18  f6f9		       a2 08		      ldx	#BC_PHP
     19  f6fb		       8e 23 f0 	      stx	[[KernelA_I_W + 0] + 0]
     20  f6fe		       a2 85		      ldx	#BC_STA
     21  f700		       8e 24 f0 	      stx	[[KernelA_J_W + 0] + 0]
     22  f703		       a2 0e		      ldx	#PF1
     23  f705		       8e 25 f0 	      stx	[[KernelA_J_W + 0] + 1]
     24  f708		       a6 a3		      ldx	RamKernelGemini4
     25  f70a		       8e 26 f0 	      stx	[KernelA_K_W + 0]
     26  f70d		       a2 1c		      ldx	#EMERALD_SP
     27  f70f		       8e 27 f0 	      stx	[KernelA_K_W + 1]
     28  f712		       a2 11		      ldx	#RESP1
     29  f714		       86 9a		      stx	[RamKernelPhpTarget + 0]
     30  f716				   .endif_1
     31  f716				   .if_2
     32  f716		       0a		      asl
     33  f717		       90 08		      bcc	.else_2
     34  f719		       a2 04		      ldx	#BC_NOP
     35  f71b		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     36  f71e		       4c 26 f7 	      jmp	.endif_2
     37  f721				   .else_2
     38  f721		       a6 ab		      ldx	BuildKernelMissile
     39  f723		       8e 1d f0 	      stx	[[KernelA_F - $100] + 0]
     40  f726				   .endif_2
     41  f726		       a6 aa		      ldx	BuildKernelVdel1
     42  f728		       8e 2f f0 	      stx	[[KernelA_VDEL1 - $100] + 0]
     43  f72b		       a6 a9		      ldx	BuildKernelGrp0
     44  f72d		       8e 07 f0 	      stx	[[KernelA_VDEL0 - $100] + 0]
     45  f730		       a6 a6		      ldx	BuildKernelX
     46  f732		       86 9b		      stx	[RamKernelX + 0]
     47  f734		       a6 a7		      ldx	BuildKernelY
     48  f736		       86 9c		      stx	[RamKernelY + 0]
    558  f738		       4c ec f7 	      jmp	.next
    559  f73b				   .kernel_b
    560  f73b		       a5 91		      lda	RamNibbleVar1
      0  f73d					      NIBBLE_gem_kernel_b
      1  f73d		       a6 9d		      ldx	RamKernelGemini1
      2  f73f		       8e 1b f0 	      stx	[KernelB_D_W + 0]
      3  f742				   .if_1
      4  f742		       0a		      asl
      5  f743		       90 44		      bcc	.else_1
      6  f745		       a2 1c		      ldx	#EMERALD_SP
      7  f747		       86 9a		      stx	[RamKernelPhpTarget + 0]
      8  f749		       a2 84		      ldx	#BC_STY
      9  f74b		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     10  f74e		       a2 11		      ldx	#EMERALD_SP_RESET
     11  f750		       8e 1e f0 	      stx	[[KernelB_E_W + 0] + 1]
     12  f753		       a2 08		      ldx	#BC_PHP
     13  f755		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     14  f758		       a2 85		      ldx	#BC_STA
     15  f75a		       8e 20 f0 	      stx	[[KernelB_G_W + 0] + 0]
     16  f75d		       a2 0e		      ldx	#PF1
     17  f75f		       8e 21 f0 	      stx	[[KernelB_G_W + 0] + 1]
     18  f762		       a6 a1		      ldx	RamKernelGemini3
     19  f764		       8e 22 f0 	      stx	[[KernelB_H_W + 0] + 0]
     20  f767		       a2 1c		      ldx	#EMERALD_SP
     21  f769		       8e 23 f0 	      stx	[[KernelB_H_W + 0] + 1]
     22  f76c				   .if_2
     23  f76c		       0a		      asl
     24  f76d		       90 0d		      bcc	.else_2
     25  f76f		       a2 38		      ldx	#$38
     26  f771		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     27  f774		       a2 93		      ldx	#RamZeroByte
     28  f776		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     29  f779		       4c 86 f7 	      jmp	.endif_2
     30  f77c				   .else_2
     31  f77c		       a2 18		      ldx	#$18
     32  f77e		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     33  f781		       a2 94		      ldx	#RamLowerSixByte
     34  f783		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     35  f786				   .endif_2
     36  f786		       4c 93 f7 	      jmp	.endif_1
     37  f789				   .else_1
     38  f789		       a6 9f		      ldx	RamKernelGemini2
     39  f78b		       8e 1e f0 	      stx	[KernelB_F_W + 0]
     40  f78e		       a2 1c		      ldx	#EMERALD_SP
     41  f790		       8e 1f f0 	      stx	[KernelB_F_W + 1]
     42  f793				   .endif_1
     43  f793				   .if_3
     44  f793		       0a		      asl
     45  f794		       90 44		      bcc	.else_3
     46  f796		       a2 1c		      ldx	#EMERALD_SP
     47  f798		       86 9a		      stx	[RamKernelPhpTarget + 0]
     48  f79a		       a2 84		      ldx	#BC_STY
     49  f79c		       8e 1d f0 	      stx	[[KernelB_E_W + 0] + 0]
     50  f79f		       a2 11		      ldx	#EMERALD_SP_RESET
     51  f7a1		       8e 1e f0 	      stx	[[KernelB_E_W + 0] + 1]
     52  f7a4		       a6 9f		      ldx	RamKernelGemini2
     53  f7a6		       8e 1f f0 	      stx	[[KernelB_F_W + 1] + 0]
     54  f7a9		       a2 1c		      ldx	#EMERALD_SP
     55  f7ab		       8e 20 f0 	      stx	[[KernelB_F_W + 1] + 1]
     56  f7ae		       a2 85		      ldx	#BC_STA
     57  f7b0		       8e 21 f0 	      stx	[[KernelB_G_W + 1] + 0]
     58  f7b3		       a2 0e		      ldx	#PF1
     59  f7b5		       8e 22 f0 	      stx	[[KernelB_G_W + 1] + 1]
     60  f7b8		       a2 08		      ldx	#BC_PHP
     61  f7ba		       8e 23 f0 	      stx	[[KernelB_H_W + 1] + 0]
     62  f7bd				   .if_4
     63  f7bd		       0a		      asl
     64  f7be		       90 0d		      bcc	.else_4
     65  f7c0		       a2 38		      ldx	#$38
     66  f7c2		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     67  f7c5		       a2 93		      ldx	#RamZeroByte
     68  f7c7		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     69  f7ca		       4c d7 f7 	      jmp	.endif_4
     70  f7cd				   .else_4
     71  f7cd		       a2 18		      ldx	#$18
     72  f7cf		       8e 0f f0 	      stx	[[KernelB_P11_C - $100] + 0]
     73  f7d2		       a2 94		      ldx	#RamLowerSixByte
     74  f7d4		       8e 18 f0 	      stx	[[KernelB_B + 1 - $100] + 0]
     75  f7d7				   .endif_4
     76  f7d7		       4c da f7 	      jmp	.endif_3
     77  f7da				   .else_3
     78  f7da				   .endif_3
     79  f7da		       a6 a3		      ldx	RamKernelGemini4
     80  f7dc		       8e 26 f0 	      stx	[KernelB_J_W + 0]
     81  f7df		       a6 a9		      ldx	BuildKernelGrp0
     82  f7e1		       8e 07 f0 	      stx	[[KernelB_VDEL0 - $100] + 0]
     83  f7e4		       a6 a6		      ldx	BuildKernelX
     84  f7e6		       86 9b		      stx	[RamKernelX + 0]
     85  f7e8		       a6 a7		      ldx	BuildKernelY
     86  f7ea		       86 9c		      stx	[RamKernelY + 0]
    562  f7ec				   .next
    563  f7ec
    564  f7ec				   VerticalBlankEnd
    565  f7ec							; Wait until the end of Vertical blank.
      0  f7ec					      TIMER_WAIT
      1  f7ec				   .waittimer
      2  f7ec		       ad 84 02 	      lda	INTIM
      3  f7ef		       d0 fb		      bne	.waittimer
      4  f7f1		       85 02		      sta	WSYNC
      0  f7f3					      ASSERT_RUNTIME	"_scan == #37"
      1  f7f3				   .COND      SET	"_scan == #37"
 ASSERT: breakif { pc== $f7f3  && !(  _scan == #37  ) }
      2  f7f3					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    568  f7f3
    569  f7f3							; Save stack pointer
    570  f7f3		       ba		      tsx
    571  f7f4		       86 96		      stx	RamStackBkp
    572  f7f6
    573  f7f6							; Start rendering the kernel.
    574  f7f6		       4c 84 fa 	      jmp	KernelBorder
    575  f7f9
    576  f800		       00 00 00 00*	      align	256	; TODO why
    577  f800
    578  f800				   FrameEnd   subroutine
    579  f800		       85 02		      sta	WSYNC
    580  f802
    581  f802							; Blank all background colors.
    582  f802		       a9 00		      lda	#0
    583  f804		       85 08		      sta	COLUPF
    584  f806		       85 0f		      sta	PF2
    585  f808		       85 0e		      sta	PF1
    586  f80a		       85 1c		      sta	EMERALD_SP
    587  f80c
    588  f80c							; Guide lines (2x)
    589  f80c		       a9 02		      lda	#SIGNAL_LINE
    590  f80e		       85 09		      sta	COLUBK
    591  f810					      REPEAT	6
    592  f810		       85 02		      sta	WSYNC
    591  f810					      REPEND
    592  f812		       85 02		      sta	WSYNC
    591  f812					      REPEND
    592  f814		       85 02		      sta	WSYNC
    591  f814					      REPEND
    592  f816		       85 02		      sta	WSYNC
    591  f816					      REPEND
    592  f818		       85 02		      sta	WSYNC
    591  f818					      REPEND
    592  f81a		       85 02		      sta	WSYNC
    593  f81c					      REPEND
    594  f81c		       a9 00		      lda	#$00
    595  f81e		       85 09		      sta	COLUBK
    596  f820
    597  f820							; Restore stack pointer
    598  f820		       a6 96		      ldx	RamStackBkp
    599  f822		       9a		      txs
    600  f823
    601  f823							; Display the rest of the blank screen.
      0  f823					      TIMER_SETUP	25
      1  f823				   .lines     SET	25
      2  f823		       a9 1d		      lda	#(((.lines)*76-14)/64)
      3  f825		       85 02		      sta	WSYNC
      4  f827		       8d 96 02 	      sta	TIM64T
    603  f82a		       85 02		      sta	WSYNC
      0  f82c					      TIMER_WAIT
      1  f82c				   .waittimer
      2  f82c		       ad 84 02 	      lda	INTIM
      3  f82f		       d0 fb		      bne	.waittimer
      4  f831		       85 02		      sta	WSYNC
      0  f833					      ASSERT_RUNTIME	"_scan == (#37 + #184)"
      1  f833				   .COND      SET	"_scan == (#37 + #184)"
 ASSERT: breakif { pc== $f833  && !(  _scan == (#37 + #184)  ) }
      2  f833					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    606  f833
    607  f833							; Overscan
    608  f833				   Overscan   subroutine
    609  f833		       85 01		      sta	VBLANK
      0  f835					      TIMER_SETUP	29
      1  f835				   .lines     SET	29
      2  f835		       a9 22		      lda	#(((.lines)*76-14)/64)
      3  f837		       85 02		      sta	WSYNC
      4  f839		       8d 96 02 	      sta	TIM64T
    611  f83c
    612  f83c		       20 d6 f9 	      jsr	MoveJoystick
    613  f83f		       20 0d fa 	      jsr	SpeedCalculation
    614  f842		       20 69 fa 	      jsr	game_state_tick
    615  f845
      0  f845					      TIMER_WAIT
      1  f845				   .waittimer
      2  f845		       ad 84 02 	      lda	INTIM
      3  f848		       d0 fb		      bne	.waittimer
      4  f84a		       85 02		      sta	WSYNC
      0  f84c					      ASSERT_RUNTIME	"_scan == (#37 + #184 + #29)"
      1  f84c				   .COND      SET	"_scan == (#37 + #184 + #29)"
 ASSERT: breakif { pc== $f84c  && !(  _scan == (#37 + #184 + #29)  ) }
      2  f84c					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    618  f84c
    619  f84c		       4c 5b f4 	      jmp	VerticalSync
    620  f84f
    621  f84f
    622  f84f
    623  f900		       00 00 00 00*	      align	256
    624  f900
    625  f900					      mac	gemini_populate
    626  f900				   .TARGET    SET	{1}
    627  f900					      lda	RamNibbleTemp
    628  f900					      and	#%00000011
    629  f900					      tay
    630  f900					      lda	GEMINI_LOOKUP,y
    631  f900					      sta	.TARGET
    632  f900					      endm
    633  f900
    634  f900					      mac	gemini_populate_missile
    635  f900				   .TARGET    SET	{1}
    636  f900					      lda	RamNibbleTemp
    637  f900					      and	#%00000001
    638  f900					      sta	.TARGET
    639  f900					      endm
    640  f900
    641  f900				   gemini_populate
    642  f900		       a6 af		      ldx	level_for_game + 3
    643  f902		       86 90		      stx	RamNibbleTemp
      0  f904					      GEMINI_POPULATE	DO_GEMS_B + 5
      1  f904				   .TARGET    SET	DO_GEMS_B + 5
      2  f904		       a5 90		      lda	RamNibbleTemp
      3  f906		       29 03		      and	#%00000011
      4  f908		       a8		      tay
      5  f909		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f90c		       85 bd		      sta	.TARGET
    645  f90e		       66 90		      ror	RamNibbleTemp
    646  f910		       66 90		      ror	RamNibbleTemp
      0  f912					      GEMINI_POPULATE	DO_GEMS_A + 5
      1  f912				   .TARGET    SET	DO_GEMS_A + 5
      2  f912		       a5 90		      lda	RamNibbleTemp
      3  f914		       29 03		      and	#%00000011
      4  f916		       a8		      tay
      5  f917		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f91a		       85 b7		      sta	.TARGET
    648  f91c		       66 90		      ror	RamNibbleTemp
    649  f91e		       66 90		      ror	RamNibbleTemp
      0  f920					      GEMINI_POPULATE	DO_GEMS_B + 4
      1  f920				   .TARGET    SET	DO_GEMS_B + 4
      2  f920		       a5 90		      lda	RamNibbleTemp
      3  f922		       29 03		      and	#%00000011
      4  f924		       a8		      tay
      5  f925		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f928		       85 bc		      sta	.TARGET
    651  f92a		       66 90		      ror	RamNibbleTemp
    652  f92c		       66 90		      ror	RamNibbleTemp
      0  f92e					      GEMINI_POPULATE	DO_GEMS_A + 4
      1  f92e				   .TARGET    SET	DO_GEMS_A + 4
      2  f92e		       a5 90		      lda	RamNibbleTemp
      3  f930		       29 03		      and	#%00000011
      4  f932		       a8		      tay
      5  f933		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f936		       85 b6		      sta	.TARGET
    654  f938		       66 90		      ror	RamNibbleTemp
    655  f93a		       66 90		      ror	RamNibbleTemp
    656  f93c
    657  f93c		       a6 ae		      ldx	level_for_game + 2
    658  f93e		       86 90		      stx	RamNibbleTemp
      0  f940					      GEMINI_POPULATE_MISSILE	DO_MISS_B
      1  f940				   .TARGET    SET	DO_MISS_B
      2  f940		       a5 90		      lda	RamNibbleTemp
      3  f942		       29 01		      and	#%00000001
      4  f944		       85 b1		      sta	.TARGET
    660  f946		       66 90		      ror	RamNibbleTemp
      0  f948					      GEMINI_POPULATE	DO_GEMS_B + 3
      1  f948				   .TARGET    SET	DO_GEMS_B + 3
      2  f948		       a5 90		      lda	RamNibbleTemp
      3  f94a		       29 03		      and	#%00000011
      4  f94c		       a8		      tay
      5  f94d		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f950		       85 bb		      sta	.TARGET
    662  f952		       66 90		      ror	RamNibbleTemp
    663  f954		       66 90		      ror	RamNibbleTemp
      0  f956					      GEMINI_POPULATE	DO_GEMS_A + 3
      1  f956				   .TARGET    SET	DO_GEMS_A + 3
      2  f956		       a5 90		      lda	RamNibbleTemp
      3  f958		       29 03		      and	#%00000011
      4  f95a		       a8		      tay
      5  f95b		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f95e		       85 b5		      sta	.TARGET
    665  f960		       66 90		      ror	RamNibbleTemp
    666  f962		       66 90		      ror	RamNibbleTemp
      0  f964					      GEMINI_POPULATE	DO_GEMS_B + 2
      1  f964				   .TARGET    SET	DO_GEMS_B + 2
      2  f964		       a5 90		      lda	RamNibbleTemp
      3  f966		       29 03		      and	#%00000011
      4  f968		       a8		      tay
      5  f969		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f96c		       85 ba		      sta	.TARGET
    668  f96e		       66 90		      ror	RamNibbleTemp
    669  f970		       66 90		      ror	RamNibbleTemp
    670  f972
    671  f972				   .HELLO
    672  f972		       66 90		      ror	RamNibbleTemp
    673  f974		       a6 ad		      ldx	level_for_game + 1
    674  f976		       86 90		      stx	RamNibbleTemp
    675  f978		       26 90		      rol	RamNibbleTemp
      0  f97a					      GEMINI_POPULATE	DO_GEMS_A + 2
      1  f97a				   .TARGET    SET	DO_GEMS_A + 2
      2  f97a		       a5 90		      lda	RamNibbleTemp
      3  f97c		       29 03		      and	#%00000011
      4  f97e		       a8		      tay
      5  f97f		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f982		       85 b4		      sta	.TARGET
    677  f984
    678  f984		       a6 ad		      ldx	level_for_game + 1
    679  f986		       86 90		      stx	RamNibbleTemp
    680  f988		       66 90		      ror	RamNibbleTemp
      0  f98a					      GEMINI_POPULATE_MISSILE	DO_MISS_A
      1  f98a				   .TARGET    SET	DO_MISS_A
      2  f98a		       a5 90		      lda	RamNibbleTemp
      3  f98c		       29 01		      and	#%00000001
      4  f98e		       85 b0		      sta	.TARGET
    682  f990		       66 90		      ror	RamNibbleTemp
      0  f992					      GEMINI_POPULATE	DO_GEMS_B + 1
      1  f992				   .TARGET    SET	DO_GEMS_B + 1
      2  f992		       a5 90		      lda	RamNibbleTemp
      3  f994		       29 03		      and	#%00000011
      4  f996		       a8		      tay
      5  f997		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f99a		       85 b9		      sta	.TARGET
    684  f99c		       66 90		      ror	RamNibbleTemp
    685  f99e		       66 90		      ror	RamNibbleTemp
      0  f9a0					      GEMINI_POPULATE	DO_GEMS_A + 1
      1  f9a0				   .TARGET    SET	DO_GEMS_A + 1
      2  f9a0		       a5 90		      lda	RamNibbleTemp
      3  f9a2		       29 03		      and	#%00000011
      4  f9a4		       a8		      tay
      5  f9a5		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f9a8		       85 b3		      sta	.TARGET
    687  f9aa		       66 90		      ror	RamNibbleTemp
    688  f9ac		       66 90		      ror	RamNibbleTemp
      0  f9ae					      GEMINI_POPULATE	DO_GEMS_B + 0
      1  f9ae				   .TARGET    SET	DO_GEMS_B + 0
      2  f9ae		       a5 90		      lda	RamNibbleTemp
      3  f9b0		       29 03		      and	#%00000011
      4  f9b2		       a8		      tay
      5  f9b3		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f9b6		       85 b8		      sta	.TARGET
    690  f9b8		       66 90		      ror	RamNibbleTemp
    691  f9ba		       66 90		      ror	RamNibbleTemp
    692  f9bc
    693  f9bc		       a6 ac		      ldx	level_for_game + 0
    694  f9be		       86 90		      stx	RamNibbleTemp
      0  f9c0					      GEMINI_POPULATE	DO_GEMS_A + 0
      1  f9c0				   .TARGET    SET	DO_GEMS_A + 0
      2  f9c0		       a5 90		      lda	RamNibbleTemp
      3  f9c2		       29 03		      and	#%00000011
      4  f9c4		       a8		      tay
      5  f9c5		       b9 d0 f9 	      lda	GEMINI_LOOKUP,y
      6  f9c8		       85 b2		      sta	.TARGET
    696  f9ca		       66 90		      ror	RamNibbleTemp
    697  f9cc		       66 90		      ror	RamNibbleTemp
    698  f9ce
    699  f9ce		       60		      rts
    700  f9cf				   gemini_populate_end
    701  f9cf
    702  f9d0		       00		      align	16
    703  f9d0
    704  f9d0				   GEMINI_LOOKUP
    705  f9d0		       00 60 06 66	      .byte.b	G00, G01, G10, G11
    706  f9d4
    707  f9d4				   SHARD_LUT_RF1
    708  f9d4		       00		      .byte.b	#0
    709  f9d5				   SHARD_LUT_VD1
    710  f9d5		       00		      .byte.b	#0
    711  f9d6
------- FILE main.s
------- FILE game_input.s LEVEL 2 PASS 2
      0  f9d6					      include	"game_input.s"
      1  f9d6							; Handles input checking. Called from overscan.
      2  f9d6
      3  f9d6							; Read joystick movement and apply to object 0
      4  f9d6				   MoveJoystick
      5  f9d6							; Move vertically
      6  f9d6							; (up and down are actually reversed since ypos starts at bottom)
      7  f9d6							;     ldx YPos
      8  f9d6		       a9 10		      lda	#%00010000	;Up?
      9  f9d8		       2c 80 02 	      bit	SWCHA
     10  f9db		       d0 0d		      bne	SkipMoveUp
     11  f9dd
     12  f9dd		       18		      clc
     13  f9de		       a5 89		      lda	Speed2
     14  f9e0		       69 0c		      adc	#12
     15  f9e2		       85 89		      sta	Speed2
     16  f9e4		       a5 88		      lda	Speed1
     17  f9e6		       69 00		      adc	#00
     18  f9e8		       85 88		      sta	Speed1
     19  f9ea
     20  f9ea				   SkipMoveUp
     21  f9ea		       a6 87		      ldx	XPos
     22  f9ec
     23  f9ec							; Only check left/right on odd frames;
     24  f9ec							; TODO make this just a fractional speed
     25  f9ec							; rather than dropping frames
     26  f9ec		       a9 01		      lda	#01
     27  f9ee		       25 84		      and	FrameCount
     28  f9f0		       d0 18		      bne	SkipMoveRight
     29  f9f2
     30  f9f2
     31  f9f2							; Move horizontally
     32  f9f2		       a9 40		      lda	#%01000000	;Left?
     33  f9f4		       2c 80 02 	      bit	SWCHA
     34  f9f7		       d0 05		      bne	SkipMoveLeft
     35  f9f9		       e0 1d		      cpx	#29
     36  f9fb		       90 01		      bcc	SkipMoveLeft
     37  f9fd		       ca		      dex
     38  f9fe
     39  f9fe							; Reflect
     40  f9fe							;     lda #$ff
     41  f9fe							;     sta REFP0
     42  f9fe				   SkipMoveLeft
     43  f9fe		       a9 80		      lda	#%10000000	;Right?
     44  fa00		       2c 80 02 	      bit	SWCHA
     45  fa03		       d0 05		      bne	SkipMoveRight
     46  fa05		       e0 80		      cpx	#128
     47  fa07		       b0 01		      bcs	SkipMoveRight
     48  fa09		       e8		      inx
     49  fa0a
     50  fa0a							; Reflect
     51  fa0a							;     lda #$0
     52  fa0a							;     sta REFP0
     53  fa0a				   SkipMoveRight
     54  fa0a		       86 87		      stx	XPos
     55  fa0c		       60		      rts
     56  fa0d
     57  fa0d
     58  fa0d				   SpeedCalculation
     59  fa0d		       38		      sec
     60  fa0e		       a5 89		      lda	Speed2
     61  fa10		       e9 07		      sbc	#7
     62  fa12		       85 89		      sta	Speed2
     63  fa14		       a5 88		      lda	Speed1
     64  fa16		       e9 00		      sbc	#0
     65  fa18		       85 88		      sta	Speed1
     66  fa1a
     67  fa1a		       18		      clc
     68  fa1b		       a5 8b		      lda	YPos2
     69  fa1d		       65 89		      adc	Speed2
     70  fa1f		       85 8b		      sta	YPos2
     71  fa21		       a5 8a		      lda	YPos
     72  fa23		       65 88		      adc	Speed1
     73  fa25		       85 8a		      sta	YPos
     74  fa27
     75  fa27		       c9 48		      cmp	#FLOOR_OFFSET
     76  fa29		       b0 0a		      bcs	NewThing2
     77  fa2b
     78  fa2b							; Reset to floor
     79  fa2b		       a9 48		      lda	#FLOOR_OFFSET
     80  fa2d		       85 8a		      sta	YPos
     81  fa2f		       a9 00		      lda	#0
     82  fa31		       85 88		      sta	Speed1
     83  fa33		       85 89		      sta	Speed2
     84  fa35				   NewThing2
     85  fa35
     86  fa35		       c9 c0		      cmp	#CEILING_OFFSET
     87  fa37		       90 0a		      bcc	.next
     88  fa39
     89  fa39							; Reset to ceiling
     90  fa39		       a9 c0		      lda	#CEILING_OFFSET
     91  fa3b		       85 8a		      sta	YPos
     92  fa3d		       a9 00		      lda	#0
     93  fa3f		       85 88		      sta	Speed1
     94  fa41		       85 89		      sta	Speed2
     95  fa43				   .next
     96  fa43		       60		      rts
     97  fa44
     98  fa44
     99  fa44
    100  fa44							; Subroutine
    101  fa44				   SetHorizPos
    102  fa44		       85 02		      sta	WSYNC	; start a new line
    103  fa46		       24 00		      bit	0	; waste 3 cycles
    104  fa48		       38		      sec		; set carry flag
    105  fa49				   DivideLoop
    106  fa49		       e9 0f		      sbc	#15	; subtract 15
    107  fa4b		       b0 fc		      bcs	DivideLoop	; branch until negative
    108  fa4d		       49 07		      eor	#7	; calculate fine offset
    109  fa4f		       0a		      asl
    110  fa50		       0a		      asl
    111  fa51		       0a		      asl
    112  fa52		       0a		      asl
    113  fa53		       95 10		      sta	JET_SP_RESET,x	; fix coarse position
    114  fa55		       95 20		      sta	JET_SP_HMOVE,x	; set fine offset
    115  fa57		       60		      rts		; return to caller
------- FILE main.s
------- FILE game_state.s LEVEL 2 PASS 2
      0  fa58					      include	"game_state.s"
      1  fa58				   game_state_setup
      2  fa58							; Set up the level
      3  fa58		       a9 ff		      lda	#%11111111
      4  fa5a		       85 ac		      sta	[level_for_game + 0]
      5  fa5c		       a9 ff		      lda	#%11111111
      6  fa5e		       85 ad		      sta	[level_for_game + 1]
      7  fa60		       a9 7f		      lda	#%01111111
      8  fa62		       85 ae		      sta	[level_for_game + 2]
      9  fa64		       a9 ff		      lda	#%11111111
     10  fa66		       85 af		      sta	[level_for_game + 3]
     11  fa68		       60		      rts
     12  fa69
     13  fa69				   game_state_tick
     14  fa69		       a5 84		      lda	FrameCount
     15  fa6b		       29 1f		      and	#%11111
     16  fa6d		       d0 14		      bne	.skiprotate
     17  fa6f		       a5 af		      lda	level_for_game + 3
     18  fa71		       6a		      ror
     19  fa72				   .rollall
      0  fa72					      _ROR32	level_for_game, level_for_game
      1  fa72		       00 ac	   VLA	      EQU	level_for_game
      2  fa72		       00 ac	   RES	      EQU	level_for_game
      3  fa72				  -	      IF	VLA != RES
      4  fa72				  -	      LDA	VLA+0
      5  fa72				  -	      ROR	A
      6  fa72				  -	      STA	RES+0
      7  fa72				  -	      LDA	VLA+1
      8  fa72				  -	      ROR	A
      9  fa72				  -	      STA	RES+1
     10  fa72				  -	      LDA	VLA+2
     11  fa72				  -	      ROR	A
     12  fa72				  -	      STA	RES+2
     13  fa72				  -	      LDA	VLA+3
     14  fa72				  -	      ROR	A
     15  fa72				  -	      STA	RES+3
     16  fa72					      ELSE
     17  fa72		       66 ac		      ROR	VLA+0
     18  fa74		       66 ad		      ROR	VLA+1
     19  fa76		       66 ae		      ROR	VLA+2
     20  fa78		       66 af		      ROR	VLA+3
     21  fa7a					      ENDIF
     21  fa7a
     22  fa7a		       a9 fb		      lda	#%11111011
     23  fa7c		       c5 ae		      cmp	[level_for_game + 2]
     24  fa7e		       d0 03		      bne	.skiprotate
     25  fa80		       4c 58 fa 	      jmp	game_state_setup
     26  fa83				   .skiprotate
     27  fa83		       60		      rts
------- FILE main.s
------- FILE kernel_border.s LEVEL 2 PASS 2
      0  fa84					      include	"kernel_border.s"
      1  fa84							; Visible Kernel
      2  fa84
      3  fa84				   KernelBorder subroutine
      4  fa84		       85 02		      sta	WSYNC	; ??? Is this needed?
      5  fa86
      6  fa86							; First HMOVE
      7  fa86		       85 2a		      sta	HMOVE
      8  fa88
      9  fa88							; Border top
     10  fa88		       a9 00		      lda	#0
     11  fa8a		       85 08		      sta	COLUPF
     12  fa8c		       85 0e		      sta	PF1
     13  fa8e		       85 0f		      sta	PF2
     14  fa90		       a9 02		      lda	#SIGNAL_LINE
     15  fa92		       85 09		      sta	COLUBK
     16  fa94
     17  fa94					      REPEAT	6
     18  fa94		       85 02		      sta	WSYNC
     17  fa94					      REPEND
     18  fa96		       85 02		      sta	WSYNC
     17  fa96					      REPEND
     18  fa98		       85 02		      sta	WSYNC
     17  fa98					      REPEND
     18  fa9a		       85 02		      sta	WSYNC
     17  fa9a					      REPEND
     18  fa9c		       85 02		      sta	WSYNC
     17  fa9c					      REPEND
     18  fa9e		       85 02		      sta	WSYNC
     19  faa0					      REPEND
     20  faa0
     21  faa0		       a9 00		      lda	#0
     22  faa2		       85 09		      sta	COLUBK
     23  faa4		       85 02		      sta	WSYNC
     24  faa6
     25  faa6							; Start top border
     26  faa6				   border_top
     27  faa6							; Make the playfield solid.
     28  faa6		       a9 3f		      lda	#%00111111
     29  faa8		       85 0e		      sta	PF1
     30  faaa		       a9 ff		      lda	#%11111111
     31  faac		       85 0f		      sta	PF2
     32  faae
     33  faae		       a9 42		      lda	#COL_BG
     34  fab0		       a0 00		      ldy	#0
     35  fab2
     36  fab2							; X_XXXX_XX
     37  fab2							; Commented lines removed to save on space.
     38  fab2		       85 08		      sta	COLUPF
     39  fab4		       85 02		      sta	WSYNC
     40  fab6		       84 08		      sty	COLUPF
     41  fab8		       85 02		      sta	WSYNC
     42  faba		       85 08		      sta	COLUPF
     43  fabc		       85 02		      sta	WSYNC
     44  fabe							; sta COLUPF
     45  fabe		       85 02		      sta	WSYNC
     46  fac0							; sta COLUPF
     47  fac0		       85 02		      sta	WSYNC
     48  fac2		       84 08		      sty	COLUPF
     49  fac4		       85 02		      sta	WSYNC
     50  fac6		       85 08		      sta	COLUPF
     51  fac8
     52  fac8		       85 02		      sta	WSYNC
     53  faca							; sta COLUPF
     54  faca
     55  faca				   PlayArea
     56  faca							; PF is now the playing area
      0  faca					      ASSERT_RUNTIME	"_scycles == #0"
      1  faca				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $faca  && !(  _scycles == #0  ) }
      2  faca					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  faca					      sleep	61
      1  faca				   .CYCLES    SET	61
      2  faca
      3  faca				  -	      IF	.CYCLES < 2
      4  faca				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  faca				  -	      ERR
      6  faca					      ENDIF
      7  faca
      8  faca					      IF	.CYCLES & 1
      9  faca					      IFNCONST	NO_ILLEGAL_OPCODES
     10  faca		       04 00		      nop	0
     11  facc				  -	      ELSE
     12  facc				  -	      bit	VSYNC
     13  facc					      ENDIF
     14  facc				   .CYCLES    SET	.CYCLES - 3
     15  facc					      ENDIF
     16  facc
     17  facc					      REPEAT	.CYCLES / 2
     18  facc		       ea		      nop
     17  facc					      REPEND
     18  facd		       ea		      nop
     17  facd					      REPEND
     18  face		       ea		      nop
     17  face					      REPEND
     18  facf		       ea		      nop
     17  facf					      REPEND
     18  fad0		       ea		      nop
     17  fad0					      REPEND
     18  fad1		       ea		      nop
     17  fad1					      REPEND
     18  fad2		       ea		      nop
     17  fad2					      REPEND
     18  fad3		       ea		      nop
     17  fad3					      REPEND
     18  fad4		       ea		      nop
     17  fad4					      REPEND
     18  fad5		       ea		      nop
     17  fad5					      REPEND
     18  fad6		       ea		      nop
     17  fad6					      REPEND
     18  fad7		       ea		      nop
     17  fad7					      REPEND
     18  fad8		       ea		      nop
     17  fad8					      REPEND
     18  fad9		       ea		      nop
     17  fad9					      REPEND
     18  fada		       ea		      nop
     17  fada					      REPEND
     18  fadb		       ea		      nop
     17  fadb					      REPEND
     18  fadc		       ea		      nop
     17  fadc					      REPEND
     18  fadd		       ea		      nop
     17  fadd					      REPEND
     18  fade		       ea		      nop
     17  fade					      REPEND
     18  fadf		       ea		      nop
     17  fadf					      REPEND
     18  fae0		       ea		      nop
     17  fae0					      REPEND
     18  fae1		       ea		      nop
     17  fae1					      REPEND
     18  fae2		       ea		      nop
     17  fae2					      REPEND
     18  fae3		       ea		      nop
     17  fae3					      REPEND
     18  fae4		       ea		      nop
     17  fae4					      REPEND
     18  fae5		       ea		      nop
     17  fae5					      REPEND
     18  fae6		       ea		      nop
     17  fae6					      REPEND
     18  fae7		       ea		      nop
     17  fae7					      REPEND
     18  fae8		       ea		      nop
     19  fae9					      REPEND
     59  fae9		       a9 00		      lda	#%00000000
     60  faeb		       85 0d		      sta	PF0
     61  faed		       a9 20		      lda	#%00100000
     62  faef		       85 0e		      sta	PF1
     63  faf1		       a9 00		      lda	#%00000000
     64  faf3		       85 0f		      sta	PF2
      0  faf5					      ASSERT_RUNTIME	"_scycles == #0"
      1  faf5				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $faf5  && !(  _scycles == #0  ) }
      2  faf5					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
      0  faf5					      sleep	7
      1  faf5				   .CYCLES    SET	7
      2  faf5
      3  faf5				  -	      IF	.CYCLES < 2
      4  faf5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  faf5				  -	      ERR
      6  faf5					      ENDIF
      7  faf5
      8  faf5					      IF	.CYCLES & 1
      9  faf5					      IFNCONST	NO_ILLEGAL_OPCODES
     10  faf5		       04 00		      nop	0
     11  faf7				  -	      ELSE
     12  faf7				  -	      bit	VSYNC
     13  faf7					      ENDIF
     14  faf7				   .CYCLES    SET	.CYCLES - 3
     15  faf7					      ENDIF
     16  faf7
     17  faf7					      REPEAT	.CYCLES / 2
     18  faf7		       ea		      nop
     17  faf7					      REPEND
     18  faf8		       ea		      nop
     19  faf9					      REPEND
     67  faf9		       4c 2b fb 	      jmp	row_start
     68  fafc							; enter row on cycle 10.
     69  fafc
     70  fafc							; reset the background for bottom of playfield
     71  fafc				   border_bottom
     72  fafc							;sta WSYNC
     73  fafc
     74  fafc							; Form the bottom of the level frame.
     75  fafc		       a9 3f		      lda	#%00111111
     76  fafe		       85 0e		      sta	PF1
     77  fb00		       a9 ff		      lda	#%11111111
     78  fb02		       85 0f		      sta	PF2
     79  fb04
     80  fb04							; Clear all sprites.
     81  fb04		       a9 00		      lda	#0
     82  fb06		       85 1c		      sta	EMERALD_SP
     83  fb08		       85 1b		      sta	JET_SP
     84  fb0a		       85 1e		      sta	EMERALD_MI_ENABLE
     85  fb0c
     86  fb0c		       a9 42		      lda	#COL_BG
     87  fb0e		       a0 00		      ldy	#0
     88  fb10		       85 02		      sta	WSYNC
     89  fb12
     90  fb12		       84 08		      sty	COLUPF
     91  fb14		       85 02		      sta	WSYNC
     92  fb16
     93  fb16		       85 08		      sta	COLUPF
     94  fb18		       85 02		      sta	WSYNC
     95  fb1a
     96  fb1a		       85 02		      sta	WSYNC
     97  fb1c
     98  fb1c		       85 02		      sta	WSYNC
     99  fb1e
    100  fb1e		       84 08		      sty	COLUPF
    101  fb20		       85 02		      sta	WSYNC
    102  fb22
    103  fb22		       85 08		      sta	COLUPF
    104  fb24		       85 02		      sta	WSYNC
    105  fb26		       85 02		      sta	WSYNC
    106  fb28		       4c 00 f8 	      jmp	FrameEnd
------- FILE main.s
------- FILE kernel_row.s LEVEL 2 PASS 2
      0  fb2b					      include	"kernel_row.s"
      1  fb2b							; Frame Start
      2  fb2b
      3  fb2b							; Macros for calculating sprite values (GRPx).
      4  fb2b
      5  fb2b							; mac jet_spritedata_calc
      6  fb2b							;
      7  fb2b							; loads the offset from Frame0 in Y, and the sprite value in A, and stores it in
      8  fb2b							; GRP0.
      9  fb2b					      mac	jet_spritedata_calc
     10  fb2b					      dec	RamRowJetpackIndex
     11  fb2b					      ldy	RamRowJetpackIndex
     12  fb2b					      ldx	Frame0,Y
     13  fb2b					      stx	JET_SP
     14  fb2b					      endm
     15  fb2b
     16  fb2b				   row_start
     17  fb2b
     18  fb2b							; [scanline 1]
     19  fb2b				   row_1
     20  fb2b							; Enter after scanline starts on row "9" and wraps
      0  fb2b					      ASSERT_RUNTIME	"_scycles == #10"
      1  fb2b				   .COND      SET	"_scycles == #10"
 ASSERT: breakif { pc== $fb2b  && !(  _scycles == #10  ) }
      2  fb2b					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     22  fb2b
     23  fb2b							; Load sprite details
     24  fb2b		       a9 0f		      lda	[#SPRITE_HEIGHT + #7]
     25  fb2d		       c5 86		      cmp	SpriteEnd	; 5c
     26  fb2f		       a9 00		      lda	#0	; 2c
     27  fb31							; constant 6c: if carry set, load SpriteEnd into y
     28  fb31		       b0 01		      .byte.b	$b0, $01	; 2c / 3c (taken)  : bcs +01 (skipping 1-byte bit instr)
     29  fb33		       0c		      .byte.b	$0c	; 4c / 0c		: bit (skip next two bytes)
     30  fb34		       a5 86		      lda	SpriteEnd
     31  fb36		       69 08		      adc	#8
     32  fb38		       85 97		      sta	RamRowJetpackIndex
     33  fb3a
     34  fb3a							; Load sprite
     35  fb3a		       c6 97		      dec	RamRowJetpackIndex
     36  fb3c		       a4 97		      ldy	RamRowJetpackIndex
     37  fb3e		       be 00 fe 	      ldx	Frame0,Y
     38  fb41		       86 1b		      stx	JET_SP
     39  fb43
     40  fb43							; TODO assert cycle is not in visible range!
     41  fb43
     42  fb43							; [[[Nibble VM.]]]
     43  fb43		       85 02		      sta	WSYNC
     44  fb45
     45  fb45							; sleep 46
     46  fb45
      0  fb45					      ASSERT_RUNTIME	"_scycles == #0"
      1  fb45				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fb45  && !(  _scycles == #0  ) }
      2  fb45					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     48  fb45
     49  fb45							; [scanline 2]
     50  fb45				   row_2
      0  fb45					      jet_spritedata_calc
      1  fb45		       c6 97		      dec	RamRowJetpackIndex
      2  fb47		       a4 97		      ldy	RamRowJetpackIndex
      3  fb49		       be 00 fe 	      ldx	Frame0,Y
      4  fb4c		       86 1b		      stx	JET_SP
      0  fb4e					      sleep	5
      1  fb4e				   .CYCLES    SET	5
      2  fb4e
      3  fb4e				  -	      IF	.CYCLES < 2
      4  fb4e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb4e				  -	      ERR
      6  fb4e					      ENDIF
      7  fb4e
      8  fb4e					      IF	.CYCLES & 1
      9  fb4e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb4e		       04 00		      nop	0
     11  fb50				  -	      ELSE
     12  fb50				  -	      bit	VSYNC
     13  fb50					      ENDIF
     14  fb50				   .CYCLES    SET	.CYCLES - 3
     15  fb50					      ENDIF
     16  fb50
     17  fb50					      REPEAT	.CYCLES / 2
     18  fb50		       ea		      nop
     19  fb51					      REPEND
     53  fb51
     54  fb51							; Black out playfield
     55  fb51							; TODO This should be done with playfield pixels, not color.
     56  fb51		       a9 00		      lda	#0
     57  fb53		       85 08		      sta	COLUPF
     58  fb55
     59  fb55							; [[[Nibble VM.]]]
      0  fb55					      sleep	27
      1  fb55				   .CYCLES    SET	27
      2  fb55
      3  fb55				  -	      IF	.CYCLES < 2
      4  fb55				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb55				  -	      ERR
      6  fb55					      ENDIF
      7  fb55
      8  fb55					      IF	.CYCLES & 1
      9  fb55					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb55		       04 00		      nop	0
     11  fb57				  -	      ELSE
     12  fb57				  -	      bit	VSYNC
     13  fb57					      ENDIF
     14  fb57				   .CYCLES    SET	.CYCLES - 3
     15  fb57					      ENDIF
     16  fb57
     17  fb57					      REPEAT	.CYCLES / 2
     18  fb57		       ea		      nop
     17  fb57					      REPEND
     18  fb58		       ea		      nop
     17  fb58					      REPEND
     18  fb59		       ea		      nop
     17  fb59					      REPEND
     18  fb5a		       ea		      nop
     17  fb5a					      REPEND
     18  fb5b		       ea		      nop
     17  fb5b					      REPEND
     18  fb5c		       ea		      nop
     17  fb5c					      REPEND
     18  fb5d		       ea		      nop
     17  fb5d					      REPEND
     18  fb5e		       ea		      nop
     17  fb5e					      REPEND
     18  fb5f		       ea		      nop
     17  fb5f					      REPEND
     18  fb60		       ea		      nop
     17  fb60					      REPEND
     18  fb61		       ea		      nop
     17  fb61					      REPEND
     18  fb62		       ea		      nop
     19  fb63					      REPEND
     61  fb63
     62  fb63							; Load PF1 value
     63  fb63		       a9 3f		      lda	#%00111111
     64  fb65		       85 98		      sta	RamPF1Value
     65  fb67
     66  fb67		       a9 04		      lda	#4
     67  fb69		       8d 96 02 	      sta	TIM64T
     68  fb6c
     69  fb6c							; Enable playfield at end of scanline
     70  fb6c		       a9 42		      lda	#COL_BG
     71  fb6e		       85 08		      sta	COLUPF
     72  fb70
     73  fb70							; Set stack pointer for PHP use from RamKernelPhpTarget.
     74  fb70		       a6 9a		      ldx	RamKernelPhpTarget
     75  fb72		       9a		      txs
     76  fb73
     77  fb73							; Set overflow flag
     78  fb73		       24 95		      bit	RamFFByte
     79  fb75
      0  fb75					      ASSERT_RUNTIME	"_scycles == #0"
      1  fb75				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fb75  && !(  _scycles == #0  ) }
      2  fb75					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
     81  fb75
     82  fb75							; [scanline 3]
     83  fb75				   row_3
     84  fb75							; Current row and next two rows.
     85  fb75		       a4 97		      ldy	RamRowJetpackIndex
     86  fb77		       88		      dey
     87  fb78		       be 00 fe 	      ldx	Frame0,Y
     88  fb7b		       86 1b		      stx	JET_SP
     89  fb7d		       88		      dey
     90  fb7e		       be 00 fe 	      ldx	Frame0,Y
     91  fb81		       86 99		      stx	RamKernelGRP0
     92  fb83		       88		      dey
     93  fb84		       be 00 fe 	      ldx	Frame0,Y
     94  fb87		       8e 03 f0 	      stx	[KernelA_GRP0 - $100]
     95  fb8a		       84 97		      sty	RamRowJetpackIndex
     96  fb8c
     97  fb8c							; Idle.
      0  fb8c					      sleep	22
      1  fb8c				   .CYCLES    SET	22
      2  fb8c
      3  fb8c				  -	      IF	.CYCLES < 2
      4  fb8c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fb8c				  -	      ERR
      6  fb8c					      ENDIF
      7  fb8c
      8  fb8c				  -	      IF	.CYCLES & 1
      9  fb8c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fb8c				  -	      nop	0
     11  fb8c				  -	      ELSE
     12  fb8c				  -	      bit	VSYNC
     13  fb8c				  -	      ENDIF
     14  fb8c				  -.CYCLES    SET	.CYCLES - 3
     15  fb8c					      ENDIF
     16  fb8c
     17  fb8c					      REPEAT	.CYCLES / 2
     18  fb8c		       ea		      nop
     17  fb8c					      REPEND
     18  fb8d		       ea		      nop
     17  fb8d					      REPEND
     18  fb8e		       ea		      nop
     17  fb8e					      REPEND
     18  fb8f		       ea		      nop
     17  fb8f					      REPEND
     18  fb90		       ea		      nop
     17  fb90					      REPEND
     18  fb91		       ea		      nop
     17  fb91					      REPEND
     18  fb92		       ea		      nop
     17  fb92					      REPEND
     18  fb93		       ea		      nop
     17  fb93					      REPEND
     18  fb94		       ea		      nop
     17  fb94					      REPEND
     18  fb95		       ea		      nop
     17  fb95					      REPEND
     18  fb96		       ea		      nop
     19  fb97					      REPEND
     99  fb97
    100  fb97							; Setup for kernel
    101  fb97		       38		      sec		; clear carry bit
    102  fb98		       a6 9b		      ldx	RamKernelX
    103  fb9a		       a4 9c		      ldy	RamKernelY
    104  fb9c
    105  fb9c							; Jump immediately into scanlines 4-5 aka "kernel_gem"
    106  fb9c		       a5 aa		      lda	BuildKernelVdel1
    107  fb9e		       85 1c		      sta	EMERALD_SP
    108  fba0		       a5 99		      lda	RamKernelGRP0	; Load sprite 2 into A
    109  fba2							; [scanline 4]
    110  fba2							; [scanline 5]
      0  fba2					      ASSERT_RUNTIME	"_scycles == #73"
      1  fba2				   .COND      SET	"_scycles == #73"
 ASSERT: breakif { pc== $fba2  && !(  _scycles == #73  ) }
      2  fba2					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    112  fba2		       4c 04 f1 	      jmp	CBSRAM_KERNEL_ENTRY
    113  fba5
    114  fba5							; [scanline 6]
    115  fba5
    116  fba5							; Try to avoid page crossing in jet_spritedata_calc
    117  fba5							; TODO enforce this with ASSERT_RUNTIME instead?
    118  fbb0		       00 00 00 00*	      align	16
    119  fbb0
    120  fbb0				   row_after_kernel
    121  fbb0				   row_6
      0  fbb0					      ASSERT_RUNTIME	"_scycles == #0"
      1  fbb0				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $fbb0  && !(  _scycles == #0  ) }
      2  fbb0					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    123  fbb0
    124  fbb0							; Cleanup from the kernel.
    125  fbb0		       a9 00		      lda	#0
    126  fbb2		       85 1e		      sta	EMERALD_MI_ENABLE
    127  fbb4		       85 1c		      sta	EMERALD_SP
    128  fbb6		       85 08		      sta	COLUPF
    129  fbb8		       85 26		      sta	VDELP1
    130  fbba
    131  fbba		       a9 20		      lda	#%00100000
    132  fbbc		       85 0e		      sta	PF1
    133  fbbe
      0  fbbe					      jet_spritedata_calc
      1  fbbe		       c6 97		      dec	RamRowJetpackIndex
      2  fbc0		       a4 97		      ldy	RamRowJetpackIndex
      3  fbc2		       be 00 fe 	      ldx	Frame0,Y
      4  fbc5		       86 1b		      stx	JET_SP
    135  fbc7
    136  fbc7							; Idle.
    137  fbc7		       85 02		      sta	WSYNC
    138  fbc9
    139  fbc9							; [scanline 7]
    140  fbc9				   row_7
      0  fbc9					      jet_spritedata_calc
      1  fbc9		       c6 97		      dec	RamRowJetpackIndex
      2  fbcb		       a4 97		      ldy	RamRowJetpackIndex
      3  fbcd		       be 00 fe 	      ldx	Frame0,Y
      4  fbd0		       86 1b		      stx	JET_SP
      0  fbd2					      sleep	5
      1  fbd2				   .CYCLES    SET	5
      2  fbd2
      3  fbd2				  -	      IF	.CYCLES < 2
      4  fbd2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbd2				  -	      ERR
      6  fbd2					      ENDIF
      7  fbd2
      8  fbd2					      IF	.CYCLES & 1
      9  fbd2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbd2		       04 00		      nop	0
     11  fbd4				  -	      ELSE
     12  fbd4				  -	      bit	VSYNC
     13  fbd4					      ENDIF
     14  fbd4				   .CYCLES    SET	.CYCLES - 3
     15  fbd4					      ENDIF
     16  fbd4
     17  fbd4					      REPEAT	.CYCLES / 2
     18  fbd4		       ea		      nop
     19  fbd5					      REPEND
      0  fbd5					      ASSERT_RUNTIME	"_scycles == #20"
      1  fbd5				   .COND      SET	"_scycles == #20"
 ASSERT: breakif { pc== $fbd5  && !(  _scycles == #20  ) }
      2  fbd5					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    144  fbd5
    145  fbd5		       a9 42		      lda	#COL_BG
    146  fbd7		       85 08		      sta	COLUPF
    147  fbd9
    148  fbd9							; FRAMESWITCH
    149  fbd9		       a9 01		      lda	#01
    150  fbdb		       25 84		      and	FrameCount
    151  fbdd		       d0 11		      bne	loadframe2
    152  fbdf
    153  fbdf							; Perform gem loading for Kernel A.
    154  fbdf
    155  fbdf				   loadframe1
      0  fbdf					      ASSERT_RUNTIME	"_scycles == #32"
      1  fbdf				   .COND      SET	"_scycles == #32"
 ASSERT: breakif { pc== $fbdf  && !(  _scycles == #32  ) }
      2  fbdf					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    157  fbdf
    158  fbdf							; Emerald byte setting 1A
    159  fbdf							; ldx #0
    160  fbdf							; lda KERNEL_STORAGE_R,X
    161  fbdf							; sta GEM_00_W
    162  fbdf							; inx
    163  fbdf							; lda KERNEL_STORAGE_R,X
    164  fbdf							; sta GEM_04_W
    165  fbdf							; inx
    166  fbdf							; lda KERNEL_STORAGE_R,X
    167  fbdf							; sta GEM_09_W
    168  fbdf							; inx
    169  fbdf
    170  fbdf		       85 02		      sta	WSYNC
    171  fbe1
    172  fbe1							; [scanline 8]
      0  fbe1					      jet_spritedata_calc
      1  fbe1		       c6 97		      dec	RamRowJetpackIndex
      2  fbe3		       a4 97		      ldy	RamRowJetpackIndex
      3  fbe5		       be 00 fe 	      ldx	Frame0,Y
      4  fbe8		       86 1b		      stx	JET_SP
      0  fbea					      sleep	5
      1  fbea				   .CYCLES    SET	5
      2  fbea
      3  fbea				  -	      IF	.CYCLES < 2
      4  fbea				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbea				  -	      ERR
      6  fbea					      ENDIF
      7  fbea
      8  fbea					      IF	.CYCLES & 1
      9  fbea					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbea		       04 00		      nop	0
     11  fbec				  -	      ELSE
     12  fbec				  -	      bit	VSYNC
     13  fbec					      ENDIF
     14  fbec				   .CYCLES    SET	.CYCLES - 3
     15  fbec					      ENDIF
     16  fbec
     17  fbec					      REPEAT	.CYCLES / 2
     18  fbec		       ea		      nop
     19  fbed					      REPEND
    175  fbed
    176  fbed							; Emerald byte setting 1B
    177  fbed							; lda KERNEL_STORAGE_R,X
    178  fbed							; sta GEM_13_W
    179  fbed							; inx
    180  fbed							; lda KERNEL_STORAGE_R,X
    181  fbed							; sta GEM_17_W
    182  fbed							; inx
    183  fbed							; lda KERNEL_STORAGE_R,X
    184  fbed							; sta GEM_18_W
    185  fbed							; inx
    186  fbed							; lda KERNEL_STORAGE_R,X
    187  fbed							; sta GEM_22_W
    188  fbed
    189  fbed		       4c 01 fc 	      jmp	row_8_end
    190  fbf0
    191  fbf0							; Perform gem loading for Kernel B.
    192  fbf0
    193  fbf0				   loadframe2
      0  fbf0					      ASSERT_RUNTIME	"_scycles == #33"
      1  fbf0				   .COND      SET	"_scycles == #33"
 ASSERT: breakif { pc== $fbf0  && !(  _scycles == #33  ) }
      2  fbf0					      echo	"ASSERT:", "breakif { pc==", ., " && !( ", .COND, " ) }"
    195  fbf0
    196  fbf0							; Emerald byte setting 2A
    197  fbf0							; ldx #[storage_02 - storage]
    198  fbf0							; lda KERNEL_STORAGE_R,X
    199  fbf0							; sta GEM_02_W
    200  fbf0							; inx
    201  fbf0							; lda KERNEL_STORAGE_R,X
    202  fbf0							; sta GEM_06_W
    203  fbf0							; inx
    204  fbf0							; lda KERNEL_STORAGE_R,X
    205  fbf0							; sta GEM_08_W
    206  fbf0							; inx
    207  fbf0
    208  fbf0		       85 02		      sta	WSYNC
    209  fbf2
    210  fbf2							; [scanline 8]
    211  fbf2				   row_8
      0  fbf2					      jet_spritedata_calc
      1  fbf2		       c6 97		      dec	RamRowJetpackIndex
      2  fbf4		       a4 97		      ldy	RamRowJetpackIndex
      3  fbf6		       be 00 fe 	      ldx	Frame0,Y
      4  fbf9		       86 1b		      stx	JET_SP
      0  fbfb					      sleep	5
      1  fbfb				   .CYCLES    SET	5
      2  fbfb
      3  fbfb				  -	      IF	.CYCLES < 2
      4  fbfb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fbfb				  -	      ERR
      6  fbfb					      ENDIF
      7  fbfb
      8  fbfb					      IF	.CYCLES & 1
      9  fbfb					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fbfb		       04 00		      nop	0
     11  fbfd				  -	      ELSE
     12  fbfd				  -	      bit	VSYNC
     13  fbfd					      ENDIF
     14  fbfd				   .CYCLES    SET	.CYCLES - 3
     15  fbfd					      ENDIF
     16  fbfd
     17  fbfd					      REPEAT	.CYCLES / 2
     18  fbfd		       ea		      nop
     19  fbfe					      REPEND
    214  fbfe
    215  fbfe							; Emerald byte setting 2B
    216  fbfe							; lda KERNEL_STORAGE_R,X
    217  fbfe							; sta GEM_11_W
    218  fbfe							; inx
    219  fbfe							; lda KERNEL_STORAGE_R,X
    220  fbfe							; sta GEM_15_W
    221  fbfe							; inx
    222  fbfe							; lda KERNEL_STORAGE_R,X
    223  fbfe							; sta GEM_20_W
    224  fbfe							; inx
    225  fbfe							; lda KERNEL_STORAGE_R,X
    226  fbfe							; sta GEM_24_W
    227  fbfe
    228  fbfe		       4c 01 fc 	      jmp	row_8_end
    229  fc01
    230  fc01							; Common row 8 return.
    231  fc01
    232  fc01				   row_8_end
    233  fc01							; Decrease SpriteEnd
    234  fc01		       38		      sec
    235  fc02		       a5 86		      lda	SpriteEnd
    236  fc04		       e9 08		      sbc	#8
    237  fc06		       85 86		      sta	SpriteEnd
    238  fc08
    239  fc08							; Idle.
    240  fc08		       85 02		      sta	WSYNC
    241  fc0a
    242  fc0a							; [scanline 8]
    243  fc0a							; Repeat loop until LoopCount < 0
    244  fc0a		       c6 83		      dec	LoopCount
    245  fc0c		       f0 03		      beq	row_end
    246  fc0e		       4c 2b fb 	      jmp	row_start
    247  fc11				   row_end
    248  fc11		       4c fc fa 	      jmp	border_bottom
------- FILE main.s
------- FILE kernel_gem.s LEVEL 2 PASS 2
      0  fc14					      include	"kernel_gem.s"
      1  fc14							;
      2  fc14							; Gem Kernels
      3  fc14							;
      4  fc14							; Gems are displayed in alternating kernels. This chart shows
      5  fc14							; which kernel is responsible for which gem, with missiles denoted.
      6  fc14							;
      7  fc14							;  1:	 |SS  SS  MSS  |SS   SS  SS  |	      kernel 1 (S = Sprite, M = missile)
      8  fc14							;  2:	 |  SS	SS   SS|  SSM  SS  SS|	      kernel 2
      9  fc14							;  =	 |1122112221122|1122111221122|	      kernel #
     10  fc14							;  #	 0^	 8^	  17^	    26^       gem index
     11  fc14							;
     12  fc14							; The middle bar indicates where the pattern reverses.
     13  fc14							;
     14  fc14							; Because we can repeat a sprite multiple times, and reset the sprite
     15  fc14							; occurance mid-line, we can render close to half of the 26 gems a line
     16  fc14							; requires with a single sprite. By alternating sprites each frame with an...
     17  fc14							; acceptable amount of flicker (15Hz) we can render almost all the gems on each
     18  fc14							; line, except for two. These are instead rendered by the missile, which
     19  fc14							; corresponds to the sprite and must have the same color and repeat pattern.
     20  fc14
     21  fc14							; for copying
     22  fd00		       00 00 00 00*	      align	256
     23  fd00
     24  fd00							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     25  fd00							;
     26  fd00							; GEM KERNEL A
     27  fd00							;
     28  fd00
     29  fd00				   kernel_1_start subroutine
     30  fd00					      rorg	$f100
     31  fd00
     32  fd00							; Kernel Marker
     33  fd00		       0a		      .byte.b	$A
     34  fd01
     35  fd01				   KernelA_early
      0  fd01					      ASSERT_RUNTIME_KERNEL	$A, "v == #1"
      1  fd01				   .KERNEL    SET	$A
      2  fd01				   .COND      SET	"v == #1"
 ASSERT: breakif { pc== $f101  && ( *$f100 ==  $a   ) && ! (  v == #1  ) }
      3  fd01					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     37  fd01		       b8		      clv
     38  fd02
     39  fd02							; Early code to set next Player GRP0. Immediate value is overwritten
     40  fd02		       a9 ff		      lda	#$ff
     41  fd02		       f1 03	   KernelA_GRP0 =	. - 1
     42  fd04
     43  fd04				   KernelA    subroutine
      0  fd04					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #0"
      1  fd04				   .KERNEL    SET	$A
      2  fd04				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $a   ) && ! (  _scycles == #0  ) }
      3  fd04					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     45  fd04
     46  fd04							; Write Player from accumulator. When writing to the other sprite, the
     47  fd04							; TIA will copy Gemini 0A into visible sprite register
     48  fd04		       85 1b		      sta	JET_SP
     49  fd06							; Write Gemini 1A into visible sprite register
     50  fd06		       a9 66		      lda	#%01100110
     51  fd06		       f1 07	   KernelA_VDEL0 =	. - 1
     52  fd08		       85 1c		      sta	EMERALD_SP
     53  fd0a
     54  fd0a							; Register config
     55  fd0a		       a9 08		      lda	#%00001000
     56  fd0c		       85 0c		      sta	REFP1
     57  fd0e
     58  fd0e		       a9 20		      lda	#%00100000
     59  fd10		       85 0e		      sta	PF1
     60  fd12
     61  fd12							; Reset stack pointer
     62  fd12		       68		      pla
     63  fd13
     64  fd13							; 22c is critical start of precise GRP0 timing for Kernel A
      0  fd13					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #22"
      1  fd13				   .KERNEL    SET	$A
      2  fd13				   .COND      SET	"_scycles == #22"
 ASSERT: breakif { pc== $f113  && ( *$f100 ==  $a   ) && ! (  _scycles == #22  ) }
      3  fd13					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     66  fd13				   KernelA_A
     67  fd13		       85 11		      sta	EMERALD_SP_RESET	; RESPx must be strobed on cycle 25c.
     68  fd15
     69  fd15							; RST0 vvv
     70  fd15				   KernelA_B
     71  fd15		       a5 98		      lda	RamPF1Value
     72  fd17				   KernelA_C
     73  fd17		       84 26		      sty	VDELP1	; disable delayed sprite
     74  fd19				   KernelA_D
     75  fd19							; sty EMERALD_SP ; Gemini 1A
      0  fd19					      sleep	3
      1  fd19				   .CYCLES    SET	3
      2  fd19
      3  fd19				  -	      IF	.CYCLES < 2
      4  fd19				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd19				  -	      ERR
      6  fd19					      ENDIF
      7  fd19
      8  fd19					      IF	.CYCLES & 1
      9  fd19					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd19		       04 00		      nop	0
     11  fd1b				  -	      ELSE
     12  fd1b				  -	      bit	VSYNC
     13  fd1b					      ENDIF
     14  fd1b				   .CYCLES    SET	.CYCLES - 3
     15  fd1b					      ENDIF
     16  fd1b
     17  fd1b				  -	      REPEAT	.CYCLES / 2
     18  fd1b				  -	      nop
     19  fd1b					      REPEND
     77  fd1b							; RST0 ^^^
     78  fd1b
     79  fd1b				   KernelA_E
     80  fd1b		       85 11		      sta	EMERALD_SP_RESET	; Reset "medium close" NUSIZ repetition
     81  fd1d				   KernelA_F
     82  fd1d		       86 1e		      stx	EMERALD_MI_ENABLE	; Enable the missile (if register uses the %0xx00110 pattern)
     83  fd1f				   KernelA_G
     84  fd1f		       84 1c		      sty	EMERALD_SP	; Gemini 2A
     85  fd21
     86  fd21				   KernelA_H
     87  fd21		       84 1c		      sty	EMERALD_SP	; Gemini 3A, modified for RST2 along with HMM1
     88  fd23
      0  fd23					      ASSERT_RUNTIME_KERNEL	$A, "c == #1"
      1  fd23				   .KERNEL    SET	$A
      2  fd23				   .COND      SET	"c == #1"
 ASSERT: breakif { pc== $f123  && ( *$f100 ==  $a   ) && ! (  c == #1  ) }
      3  fd23					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
     90  fd23							; RST4 vvv
     91  fd23				   KernelA_I
     92  fd23		       08		      php		; Reset "medium close" NUSIZ repetition
     93  fd24				   KernelA_J		; unchanging
     94  fd24		       85 0e		      sta	PF1	; Write asymmetrical playfield register
     95  fd26				   KernelA_K
     96  fd26		       84 1c		      sty	EMERALD_SP	; Gemini 4A
     97  fd28							; RST4 ^^^
     98  fd28
     99  fd28				   KernelA_L
    100  fd28		       a5 93		      lda	RamZeroByte	; FIXME this doesn't belong here
    101  fd2a				   KernelA_M
    102  fd2a		       84 26		      sty	VDELP1	; Gemini 5A ; need a way to skip this vlaue
    103  fd2c				   KernelA_N
    104  fd2c		       85 1e		      sta	EMERALD_MI_ENABLE	; disable missile FIXME better place for this?
    105  fd2e				   KernelA_O
    106  fd2e		       a9 66		      lda	#%01100110
    107  fd2e		       f1 2f	   KernelA_VDEL1 =	. - 1
    108  fd30
    109  fd30							; End visible line
      0  fd30					      ASSERT_RUNTIME_KERNEL	$A, "_scycles == #66"
      1  fd30				   .KERNEL    SET	$A
      2  fd30				   .COND      SET	"_scycles == #66"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $a   ) && ! (  _scycles == #66  ) }
      3  fd30					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    111  fd30				   KernelA_branch
    112  fd30		       85 1c		      sta	EMERALD_SP	; set VDEL1
    113  fd32
    114  fd32							; Branch or return.
    115  fd32		       70 cd		      bvs	KernelA_early
      0  fd34					      sleep	2
      1  fd34				   .CYCLES    SET	2
      2  fd34
      3  fd34				  -	      IF	.CYCLES < 2
      4  fd34				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd34				  -	      ERR
      6  fd34					      ENDIF
      7  fd34
      8  fd34				  -	      IF	.CYCLES & 1
      9  fd34				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd34				  -	      nop	0
     11  fd34				  -	      ELSE
     12  fd34				  -	      bit	VSYNC
     13  fd34				  -	      ENDIF
     14  fd34				  -.CYCLES    SET	.CYCLES - 3
     15  fd34					      ENDIF
     16  fd34
     17  fd34					      REPEAT	.CYCLES / 2
     18  fd34		       ea		      nop
     19  fd35					      REPEND
    117  fd35		       4c b0 fb 	      jmp	row_after_kernel
    118  fd38
    119  fd38					      rend
    120  fd38				   kernel_1_end
      0  fd38					      ASSERT_SIZE	kernel_1_start, kernel_1_end, $40
      1  fd38				   .STARTA    SET	kernel_1_start
      2  fd38				   .ENDA      SET	kernel_1_end
      3  fd38				   .LEN       SET	$40
      4  fd38				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fd38				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fd38				  -	      err
      7  fd38					      endif
    122  fd38
    123  fd38							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    124  fd38							;
    125  fd38							; GEM KERNEL B
    126  fd38							;
    127  fd38
    128  fd38				   kernel_2_start subroutine
    129  fd38					      rorg	$f100
    130  fd38
    131  fd38							; Kernel Marker
    132  fd38		       0b		      .byte.b	$B
    133  fd39
    134  fd39		       b8		      clv
    135  fd3a
    136  fd3a				   KernelB_early
    137  fd3a							; Early code to set next GRP0 image. Value is overwritten
    138  fd3a		       a9 ff		      lda	#$ff
    139  fd3a		       f1 03	   KernelB_GRP0 =	. - 1
    140  fd3c
    141  fd3c				   KernelB    subroutine
      0  fd3c					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #0"
      1  fd3c				   .KERNEL    SET	$B
      2  fd3c				   .COND      SET	"_scycles == #0"
 ASSERT: breakif { pc== $f104  && ( *$f100 ==  $b   ) && ! (  _scycles == #0  ) }
      3  fd3c					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    143  fd3c
    144  fd3c							; Write Player from accumulator. When writing to the other sprite, the
    145  fd3c							; TIA will copy Gemini 0A into visible sprite register
    146  fd3c		       85 1b		      sta	JET_SP
    147  fd3e		       a9 aa		      lda	#%10101010
    148  fd3e		       f1 07	   KernelB_VDEL0 =	. - 1
    149  fd40							; Write Gemini 1A into delayed sprite register
    150  fd40		       85 1c		      sta	EMERALD_SP
    151  fd42
    152  fd42							; Reset stack
    153  fd42		       68		      pla
    154  fd43
    155  fd43							; Register config
    156  fd43		       a9 ff		      lda	#$ff
    157  fd45		       85 1e		      sta	EMERALD_MI_ENABLE	; enable missile
    158  fd47
    159  fd47							; Set processor register bit for PHP sprite rendering.
    160  fd47		       38		      sec
    161  fd47		       f1 0f	   KernelB_P11_C =	. - 1
    162  fd48
    163  fd48							; 6c
    164  fd48		       a9 20		      lda	#%00100000
    165  fd4a		       8d 0e 00 	      sta.w	PF1
    166  fd4d
    167  fd4d							; 25c is critical start of precise GRP0 timing for Kernel B
      0  fd4d					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #25"
      1  fd4d				   .KERNEL    SET	$B
      2  fd4d				   .COND      SET	"_scycles == #25"
 ASSERT: breakif { pc== $f115  && ( *$f100 ==  $b   ) && ! (  _scycles == #25  ) }
      3  fd4d					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    169  fd4d				   KernelB_A
    170  fd4d		       85 11		      sta	EMERALD_SP_RESET
    171  fd4f				   KernelB_B
    172  fd4f		       24 93		      bit	RamZeroByte
    173  fd51				   KernelB_C
    174  fd51							; Load PF1 value into accumulator
    175  fd51		       a5 98		      lda	RamPF1Value
    176  fd53				   KernelB_D
    177  fd53		       86 1c		      stx	EMERALD_SP	; Gemini 1B
    178  fd55
    179  fd55							; below has one php load (could just be RESET)
    180  fd55				   KernelB_E
    181  fd55		       08		      php
    182  fd56				   KernelB_F
    183  fd56		       84 1c		      sty	EMERALD_SP	; Gemini 2B
    184  fd58				   KernelB_G
    185  fd58		       85 0e		      sta	PF1
    186  fd5a				   KernelB_H
    187  fd5a		       84 1c		      sty	EMERALD_SP	; Gemini 3B; TODO write php instead fixed
    188  fd5c							; above has one PHP load
    189  fd5c
    190  fd5c				   KernelB_I
    191  fd5c		       85 11		      sta	EMERALD_SP_RESET
    192  fd5e				   KernelB_J
    193  fd5e		       84 1c		      sty	EMERALD_SP	; Gemini 4B
    194  fd60				   KernelB_K
    195  fd60		       86 1e		      stx	EMERALD_MI_ENABLE
    196  fd62				   KernelB_L
    197  fd62		       86 1c		      stx	EMERALD_SP	; Gemini 5B
    198  fd64
    199  fd64				   KernelB_M
      0  fd64					      sleep	3
      1  fd64				   .CYCLES    SET	3
      2  fd64
      3  fd64				  -	      IF	.CYCLES < 2
      4  fd64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd64				  -	      ERR
      6  fd64					      ENDIF
      7  fd64
      8  fd64					      IF	.CYCLES & 1
      9  fd64					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd64		       04 00		      nop	0
     11  fd66				  -	      ELSE
     12  fd66				  -	      bit	VSYNC
     13  fd66					      ENDIF
     14  fd66				   .CYCLES    SET	.CYCLES - 3
     15  fd66					      ENDIF
     16  fd66
     17  fd66				  -	      REPEAT	.CYCLES / 2
     18  fd66				  -	      nop
     19  fd66					      REPEND
    201  fd66				   KernelB_N
      0  fd66					      sleep	3
      1  fd66				   .CYCLES    SET	3
      2  fd66
      3  fd66				  -	      IF	.CYCLES < 2
      4  fd66				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  fd66				  -	      ERR
      6  fd66					      ENDIF
      7  fd66
      8  fd66					      IF	.CYCLES & 1
      9  fd66					      IFNCONST	NO_ILLEGAL_OPCODES
     10  fd66		       04 00		      nop	0
     11  fd68				  -	      ELSE
     12  fd68				  -	      bit	VSYNC
     13  fd68					      ENDIF
     14  fd68				   .CYCLES    SET	.CYCLES - 3
     15  fd68					      ENDIF
     16  fd68
     17  fd68				  -	      REPEAT	.CYCLES / 2
     18  fd68				  -	      nop
     19  fd68					      REPEND
    203  fd68
    204  fd68							; End visible line
      0  fd68					      ASSERT_RUNTIME_KERNEL	$B, "_scycles == #67"
      1  fd68				   .KERNEL    SET	$B
      2  fd68				   .COND      SET	"_scycles == #67"
 ASSERT: breakif { pc== $f130  && ( *$f100 ==  $b   ) && ! (  _scycles == #67  ) }
      3  fd68					      echo	"ASSERT:", "breakif { pc==", ., " && ( *$f100 == ", .KERNEL, "  ) && ! ( ", .COND, " ) }"
    206  fd68
    207  fd68				   KernelB_branch
    208  fd68		       ad 84 02 	      lda	INTIM
    209  fd6b		       d0 cd		      bne	KernelB_early
    210  fd6d		       4c b0 fb 	      jmp	row_after_kernel
    211  fd70
    212  fd70					      rend
    213  fd70				   kernel_2_end
      0  fd70					      ASSERT_SIZE	kernel_2_start, kernel_2_end, $40
      1  fd70				   .STARTA    SET	kernel_2_start
      2  fd70				   .ENDA      SET	kernel_2_end
      3  fd70				   .LEN       SET	$40
      4  fd70				  -	      if	[[.ENDA - .STARTA] >= .LEN]
      5  fd70				  -	      echo	"Error: Exceeded size limit", [.ENDA - .STARTA], "vs", .LEN
      6  fd70				  -	      err
      7  fd70					      endif
------- FILE main.s
------- FILE data_sprites.s LEVEL 2 PASS 2
      0  fd70					      include	"data_sprites.s"
      1  fd70
      2  fe00		       00 00 00 00*	      align	256
      3  fe00
      4  fe00				   Frame0
      5  fe00							; 8 buffer
      6  fe00		       00		      .byte.b	#%00000000
      7  fe01		       00		      .byte.b	#%00000000
      8  fe02		       00		      .byte.b	#%00000000
      9  fe03		       00		      .byte.b	#%00000000
     10  fe04		       00		      .byte.b	#%00000000
     11  fe05		       00		      .byte.b	#%00000000
     12  fe06		       00		      .byte.b	#%00000000
     13  fe07		       00		      .byte.b	#%00000000
     14  fe08
     15  fe08							; 8 rows
     16  fe08		       60		      .byte.b	#%01100000
     17  fe09		       60		      .byte.b	#%01100000
     18  fe0a		       60		      .byte.b	#%01100000
     19  fe0b		       c0		      .byte.b	#%11000000
     20  fe0c		       c0		      .byte.b	#%11000000
     21  fe0d		       f0		      .byte.b	#%11110000
     22  fe0e		       c0		      .byte.b	#%11000000
     23  fe0f		       c0		      .byte.b	#%11000000
     24  fe10
     25  fe10							; 8 buffer
     26  fe10		       00		      .byte.b	#%00000000
     27  fe11		       00		      .byte.b	#%00000000
     28  fe12		       00		      .byte.b	#%00000000
     29  fe13		       00		      .byte.b	#%00000000
     30  fe14		       00		      .byte.b	#%00000000
     31  fe15		       00		      .byte.b	#%00000000
     32  fe16		       00		      .byte.b	#%00000000
     33  fe17		       00		      .byte.b	#%00000000
------- FILE main.s
------- FILE data_levels.s LEVEL 2 PASS 2
      0  fe18					      include	"data_levels.s"
      1  fe18					      align	8
      2  fe18							; first bit of byte 2 & 3 are unused for simplicity
      3  fe18
      4  fe18				   level_00
      5  fe18		       f0 1f 1f 0f	      .byte.b	%11110000, %00011111, %00011111, %00001111
      6  fe1c
      7  fe1c				   level_01
      8  fe1c		       0a 1e 00 00	      .byte.b	%1010, %0011110, %0000000, %00000000
      9  fe20		       05 1e 00 00	      .byte.b	%0101, %0011110, %0000000, %00000000
     10  fe24		       02 47 40 00	      .byte.b	%0010, %1000111, %1000000, %00000000
     11  fe28		       01 27 40 00	      .byte.b	%0001, %0100111, %1000000, %00000000
     12  fe2c		       00 57 7c 00	      .byte.b	%0000, %1010111, %1111100, %00000000
     13  fe30		       00 28 3c 00	      .byte.b	%0000, %0101000, %0111100, %00000000
     14  fe34		       00 14 3c 00	      .byte.b	%0000, %0010100, %0111100, %00000000
     15  fe38		       00 0a 3c 00	      .byte.b	%0000, %0001010, %0111100, %00000000
     16  fe3c		       00 05 3c 00	      .byte.b	%0000, %0000101, %0111100, %00000000
     17  fe40		       00 02 43 c0	      .byte.b	%0000, %0000010, %1000011, %11000000
     18  fe44		       00 01 23 c0	      .byte.b	%0000, %0000001, %0100011, %11000000
     19  fe48		       00 00 53 c0	      .byte.b	%0000, %0000000, %1010011, %11000000
     20  fe4c		       00 00 2b c0	      .byte.b	%0000, %0000000, %0101011, %11000000
     21  fe50		       00 00 14 3c	      .byte.b	%0000, %0000000, %0010100, %00111100
     22  fe54		       00 00 0a 3c	      .byte.b	%0000, %0000000, %0001010, %00111100
     23  fe58		       00 00 05 3c	      .byte.b	%0000, %0000000, %0000101, %00111100
     24  fe5c		       00 00 02 bc	      .byte.b	%0000, %0000000, %0000010, %10111100
     25  fe60		       0c 00 01 43	      .byte.b	%1100, %0000000, %0000001, %01000011
     26  fe64		       0c 00 00 a3	      .byte.b	%1100, %0000000, %0000000, %10100011
     27  fe68		       0c 00 00 53	      .byte.b	%1100, %0000000, %0000000, %01010011
     28  fe6c		       0c 00 00 2b	      .byte.b	%1100, %0000000, %0000000, %00101011
     29  fe70		       03 60 00 14	      .byte.b	%0011, %1100000, %0000000, %00010100
     30  fe74		       03 60 00 0a	      .byte.b	%0011, %1100000, %0000000, %00001010
     31  fe78		       03 60 00 05	      .byte.b	%0011, %1100000, %0000000, %00000101
     32  fe7c		       0b 60 00 02	      .byte.b	%1011, %1100000, %0000000, %00000010
     33  fe80		       04 1e 00 01	      .byte.b	%0100, %0011110, %0000000, %00000001
     34  fe84				   level_01_end
     35  fe84
     36  fe84
     37  fe84				   shard_map
     38  fe84		       40		      .byte.b	%01000000	; [1, 0, 0]
     39  fe85				   shard_map_end
------- FILE main.s
    162  fe85
    163  fffc					      org	$fffc
    164  fffc		       09 f2		      .word.w	Start
    165  fffe		       09 f2		      .word.w	Start
